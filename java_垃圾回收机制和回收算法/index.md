# Java的垃圾回收机制和回收算法摘抄



[Java的垃圾回收机制和回收算法](https://blog.csdn.net/u012988901/article/details/100117719)
<!--more-->


## 对象是否可回收

我们讨论的garbage collection主要是对Java中堆内存的回收，堆里面主要放的就是对象，那么一个对象是否能回收是如何被判断的呢？

- 引用计数法
- 可达性分析

### 引用计数法（Reference Counting）

- 引用计数法（Reference Counting）：给对象中添加一个引用计数器
- 每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；当计数器为0时对象就是不再被使用的。
- 这种方式实现简单，但是主流垃圾收集器没有用这种方式管理内存的，因为这种方式很难解决循环依赖问题。



### 可达性分析（Reachability Analysis）

- 可达性分析（Reachability Analysis）：通过一系列的称为 "GC Roots" （GC根）的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到对象不可达）时，则证明此对象是不可用的。
- 主流的开发语言都是使用的这种方式判断对象是否存活的。如下图所示，object5，object6，object7虽然相互关联，但是GC Roots是不可达的，所以这些对象是可回收的。
![image for reachability](https://img-blog.csdnimg.cn/20190828155423976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5ODg5MDE=,size_16,color_FFFFFF,t_70)


#### Java中可被作为GC Root的对象主要有：
- 虚拟机栈（栈帧中的本地变量表）中引用对象
- 方法区中的类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈JNI的引用对象
- 激活状态的线程
- 正在被用于同步的各种锁对象
- Class 由系统类加载器(system class loader)加载的对象，这些类不可以被回收，他们可以以静态字段的方式持有其它对象 [more about reference](https://blog.csdn.net/u012988901/article/details/99317272)




### 从对象的生存到死亡




## 垃圾回收的算法

### 标记一清除（Mark-Sweep）算法

#### 算法讲述
- 标记阶段： 首先标记处所有需要回收的对象
- 清除阶段：在标记后统一回收所有被标记的对象

#### 不足：
- 效率问题，标记和清除的效率都不高
- 空间问题，清除后会产生大量不连续的内存碎片，无法分配给太大的对象


### “复制”(Copying)算法

#### 算法讲述
- “复制”(Copying)算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面。
- 然后再把己使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

#### 不足：
- 其缺点是只能用一半内存，浪费资源。


### “复制”(Copying)算法

#### 算法讲述
- “复制”(Copying)算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面。
- 然后再把己使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

- 大部分虚拟机都是采用复制算法回收新生代的，研究表明，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1：1的比例来划分内存空间。Java虚拟机将新生代内存分为一块较大的Eden空间和两块较小的Survivor（S0和S1）空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。Eden：S0：S1的比例默认是8：1：1，每次新生代中可用内存空间为整个新生代容量的90％（80％+10％)，只有10％的内存会被“浪费”。但是不能保证每次都能回收百分之九十多的对象，当Survivor区内存不够用时需要依赖老年代进行分配担保（Handle Promotion），说白了就是去老年代借内存空间，后面再做介绍。



#### 不足：
- 其缺点是只能用一半内存，浪费资源。


### 标记-整理算法 (Mark-Compact)


- 在回收老年代时可能回收后还有很多对象存活，复制算法肯定是不合适的，根据老年代的特点，"标记-整理"
- （Mark-Compact）算法出现了，标记过程仍然与"标记一清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，如下图所示：

![](https://img-blog.csdnimg.cn/20190829001858258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5ODg5MDE=,size_16,color_FFFFFF,t_70)

### 分代收集算法 (Generational Collection)
- 分代收集（Generational Collection）算法是根据对象生存周期的不同，将内存划分为几块。
- Java堆中是分为新生代和老年代，新生代对象朝生夕死选择复制算法。老年代对象存活率高、没有分配担保，必须采用标记-清除或者标记-整理算法进行回收。
