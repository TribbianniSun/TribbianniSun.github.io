# Volatile的使用及其原理



[Volatile的使用及其原理](https://www.cnblogs.com/paddix/p/5428507.html) 
<!--more-->

## 摘抄 [Volatile的使用及其原理](https://www.cnblogs.com/paddix/p/5428507.html) 


### Volatile的作用
我们已经提到过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：**对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。**




### Volatile的使用

#### 防止重排序

- 为什么要在变量singleton之间加上volatile关键字。

#### 实例化一个对象其实可以分为三个步骤：
1）分配内存空间。
2) 初始化对象。
3) 将内存空间的地址赋值给对应的引用。

#### 但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：
1）分配内存空间。
2）将内存空间的地址赋值给对应的引用。
3）初始化对象

#### 实现可见性
- 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

- 对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

3. 保证原子性

- 在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同。
- Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作，如long、double）。
- 要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。volatile是无法保证**复合操作**的原子性。
- volatile是无法保证这复合操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。





### Volatile的实现原理


#### 有序性实现

通俗一点说就是如果a happen-before b，则a所做的任何操作对b是可见的。（这一点大家务必记住，因为happen-before这个词容易被误解为是时间的前后）。我们再来看看JSR 133中定义了哪些happen-before规则：

- 同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。
- 监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则）
- 对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则）
- 线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则）
- 线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。
- 如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。
　
这里我们主要看下第三条：volatile变量的保证有序性的规则。《Java并发编程：核心理论》一文中提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会对volatile变量限制这两种类型的重排序。下面是JMM针对volatile变量所规定的重排序规则表：



#### 可见性的实现 

在前文中已经提及过，线程本身并不直接与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。因此要实现volatile变量的可见性，直接从这方面入手即可。对volatile变量的写操作与普通变量的主要区别有两点：

1）修改volatile变量时会强制将修改后的值刷新的主内存中。
2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。通过这两个操作，就可以解决volatile变量的可见性问题。




