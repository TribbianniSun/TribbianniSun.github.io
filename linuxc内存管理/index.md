# LinuxC内存管理摘抄

[LinuxC内存管理摘抄](https://blog.csdn.net/zqixiao_09/article/details/50381476)
<!--more-->

提到C语言，我们知道C语言和其他高级语言的最大的区别就是C语言是要操作内存的！

我们需要知道，变量，其实是内存地址的一个抽像名字罢了。在静态编译的程序中，所有的变量名都会在编译时被转成内存地址。机器是不知道我们取的名字的，只知道地址。

内存的使用是程序设计中需要考虑的重要因素之一，这不仅由于系统内存是有限的（尤其在嵌入式系统中），而且内存分配也会直接影响到程序的效率。因此，我们要对C语言中的内存管理，有个系统的了解。

在C语言中，定义了4个内存区间：**代码区 code**；**全局变量（静态变量区）static**；**局部变量区即stack**；**动态存储区即heap**；具体如下：

- 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

- 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。

- 全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的 另一块区域。 - 程序结束后由系统释放。

- 常量区 —常量字符串就是放在这里的。 程序结束后由系统释放

- 程序代码区—存放函数体的二进制代码。


![](https://img-blog.csdn.net/20151222180547541?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 编译过程

首先我们要知道，源代码编译成程序，程序是放在硬盘上的，而非内存里！只有执行时才会被调用到内存中！

我们来看看程序结构，ELF是是Linux的主要可执行文件格式。ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。具体如下：

1、Program header描述的是一个段在文件中的位置、大小以及它被放进内存后所在的位置和大小。
1、Program header描述的是一个段在文件中的位置、大小以及它被放进内存后所在的位置和大小。 即要加载的信息；
2、Sections保存着object 文件的信息，从连接角度看：包括指令，数据，符号表，重定位信息等等。在图中，我们可以看到Sections中包括：
      (1)  .text   文本结 存放指令；
      (2)  .rodata   数据结  readonly;
      (3)  .data  数据结 可读可写； 
3、Section头表（section header table）包含了描述文件sections的信息。每个section在这个表中有一个入口；每个入口给出了该section的名字，大小，等等信息。 相当于 索引！

## 加载到内存里
而程序被加载到内存里面，又是如何分布的呢？我们看看上图中：
1、正文和初始化的数据和未初始化的数据就是我们所说的数据段，正文即代码段；
2、正文段上面是常量区，常量区上面是全局变量和静态变量区，二者占据的就是初始化的数据和未初始化的数据那部分；
3、再上面就是堆，动态存储区，这里是上增长；
4、堆上面是栈，存放的是局部变量，就是局部变量所在代码块执行完毕后，这块内存会被释放，这里栈区是下增长；
5、命令行参数就是$0 $1之类的，环境变量什么的前面的文章已经讲过，有兴趣的可以去看看。

## 静态内存

内存管理---存储模型
       存储模型决定了一个变量的内存分配方式和访问特性，在C语言中主要有三个维度来决定：1、存储时期 2、作用域 3、链接

1. 存储时期
       存储时期：变量在内存中的保留时间（生命周期）
       存储时期分为两种情况,关键是看变量在程序执行过程中会不会被系统自动回收掉。
 1)  静态存储时期 Static
        在程序执行过程中一旦分配就不会被自动回收。
        通常来说，任何不在函数级别代码块内定义的变量。
        无论是否在代码块内，只要采用 static关键字修饰的变量。
 2) 自动存储时期  Automatic
        除了静态存储以外的变量都是自动存储时期的，或者说只要是在代码块内定义的非static的变量，系统会肚脐自动非配和释放内存；

2. 作用域
      作用域：一个变量在定义该变量的自身文件中的可见性（访问或者引用）
       在C语言中，一共有3中作用域：
1)  代码块作用域
     在代码块中定义的变量都具有该代码的作用域。从这个变量定义地方开始，到这个代码块结束，该变量是可见的；
2)  函数原型作用域
    出现在函数原型中的变量，都具有函数原型作用域，函数原型作用域从变量定义处一直到原型声明的末尾。
3)  文件作用域
    一个在所有函数之外定义的变量具有文件作用域，具有文件作用域的变量从它的定义处到包含该定义的文件结尾处都是可见的；

3. 链接
      链接：一个变量在组成程序的所有文件中的可见性（访问或者引用）；
      C语言中一共有三种不同的链接：
1)  外部链接
      如果一个变量在组成一个程序的所有文件中的任何位置都可以被访问，则称该变量支持外部链接；
2)  内部链接
    如果一个变量只可以在定义其自身的文件中的任何位置被访问，则称该变量支持内部链接。
3)  空链接   
      如果一个变量只是被定义其自身的当前代码块所私有，不能被程序的其他部分所访问，则成该变量支持空链接
 
```cpp
#include <stdio.h>
 
int a = 0;// 全局初始化区  
char *p1; //全局未初始化区  
 
int main()  
{  
    int b; //b在栈区
    char s[] = "abc"; //栈  
    char *p2; //p2在栈区
    
    char *p3 = "123456"; //123456\0在常量区，p3在栈上。  
    static int c =0； //全局（静态）初始化区
    
    p1 = (char *)malloc(10);  
    p2 = (char *)malloc(20);  //分配得来得10和20字节的区域就在堆区。  
    
    strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。  
}  
```



## 动态内存

当程序运行到需要一个动态分配的变量时，必须向系统申请取得堆中的一块所需大小的存储空间，用于存储该变量。当不在使用该变量时，也就是它的生命结束时，要显示释放它所占用的存储空间，这样系统就能对该空间进行再次分配，做到重复使用有限的资源。下面介绍动态内存申请和释放的函数。


### malloc函数

使用该函数时，有下面几点要注意：
1）只关心申请内存的大小；
2）申请的是一块连续的内存。记得一定要写出错判断；
3）显示初始化。即我们不知这块内存中有什么东西，要对其清零；

### free函数
使用free(),也有下面几点要注意：
1）必须提供内存的起始地址；
    调用该函数时，必须提供内存的起始地址，不能够提供部分地址，释放内存中的一部分是不允许的。
2）malloc和free配对使用；
编译器不负责动态内存的释放，需要程序员显示释放。因此，malloc与free是配对使用的，避免 内存泄漏。
3）不允许重复释放
因为这块内存被释放后，可能已另分配，这块区域被别人占用，如果再次释放，会造成数据丢失；


## 我们经常将堆和栈相比较：

### 申请方式 
stack:  由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 
heap:  需要程序员自己申请，并指明大小，在c中malloc函数 ,如p1 = (char *)malloc(10); 
 
### 申请后系统的响应 
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 

### 申请大小的限制 
栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

### 申请效率的比较： 
栈由系统自动分配，速度较快。但程序员是无法控制的。 
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。 

### 堆和栈中的存储内容 
栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。  当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 

### 存取效率的比较 

char s1[] = "aaaaaaaaaaaaaaa"; 
char *s2 = "bbbbbbbbbbbbbbbbb"; 
aaaaaaaaaaa是在运行时刻赋值的； 
而bbbbbbbbbbb是在编译时就确定的； 
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 
第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。 
```cpp
#include  
void main()  
{  
    char a = 1;  
    char c[] = "1234567890";  
    char *p ="1234567890";  
    a = c[1];  
    a = p[1];  
    return;  
}  

0: a = c[1];  
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]  
0040106A 88 4D FC mov byte ptr [ebp-4],cl  
11: a = p[1];  
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]  
00401070 8A 42 01 mov al,byte ptr [edx+1]  
00401073 88 45 FC mov byte ptr [ebp-4],al  

第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。 
```

## 小结

堆和栈的区别可以用如下的比喻来看出： 

- 栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。  
- 堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。

