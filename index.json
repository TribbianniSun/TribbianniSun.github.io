[{"categories":["interview cheatsheet"],"content":"Synchronized和lock的使用分析","date":"2021-03-04","objectID":"/synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析","uri":"/synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"Synchronized和lock的使用分析 ","date":"2021-03-04","objectID":"/synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析","uri":"/synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"String能否被继承","date":"2021-03-04","objectID":"/string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/","tags":["wi21-week9","interview prep","Java"],"title":"String能否被继承","uri":"/string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/"},{"categories":["interview cheatsheet"],"content":"String能否被继承 根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。 　 final类不能被继承，没有子类，final类中的方法默认是final的。 final方法不能被子类的方法覆盖，但可以被继承。 final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 final不能用于修饰构造方法。 注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。 如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。 使用final方法的原因有二：　 第一、把方法锁定，防止任何继承类修改它的意义和实现。 第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。（这点有待商榷，《Java编程思想》中对于这点存疑） Java中，是否可以继承String类？为什么？ 答案： 不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。 ","date":"2021-03-04","objectID":"/string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"String能否被继承","uri":"/string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/"},{"categories":["interview cheatsheet"],"content":"Java的垃圾回收机制和回收算法","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"Java的垃圾回收机制和回收算法 ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"对象是否可回收 我们讨论的garbage collection主要是对Java中堆内存的回收，堆里面主要放的就是对象，那么一个对象是否能回收是如何被判断的呢？ 引用计数法 可达性分析 ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:0","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"引用计数法（Reference Counting） 引用计数法（Reference Counting）：给对象中添加一个引用计数器 每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；当计数器为0时对象就是不再被使用的。 这种方式实现简单，但是主流垃圾收集器没有用这种方式管理内存的，因为这种方式很难解决循环依赖问题。 ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:1","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"可达性分析（Reachability Analysis） 可达性分析（Reachability Analysis）：通过一系列的称为 “GC Roots” （GC根）的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到对象不可达）时，则证明此对象是不可用的。 主流的开发语言都是使用的这种方式判断对象是否存活的。如下图所示，object5，object6，object7虽然相互关联，但是GC Roots是不可达的，所以这些对象是可回收的。 Java中可被作为GC Root的对象主要有： 虚拟机栈（栈帧中的本地变量表）中引用对象 方法区中的类静态属性引用的对象 方法区中常量引用的对象 本地方法栈JNI的引用对象 激活状态的线程 正在被用于同步的各种锁对象 Class 由系统类加载器(system class loader)加载的对象，这些类不可以被回收，他们可以以静态字段的方式持有其它对象 more about reference ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:2","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"从对象的生存到死亡 ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:3","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"垃圾回收的算法 ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:0","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"标记一清除（Mark-Sweep）算法 算法讲述 标记阶段： 首先标记处所有需要回收的对象 清除阶段：在标记后统一回收所有被标记的对象 不足： 效率问题，标记和清除的效率都不高 空间问题，清除后会产生大量不连续的内存碎片，无法分配给太大的对象 ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:1","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"“复制”(Copying)算法 算法讲述 “复制”(Copying)算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面。 然后再把己使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 不足： 其缺点是只能用一半内存，浪费资源。 ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:2","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"“复制”(Copying)算法 算法讲述 “复制”(Copying)算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面。 然后再把己使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 大部分虚拟机都是采用复制算法回收新生代的，研究表明，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1：1的比例来划分内存空间。Java虚拟机将新生代内存分为一块较大的Eden空间和两块较小的Survivor（S0和S1）空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。Eden：S0：S1的比例默认是8：1：1，每次新生代中可用内存空间为整个新生代容量的90％（80％+10％)，只有10％的内存会被“浪费”。但是不能保证每次都能回收百分之九十多的对象，当Survivor区内存不够用时需要依赖老年代进行分配担保（Handle Promotion），说白了就是去老年代借内存空间，后面再做介绍。 不足： 其缺点是只能用一半内存，浪费资源。 ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:3","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"标记-整理算法 (Mark-Compact) 在回收老年代时可能回收后还有很多对象存活，复制算法肯定是不合适的，根据老年代的特点，“标记-整理” （Mark-Compact）算法出现了，标记过程仍然与\"标记一清除\"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，如下图所示： ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:4","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"分代收集算法 (Generational Collection) 分代收集（Generational Collection）算法是根据对象生存周期的不同，将内存划分为几块。 Java堆中是分为新生代和老年代，新生代对象朝生夕死选择复制算法。老年代对象存活率高、没有分配担保，必须采用标记-清除或者标记-整理算法进行回收。 ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:5","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"红黑树与AVL树的区别与联系？","date":"2021-03-04","objectID":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/","tags":["wi21-week9","interview prep","算法"],"title":"红黑树和AVL树","uri":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"红黑树与AVL树的区别与联系？ ","date":"2021-03-04","objectID":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:0:0","tags":["wi21-week9","interview prep","算法"],"title":"红黑树和AVL树","uri":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"红黑树总结 节点都是红色或者黑色 根结点是黑色 所有叶子结点都是黑色 每个红色节点必须有两个黑色的叶子结点 从任意一个节点到每个叶子节点的简单路径都包含相同数目的黑色节点 ","date":"2021-03-04","objectID":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:1:0","tags":["wi21-week9","interview prep","算法"],"title":"红黑树和AVL树","uri":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"AVL树总结 AVL的条件是左右树的高度差不能大于1，并且他的每个子树也都是平衡二叉树 对于平衡二叉树的最小个数， n0=0 ; n1=1 ; nk=n(k-1)+n(k-2)+1 ;(求法可以类比斐波那契！) ","date":"2021-03-04","objectID":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:2:0","tags":["wi21-week9","interview prep","算法"],"title":"红黑树和AVL树","uri":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"红黑树和AVL树的相同点 就插入节点导致树失衡的情况，AVL和RB-Tree都是最多两次树旋转来实现复衡rebalance，旋转的量级是O(1) 删除节点导致失衡，AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN)，而RB-Tree最多只需要旋转3次实现复衡，只需O(1)，所以说RB-Tree删除节点的rebalance的效率更高，开销更小！ AVL的结构相较于RB-Tree更为平衡，插入和删除引起失衡，如2所述，RB-Tree复衡效率更高；当然，由于AVL高度平衡，因此AVL的Search效率更高啦。 红黑树的查询性能略微逊色于AVL树，因为其比AVL树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的AVL树最多多一次比较，但是，红黑树在插入和删除上优于AVL树，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多 总结：实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。 ","date":"2021-03-04","objectID":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:3:0","tags":["wi21-week9","interview prep","算法"],"title":"红黑树和AVL树","uri":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"volatile有何作用？volatile有何使用场景？volatile的实现原理是什么？","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatile的使用及其原理 ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"摘抄 Volatile的使用及其原理 ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:0","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatile的作用 我们已经提到过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。 ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:1","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatile的使用 防止重排序 为什么要在变量singleton之间加上volatile关键字。 实例化一个对象其实可以分为三个步骤： 1）分配内存空间。 2) 初始化对象。 3) 将内存空间的地址赋值给对应的引用。 但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程： 1）分配内存空间。 2）将内存空间的地址赋值给对应的引用。 3）初始化对象 实现可见性 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 保证原子性 在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同。 Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作，如long、double）。 要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。volatile是无法保证复合操作的原子性。 volatile是无法保证这复合操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。 ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:2","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatile的实现原理 有序性实现 通俗一点说就是如果a happen-before b，则a所做的任何操作对b是可见的。（这一点大家务必记住，因为happen-before这个词容易被误解为是时间的前后）。我们再来看看JSR 133中定义了哪些happen-before规则： 同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。 监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则） 对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则） 线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则） 线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。 如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。 这里我们主要看下第三条：volatile变量的保证有序性的规则。《Java并发编程：核心理论》一文中提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会对volatile变量限制这两种类型的重排序。下面是JMM针对volatile变量所规定的重排序规则表： 可见性的实现 在前文中已经提及过，线程本身并不直接与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。因此要实现volatile变量的可见性，直接从这方面入手即可。对volatile变量的写操作与普通变量的主要区别有两点： 1）修改volatile变量时会强制将修改后的值刷新的主内存中。 2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。通过这两个操作，就可以解决volatile变量的可见性问题。 ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:3","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？","date":"2021-03-04","objectID":"/concurrenthashmap%E5%92%8Chashmap/","tags":["wi21-week9","interview prep","Java"],"title":"ConcurrentHashMap是如何保证线程安全的","uri":"/concurrenthashmap%E5%92%8Chashmap/"},{"categories":["interview cheatsheet"],"content":"ConcurrentHashMap是如何保证线程安全的 ","date":"2021-03-04","objectID":"/concurrenthashmap%E5%92%8Chashmap/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"ConcurrentHashMap是如何保证线程安全的","uri":"/concurrenthashmap%E5%92%8Chashmap/"},{"categories":["interview cheatsheet"],"content":"参考 ConcurrentHashMap是如何保证线程安全的 HashMap和HashTable的区别 HashTable 是非常高效率的数据结构，但HashMap和HashTable在线程的环境下使用并不合理 HashMap: HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成，具体原因自行百度google或查看源码分析），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。 HashTable:HashTable和HashMap的实现原理几乎一样，差别无非是1.HashTable不允许key和value为null；2.HashTable是线程安全的。但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。 使用ConcurrentHashMap解决全段锁的问题 和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。 原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。 1.7 如何实现呢？这就用到了ConcurrentHashMap中最关键的Segment。 ConcurrentHashMap中维护着一个Segment数组，每个Segment可以看做是一个HashMap。 而Segment本身继承了ReentrantLock，它本身就是一个锁。 在Segment中通过HashEntry数组来维护其内部的hash表。 每个HashEntry就代表了map中的一个K-V，用HashEntry可以组成一个链表结构，通过next字段引用到其下一个元素。 PUT的流程 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。 最后会解除在 1 中所获取当前 Segment 的锁。 GET的流程 只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。 由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。 ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。 1.8 其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。 PUT的流程 根据 key 计算出 hashcode。 判断是否需要进行初始化。 f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。 如果都不满足，则利用 synchronized 锁写入数据。 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。 GET的流程 根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。 如果是红黑树那就按照树的方式获取值，若不满足那就按照链表的方式遍历获取值。 常见关于 HashMap || ConcurrentHashMap 的问题整理 谈谈你理解的 HashMap，讲讲其中的 get put 过程。 1.8 做了什么优化？ 是线程安全的嘛？ 不安全会导致哪些问题？ 如何解决？有没有线程安全的并发容器？ ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？ ","date":"2021-03-04","objectID":"/concurrenthashmap%E5%92%8Chashmap/:0:1","tags":["wi21-week9","interview prep","Java"],"title":"ConcurrentHashMap是如何保证线程安全的","uri":"/concurrenthashmap%E5%92%8Chashmap/"},{"categories":["interview cheatsheet"],"content":"中国面试八股文背诵链接","date":"2021-03-03","objectID":"/eight_legged_essay/","tags":["wi21-week9","interview prep"],"title":"Eight_legged_essay","uri":"/eight_legged_essay/"},{"categories":["interview cheatsheet"],"content":"文章链接总结 https://blog.csdn.net/huangqili1314/article/details/79448187 https://github.com/Moosphan/Android-Daily-Interview https://osjobs.net/topk/ ","date":"2021-03-03","objectID":"/eight_legged_essay/:0:1","tags":["wi21-week9","interview prep"],"title":"Eight_legged_essay","uri":"/eight_legged_essay/"},{"categories":["Leetcode Problem"],"content":"New BFS to solve Leetcode 786 - K-th Smallest Prime Fraction ","date":"2021-02-22","objectID":"/leetcode_786/:0:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 786 You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k. For every i and j where 0 \u003c= i \u003c j \u003c arr.length, we consider the fraction arr[i] / arr[j]. Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j]. ","date":"2021-02-22","objectID":"/leetcode_786/:1:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Example Test Cases Leetcode 786 Example1: Input: arr = [1,2,3,5], k = 3 Output: [2,5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3. The third fraction is 2/5. ","date":"2021-02-22","objectID":"/leetcode_786/:2:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 786 // BFS vector\u003cint\u003e global_arr; class Node { public: int denominator; int numerator; double val; Node(int de, int nu){ this -\u003e denominator = de; this -\u003e numerator = nu; this -\u003e val = (double)global_arr[nu] / global_arr[de]; } }; class Compare { public: bool operator() (Node\u0026 n1, Node\u0026 n2) { return n1.val \u003e n2.val; } }; class Solution { public: vector\u003cint\u003e kthSmallestPrimeFraction(vector\u003cint\u003e\u0026 arr, int k) { global_arr.clear(); for(int i : arr){ global_arr.push_back(i); } std::priority_queue\u003cNode, std::vector\u003cNode\u003e, Compare\u003e pq; for(int i = 1; i \u003c arr.size(); i++){ Node cur(i, 0); pq.push(cur); } for(int i = 0; i \u003c k - 1; ++i){ // cout \u003c\u003c pq.top().numerator \u003c\u003c \" \" \u003c\u003c pq.top().denominator \u003c\u003c endl; Node cur = pq.top(); pq.pop(); if(cur.numerator == cur.denominator - 1){ continue; } else{ cur.numerator += 1; cur.val = (double)global_arr[cur.numerator] / global_arr[cur.denominator]; pq.push(cur); } } // cout \u003c\u003c global_arr[pq.top().numerator] \u003c\u003c \" \" \u003c\u003c global_arr[pq.top().denominator]; vector\u003cint\u003e ret{global_arr[pq.top().numerator], global_arr[pq.top().denominator]}; return ret; } }; ","date":"2021-02-22","objectID":"/leetcode_786/:3:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Leetcode 786 Using Heap O(k * log(n)) solution ","date":"2021-02-22","objectID":"/leetcode_786/:4:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"New BFS to solve Leetcode 1091 - Shortest Path in Binary Matrix. ","date":"2021-02-10","objectID":"/leetcode_1091/:0:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 1091 In an N by N square grid, each cell is either empty (0) or blocked (1). A clear path from top-left to bottom-right has length k if and only if it is composed of cells C_1, C_2, …, C_k such that: Adjacent cells C_i and C_{i+1} are connected 8-directionally (ie., they are different and share an edge or corner) C_1 is at location (0, 0) (ie. has value grid[0][0]) C_k is at location (N-1, N-1) (ie. has value grid[N-1][N-1]) If C_i is located at (r, c), then grid[r][c] is empty (ie. grid[r][c] == 0). Return the length of the shortest such clear path from top-left to bottom-right. If such a path does not exist, return -1. ","date":"2021-02-10","objectID":"/leetcode_1091/:1:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Example Test Cases Leetcode 1091 Example1: Input: [[0,1],[1,0]] Output: 2 ","date":"2021-02-10","objectID":"/leetcode_1091/:2:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 1091 // BFS class Solution { public: int shortestPathBinaryMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { if(grid[0][0] == 1){ return -1; } deque\u003cint\u003e q; set\u003cint\u003e seen; int m = grid.size(), n = grid[0].size(); int step = 1; seen.insert(0); q.push_back(0); while(q.size()){ int width = q.size(); for(int i = 0; i \u003c width; ++i){ int p = q.front(); q.pop_front(); int r = p / n, c = p % n; if(r == m - 1 \u0026\u0026 c == n -1){ return step; } for(int j = -1; j \u003c= 1; j++){ for(int k = -1; k \u003c= 1; k++){ if(j == 0 \u0026\u0026 k == 0){ continue; } else{ int nr = r + j, nc = c + k; int np = nr * n + nc; if(nr \u003e= 0 \u0026\u0026 nr \u003c m \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n \u0026\u0026 seen.find(np) == seen.end() \u0026\u0026 grid[nr][nc] == 0){ seen.insert(np); q.push_back(np); } } } } } step += 1; } return -1; } }; ","date":"2021-02-10","objectID":"/leetcode_1091/:3:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Leetcode 1091 Dimension Reduction + 8 direction loop O(m*n) solution ","date":"2021-02-10","objectID":"/leetcode_1091/:4:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 284 - Peeking Iterator","date":"2021-02-08","objectID":"/leetcode_284/","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"New Idea to solve Leetcode 284 - Peeking Iterator. ","date":"2021-02-08","objectID":"/leetcode_284/:0:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 284 Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next(). ","date":"2021-02-08","objectID":"/leetcode_284/:1:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Example Test Cases Leetcode 284 Example1: Assume that the iterator is initialized to the beginning of the list: [1,2,3]. Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2. You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false. ","date":"2021-02-08","objectID":"/leetcode_284/:2:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 284 # Below is the interface for Iterator, which is already defined for you. # # class Iterator: # def __init__(self, nums): # \"\"\" # Initializes an iterator object to the beginning of a list. # :type nums: List[int] # \"\"\" # # def hasNext(self): # \"\"\" # Returns true if the iteration has more elements. # :rtype: bool # \"\"\" # # def next(self): # \"\"\" # Returns the next element in the iteration. # :rtype: int # \"\"\" class PeekingIterator: def __init__(self, iterator): \"\"\" Initialize your data structure here. :type iterator: Iterator \"\"\" self.isCalled = False self.ret = 0 self.it = iterator def peek(self): \"\"\" Returns the next element in the iteration without advancing the iterator. :rtype: int \"\"\" if(self.isCalled): return self.ret else: self.ret = self.it.next() self.isCalled = True return self.ret def next(self): \"\"\" :rtype: int \"\"\" if(self.isCalled): self.isCalled = False return self.ret else: return self.it.next() def hasNext(self): \"\"\" :rtype: bool \"\"\" return self.it.hasNext() or self.isCalled # Your PeekingIterator object will be instantiated and called as such: # iter = PeekingIterator(Iterator(nums)) # while iter.hasNext(): # val = iter.peek() # Get the next element but not advance the iterator. # iter.next() # Should return the same value as [val]. ","date":"2021-02-08","objectID":"/leetcode_284/:3:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Leetcode 284 peek will differ at most one with the actual iterator, therefore use a boolean to remember diff or not O(1) solution ","date":"2021-02-08","objectID":"/leetcode_284/:4:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 638 - Shopping Offers","date":"2021-02-04","objectID":"/leetcode_638/","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Use Dynamic Programming to solve Leetcode 638 - Shopping Offers. ","date":"2021-02-04","objectID":"/leetcode_638/:0:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 638 In LeetCode Store, there are some kinds of items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. You are given the each item’s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer. You could use any of special offers as many times as you want. ","date":"2021-02-04","objectID":"/leetcode_638/:1:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 638 Example1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B. You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A. Example2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation: The price of A is $2, and $3 for B, $4 for C. You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. You cannot add more items, though only $9 for 2A ,2B and 1C. ","date":"2021-02-04","objectID":"/leetcode_638/:2:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 638 class Solution { public: unordered_map\u003cstring, int\u003e cache; vector\u003cint\u003e _p; vector\u003cvector\u003cint\u003e\u003e _s; string vector2str(vector\u003cint\u003e\u0026 num){ vector\u003cchar\u003e v; for(int i = 0; i \u003c num.size(); ++i){ v.push_back('a' + num[i]); } string s(v.begin(), v.end()); return s; } int helper(vector\u003cint\u003e\u0026 state){ string s = vector2str(state); if(cache.find(s) != cache.end()){ return cache[s]; } int ret = 0; for(int i = 0; i \u003c state.size(); ++i){ ret += (state[i] * _p[i]); } for(int i = 0; i \u003c _s.size(); ++i){ vector\u003cint\u003e ns = state; int j; for(j = 0; j \u003c _s[i].size() - 1; j++){ ns[j] -= _s[i][j]; if(ns[j] \u003c 0){ break; } } if(j == _s[i].size() - 1){ ret = min(ret, _s[i][j] + helper(ns)); } } return cache[vector2str(state)] = ret; } int shoppingOffers(vector\u003cint\u003e\u0026 price, vector\u003cvector\u003cint\u003e\u003e\u0026 special, vector\u003cint\u003e\u0026 needs) { _p = price; _s = special; vector\u003cint\u003e startState(needs.size(), 0); cache[vector2str(startState)] = 0; return helper(needs); } }; ","date":"2021-02-04","objectID":"/leetcode_638/:3:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Recursion + Memorization Top Down, and We can simply try to buy all the items by the original price as the starting ret to compare later. ","date":"2021-02-04","objectID":"/leetcode_638/:4:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["cpp cheatsheet"],"content":"cpp handy reference","date":"2021-02-03","objectID":"/cpp_handy_1/","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"cpp cheatsheet 1. ","date":"2021-02-03","objectID":"/cpp_handy_1/:0:0","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"Binary Search related library function lower_bound upper_bound binary_search (beginIterator, endInterator, val) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:0","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"lower_bound lower_bound(beginIterator, endInterator, target) Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val. greater than or equal to the target if no elements satisfies the condition, simply return the endInterator(out of bound) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:1","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"upper_bound upper_bound(beginIterator, endInterator, target)s Returns an iterator pointing to the first element in the range [first,last) which compares greater than val. strictly greater than the target if no element satisfies the condition, simply return the endInterator(out of bound) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:2","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"binary_search binary_search(beginIterator, endInterator, val) true if exist, false otherwise. int main() { vector\u003cint\u003e _v; for(int i = 0; i \u003c 5; i++){ _v.push_back(i); _v.push_back(i + 3); } // must be sorted in increasing order // note that rbegin, rend, reverse order is not allowed sort(_v.begin(), _v.end()); cout \u003c\u003c lower_bound(_v.begin(), _v.end(), 4) - _v.begin() \u003c\u003c '\\n'; return 0; } ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:3","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["codeforce"],"content":"codeforce 1","date":"2021-02-03","objectID":"/codeforce_1/","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"codeforce 1475D, share my solution for these this codeforce problem. ","date":"2021-02-03","objectID":"/codeforce_1/:0:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Description D. Cleaning the Phone ","date":"2021-02-03","objectID":"/codeforce_1/:1:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Introduction D. Cleaning the Phone Polycarp often uses his smartphone. He has already installed 𝑛 applications on it. Application with number 𝑖 takes up 𝑎𝑖 units of memory. Polycarp wants to free at least 𝑚 units of memory (by removing some applications). Of course, some applications are more important to Polycarp than others. He came up with the following scoring system — he assigned an integer 𝑏𝑖 to each application: 𝑏𝑖=1 — regular application; 𝑏𝑖=2 — important application. According to this rating system, his phone has 𝑏1+𝑏2+…+𝑏𝑛 convenience points. Polycarp believes that if he removes applications with numbers 𝑖1,𝑖2,…,𝑖𝑘, then he will free 𝑎𝑖1+𝑎𝑖2+…+𝑎𝑖𝑘 units of memory and lose 𝑏𝑖1+𝑏𝑖2+…+𝑏𝑖𝑘 convenience points. For example, if 𝑛=5, 𝑚=7, 𝑎=[5,3,2,1,4], 𝑏=[2,1,1,2,1], then Polycarp can uninstall the following application sets (not all options are listed below): applications with numbers 1,4 and 5. In this case, it will free 𝑎1+𝑎4+𝑎5=10 units of memory and lose 𝑏1+𝑏4+𝑏5=5 convenience points; applications with numbers 1 and 3. In this case, it will free 𝑎1+𝑎3=7 units of memory and lose 𝑏1+𝑏3=3 convenience points. applications with numbers 2 and 5. In this case, it will free 𝑎2+𝑎5=7 memory units and lose 𝑏2+𝑏5=2 convenience points. Help Polycarp, choose a set of applications, such that if removing them will free at least 𝑚 units of memory and lose the minimum number of convenience points, or indicate that such a set does not exist. ","date":"2021-02-03","objectID":"/codeforce_1/:1:1","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Input D. Cleaning the Phone Input The first line contains one integer 𝑡 (1≤𝑡≤104) — the number of test cases. Then 𝑡 test cases follow. The first line of each test case contains two integers 𝑛 and 𝑚 (1≤𝑛≤2⋅105, 1≤𝑚≤109) — the number of applications on Polycarp’s phone and the number of memory units to be freed. The second line of each test case contains 𝑛 integers 𝑎1,𝑎2,…,𝑎𝑛 (1≤𝑎𝑖≤109) — the number of memory units used by applications. The third line of each test case contains 𝑛 integers 𝑏1,𝑏2,…,𝑏𝑛 (1≤𝑏𝑖≤2) — the convenience points of each application. It is guaranteed that the sum of 𝑛 over all test cases does not exceed 2⋅105. ","date":"2021-02-03","objectID":"/codeforce_1/:1:2","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Output D. Cleaning the Phone Output For each test case, output on a separate line: -1, if there is no set of applications, removing which will free at least 𝑚 units of memory; the minimum number of convenience points that Polycarp will lose if such a set exists. ","date":"2021-02-03","objectID":"/codeforce_1/:1:3","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Example Input \u0026 Output D. Cleaning the Phone 5 5 7 5 3 2 1 4 2 1 1 2 1 1 3 2 1 5 10 2 3 2 3 2 1 2 1 2 1 4 10 5 1 3 4 1 2 1 2 4 5 3 2 1 2 2 1 2 1 2 -1 6 4 3 ","date":"2021-02-03","objectID":"/codeforce_1/:1:4","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Example Explanation D. Cleaning the Phone In the first test case, it is optimal to remove applications with numbers 2 and 5, freeing 7 units of memory. 𝑏2+𝑏5=2. In the second test case, by removing the only application, Polycarp will be able to clear only 2 of memory units out of the 3 needed. In the third test case, it is optimal to remove applications with numbers 1, 2, 3 and 4, freeing 10 units of memory. 𝑏1+𝑏2+𝑏3+𝑏4=6. In the fourth test case, it is optimal to remove applications with numbers 1, 3 and 4, freeing 12 units of memory. 𝑏1+𝑏3+𝑏4=4. In the fifth test case, it is optimal to remove applications with numbers 1 and 2, freeing 5 units of memory. 𝑏1+𝑏2=3. ","date":"2021-02-03","objectID":"/codeforce_1/:1:5","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Solution D. Cleaning the Phone #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long int main() { int n; cin \u003e\u003e n; vector\u003cll\u003e ret; for(int i = 0; i \u003c n; i+=1){ int m, needed; cin \u003e\u003e m \u003e\u003e needed; vector\u003cll\u003e a(m + 1, 0); vector\u003cint\u003e b(m + 1, 0); vector\u003cll\u003e _1; vector\u003cll\u003e _2; ll sum = 0; for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e a[i]; sum += a[i]; } for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e b[i]; if(b[i] == 1){ _1.push_back(a[i]); } else{ _2.push_back(a[i]); } } if(sum\u003cneeded) { ret.push_back(-1); continue; } sort(_1.rbegin(), _1.rend()); sort(_2.rbegin(), _2.rend()); vector\u003cll\u003e _pre2; _pre2.push_back(0); for(int i = 0; i \u003c _2.size(); i++){ _pre2.push_back(_pre2[i] + _2[i]); } int len=_pre2.size(); sum=0; ll ans=1e18; int cur=lower_bound(_pre2.begin(),_pre2.end(),needed)-_pre2.begin(); // if cur == len, it means that no element inside the _pre2 \u003e= needed if(cur!=len) { ans=cur*2; } for(int i = 0; i \u003c _1.size(); i++){ sum += _1[i]; if(needed \u003c 0){ ans = min(ans, 1ll + i + 1); break; } int point = needed - sum; int cur=lower_bound(_pre2.begin(),_pre2.end(),point)-_pre2.begin(); if(cur != len){ ans = min(ans, i + 1 + 2 * 1ll * cur); } } ret.push_back(ans); } for(int i : ret){ cout \u003c\u003c i \u003c\u003c '\\n'; } return 0; } ","date":"2021-02-03","objectID":"/codeforce_1/:2:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Remark D. Cleaning the Phone Implicit Binary Search Idea is computing the prefix sum and set the pointer at application with importance 1, and then do binary search to find the lower_bound for the application with importance of 2 ","date":"2021-02-03","objectID":"/codeforce_1/:3:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["OJ Problem"],"content":"OJ 5","date":"2021-02-02","objectID":"/coding_practice_5/","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"OJ Practice 5, share my solutions for these three OJ problems during the UCSD ICPC Selection Contest. ","date":"2021-02-02","objectID":"/coding_practice_5/:0:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Methodic Multiplication #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; int countS(string s){ int ret = 0; for(int i = 0; i \u003c s.length(); i++){ if(s[i] == 'S'){ ret += 1; } } return ret; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; if(s1 == \"0\"){ cout \u003c\u003c \"0\"; } else if(s2 == \"0\"){ cout \u003c\u003c \"0\"; } else{ int count1 = countS(s1), count2 = countS(s2); int ret = count1 * count2; int idx = 0; vector\u003cchar\u003e resultS; for(int i = 0; i \u003c ret; i++){ resultS.push_back('S'); resultS.push_back('('); } resultS.push_back('0'); for(int i = 0; i \u003c ret; i++){ resultS.push_back(')'); } string retS(resultS.begin(), resultS.end()); cout \u003c\u003c retS; } return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:1:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Dams in Distress #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; /* 4 75 0 100 50 1 49 10 1 50 0 3 50 48 */ int main() { ll n, t; cin \u003e\u003e n \u003e\u003e t; unordered_map\u003cint, vector\u003cint\u003e\u003e graph; vector\u003cll\u003e needed(n + 1, 0); vector\u003cll\u003e require(n + 1, 0); vector\u003cll\u003e current(n + 1, 0); // the first one need t amount of water needed[0] = t; require[0] = t; for(int i = 1; i \u003c= n; i++){ int d, c, u; cin \u003e\u003e d \u003e\u003e c \u003e\u003e u; // from parent to child if(graph.find(d) == graph.end()){ graph[d] = vector\u003cint\u003e {i}; } else{ graph[d].push_back(i); } require[i] = c; current[i] = u; } deque\u003cint\u003e q; q.push_back(0); while(q.size()){ int p = q.front(); q.pop_front(); if(graph.find(p) != graph.end()){ for(int np : graph[p]){ ll cur_n = max(needed[p], require[np]) - current[np]; needed[np] = cur_n; q.push_back(np); } } } ll min_amount = LLONG_MAX; for(int i = 0; i \u003c= n; i++){ min_amount = min(min_amount, needed[i]); } cout \u003c\u003c min_amount; /*TLE solution ll min_amount = LLONG_MAX; for(int i = 0; i \u003c= n; i++){ ll needed = require[i] - current[i]; ll carry = require[i]; int idx = i; while(idx != 0){ int next_level = parent[idx]; if(carry + current[next_level] \u003c require[next_level]){ break; } else{ carry = carry + current[next_level]; idx = parent[idx]; } } if(idx == 0){ min_amount = min(min_amount, needed); } } cout \u003c\u003c min_amount; */ return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:2:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Array of Discord #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; /* 3 2020 2020 2020 */ /* 4 1 42 4711 9876 */ ll magicSmall(ll num){ if(num \u003c 10){ return 0; } else{ string s = to_string(num); // if the first digit is not 1, we change it to 1, and return it. if(s[0] != '1'){ s[0] = '1'; return stoll(s); } // if the first digit is 1, we find the first non-zero, and change it to zero else{ for(int i = 1; i \u003c s.length(); i+=1){ if(s[i] != '0'){ s[i] = '0'; return stoll(s); } } } } return num; } ll magicBig(ll num){ if(num \u003c 10){ return 9; } else{ string s = to_string(num); if(s[0] != '9'){ s[0] = '9'; return stoll(s); } // find the first non-9, and change it to 9 else{ for(int i = 1; i \u003c s.length(); i+=1){ if(s[i] != '9'){ s[i] = '9'; return stoll(s); } } } } return num; } int main() { int n; cin \u003e\u003e n; vector\u003cll\u003e nums(n, 0); for(int i = 0; i \u003c n; i++){ ll num; cin \u003e\u003e num; nums[i] = num; } // either make left bigger, scan from the left to right, if the changed number is biggr than the one on the right, // we can return the array of numers for(int i = 0; i \u003c nums.size() - 1; i++){ if(magicBig(nums[i]) \u003e nums[i+1]){ nums[i] = magicBig(nums[i]); for(ll i : nums){ cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } } // or make right smaller, scan from right to left, if the changed number is smaller than the one on the left, // return the array of numbers for(int i = nums.size() - 1; i \u003e= 1; i--){ if(magicSmall(nums[i]) \u003c nums[i - 1]){ nums[i] = magicSmall(nums[i]); for(ll i : nums){ cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } } cout \u003c\u003c \"impossible\"; return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:3:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Remark to Array of Discord Just use stoll, do not mess up with the overflow ","date":"2021-02-02","objectID":"/coding_practice_5/:4:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"OJ 4","date":"2021-01-29","objectID":"/coding_practice_4/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"OJ Practice 4, share my solutions for these three OJ problems. ","date":"2021-01-29","objectID":"/coding_practice_4/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"[NCPC 2011 Problem A: Car Trouble] #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* 6 0 1 1 1 1 2 2 3 1 3 0 3 0 4 2 5 0 5 1 4 */ set\u003cint\u003e solve(unordered_map\u003cint, vector\u003cint\u003e\u003e\u0026 graph){ set\u003cint\u003e seen; if (graph.find(0) == graph.end()){ return seen; } deque\u003cint\u003e q; q.push_back(0); while(q.size()){ int cur = q.front(); q.pop_front(); seen.insert(cur); for(int j = 0; j \u003c graph[cur].size(); ++j){ if(seen.find(graph[cur][j]) == seen.end()){ seen.insert(graph[cur][j]); q.push_back(graph[cur][j]); } } } return seen; } int main() { int m, f, t, n; unordered_map\u003cint, vector\u003cint\u003e\u003e graph; unordered_map\u003cint, vector\u003cint\u003e\u003e reverse_graph; vector\u003cint\u003e all_road; cin \u003e\u003e m; for(int i = 0; i \u003c m; i++){ cin \u003e\u003e f; cin \u003e\u003e n; all_road.push_back(f); if(reverse_graph.find(t) == reverse_graph.end()){ reverse_graph[f] = vector\u003cint\u003e{}; } if(graph.find(f) == graph.end()){ graph[f] = vector\u003cint\u003e{}; } for(int j = 0; j \u003c n; j++){ cin \u003e\u003e t; graph[f].push_back(t); reverse_graph[t].push_back(f); } } // UNREACHABLE vector\u003cint\u003e unreachable; // TRAPPED vector\u003cint\u003e trapped; set\u003cint\u003e not_trapped = solve(reverse_graph); set\u003cint\u003e not_unreachable = solve(graph); for(int i : all_road){ if(not_unreachable.find(i) == not_unreachable.end()){ unreachable.push_back(i); } if(not_trapped.find(i) == not_trapped.end()){ trapped.push_back(i); } } if(trapped.size() == 0 \u0026\u0026 unreachable.size() == 0){ cout \u003c\u003c \"NO PROBLEMS\"; return 0; } else{ for(int i : trapped){ cout \u003c\u003c \"TRAPPED \" \u003c\u003c i \u003c\u003c endl; } for(int i : unreachable){ cout \u003c\u003c \"UNREACHABLE \" \u003c\u003c i \u003c\u003c endl; } } return 0; } ","date":"2021-01-29","objectID":"/coding_practice_4/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"NCPC 2015​ Goblin Garden Guards #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* 5 0 0 100 0 0 100 100 100 50 50 1 0 0 50 */ int main() { int n, m; cin \u003e\u003e n; int x, y, r; vector\u003ctuple\u003cint, int\u003e\u003e g; vector\u003ctuple\u003cint, int, int\u003e\u003e s; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e x \u003e\u003e y; g.push_back(make_tuple(x, y)); } cin \u003e\u003e m; for (int i = 0; i \u003c m; i++) { cin \u003e\u003e x \u003e\u003e y \u003e\u003e r; s.push_back(make_tuple(x, y, r)); } vector\u003cvector\u003cbool\u003e\u003e board(10000 + 5, vector\u003cbool\u003e(10000 + 5, true)); /*TLE SOLUTION int ret = 0; for(int i = 0; i \u003c n; i++){ bool flag = true; int g_x = get\u003c0\u003e(g[i]), g_y = get\u003c1\u003e(g[i]); for(int j = 0; j \u003c m; j++){ int s_x = get\u003c0\u003e(s[j]), s_y = get\u003c1\u003e(s[j]), s_r = get\u003c2\u003e(s[j]); if( pow((g_x - s_x), 2) + pow((g_y - s_y), 2) \u003c= pow(s_r, 2)){ flag = false; break; } } if(flag){ ret += 1; } } */ for (int j = 0; j \u003c m; j++) { int s_x = get\u003c0\u003e(s[j]), s_y = get\u003c1\u003e(s[j]), s_r = get\u003c2\u003e(s[j]); for (int dx = -s_r; dx \u003c= s_r; dx++) { for (int dy = -s_r; dy \u003c= s_r; dy++) { if (s_x + dx \u003e= 0 \u0026\u0026 s_x + dx \u003c 10000 + 5 \u0026\u0026 s_y + dy \u003e= 0 \u0026\u0026 s_y + dy \u003c 10000 + 5) { // double check the name of variables is correct if (dx * dx + dy * dy \u003c= s_r * s_r) { board[s_x + dx][s_y + dy] = false; } } } } } int ret = 0; for (int i = 0; i \u003c n; i++) { int g_x = get\u003c0\u003e(g[i]), g_y = get\u003c1\u003e(g[i]); if (board[g_x][g_y]) { ret += 1; } } cout \u003c\u003c ret; return 0; } ","date":"2021-01-29","objectID":"/coding_practice_4/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"OJ 2","date":"2021-01-28","objectID":"/coding_practice_3/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"OJ Practice 3, share my solution for these three OJ problems. ","date":"2021-01-28","objectID":"/coding_practice_3/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"NCPC 2011 Problem B: Mega Inversion using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { const int N = 2 * 1e5 + 10; const int origin = 1e5 + 10; public: vector\u003cll\u003e countLarger(vector\u003cint\u003e\u0026 nums){ vector\u003cll\u003e segtree(2 * N + 2, 0); reverse(nums.begin(), nums.end()); for(int i = 0; i \u003c nums.size(); ++i){ nums[i] = -nums[i]; } vector\u003cll\u003e result; for (int i = nums.size()-1; i \u003e= 0; i--) { result.push_back(rangeQuery(segtree, origin + nums[i])); update(segtree, origin + nums[i]); } return result; } vector\u003cll\u003e countSmaller(vector\u003cint\u003e\u0026 nums) { vector\u003cll\u003e segtree(2*N + 2, 0); vector\u003cll\u003e result; for (int i = nums.size()-1; i \u003e= 0; i--) { result.push_back(rangeQuery(segtree, origin + nums[i])); update(segtree, origin + nums[i]); } // need to reverse result reverse(result.begin(), result.end()); return result; } void update(vector\u003cll\u003e\u0026 segtree, int index) { for (index += N; index \u003e 0; index \u003e\u003e= 1) { segtree[index]++; } } ll rangeQuery(vector\u003cll\u003e\u0026 segtree, int entry) { int left = 0; int right = entry; ll result = 0; for (left += N, right += N; left \u003c right; left \u003e\u003e= 1, right \u003e\u003e= 1) { if(entry == 6 + origin){ } if (left%2 == 1) result += segtree[left++]; if (right%2 == 1) result += segtree[--right]; } return result; } }; int main() { Solution s; int n; cin \u003e\u003e n; vector\u003cint\u003e nums; int t; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e t; nums.push_back(t); } vector\u003cll\u003e smaller = s.countSmaller(nums); vector\u003cll\u003e larger = s.countLarger(nums); ll ret = 0; for(int i = 0; i \u003c larger.size(); i ++){ ret += (larger[i] * smaller[i]); } cout \u003c\u003c ret; return 0; } ","date":"2021-01-28","objectID":"/coding_practice_3/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"OJ 2","date":"2021-01-27","objectID":"/coding_practice_2/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"OJ Practice 2, share my solution for these three OJ problems. ","date":"2021-01-27","objectID":"/coding_practice_2/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"Robots on a grid using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { public: int test() { } }; int solve(vector\u003cvector\u003cint\u003e\u003e\u0026 board){ int m = board.size(), n = board[0].size(); int step = 0; vector\u003cint\u003e dirs = {0, 1, 0, -1, 0}; set\u003cint\u003e seen; deque\u003cint\u003e q; q.push_back(0); seen.insert(0); while(q.size()){ int size = q.size(); for(int i = 0; i \u003c size; i++){ int p = q.front(); q.pop_front(); int r = p / n, c = p % n; if(r == m - 1 \u0026\u0026 c == n - 1){ return step; } else{ for(int i = 0; i \u003c 4; i++){ int nr = r + (board[r][c] * dirs[i]), nc = c + (board[r][c] * dirs[i + 1]); if(nr \u003e= 0 \u0026\u0026 nr \u003c m \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n){ int np = nr * n + nc; if(seen.find(np) == seen.end()){ seen.insert(np); q.push_back(np); } } } } } step += 1; } return -1; } int main() { int m, n; cin \u003e\u003e m \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e board(m, vector\u003cint\u003e(n, 0)); char c; for(int i = 0; i \u003c m; i++){ for(int j = 0; j \u003c n; j++){ cin \u003e\u003e c; board[i][j] = c - '0'; } } // for(int i = 0; i \u003c m; i++){ // for(int j = 0; j \u003c n; j++){ // cout \u003c\u003c board[i][j]; // } // } cout \u003c\u003c solve(board); return 0; } ","date":"2021-01-27","objectID":"/coding_practice_2/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"SERGRID - Grid using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int solve(vector\u003cvector\u003cunsigned int\u003e\u003e\u0026 board){ int n = board.size() - 1; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= n; j++){ if(board[i][j] == -1){ board[i][j] = 0; } else{ board[i][j] = (board[i][j - 1] % 0x7FFFFFFF + board[i - 1][j] % 0x7FFFFFFF) % 0x7FFFFFFF; } } } return board[n][n]; } bool isValid(vector\u003cvector\u003cint\u003e\u003e\u0026 board){ int n = board.size(); // invalid board if(board[0][0] == -1){ return false; } vector\u003cint\u003e dirs = {0, 1, 0, -1, 0}; // r * n + c set\u003cint\u003e seen; deque\u003cint\u003e d; seen.insert(0); d.push_back(0); while(d.size()){ int p = d.front(); d.pop_front(); int r = p / n, c = p % n; if(r == n - 1 \u0026\u0026 c == n - 1){ return true; } else{ for(int i = 0; i \u003c dirs.size() - 1; i++){ int nr = r + dirs[i], nc = c + dirs[i + 1]; if(nr \u003e= 0 \u0026\u0026 nr \u003c n \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n \u0026\u0026 board[nr][nc] == 0){ int np = nr * n + nc; if(seen.find(np) == seen.end()){ seen.insert(np); d.push_back(np); } } } } } return false; } int main() { int n; char c; cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e validBoard(n, vector\u003cint\u003e(n, 0)); vector\u003cvector\u003cunsigned int\u003e\u003e board(n + 1, vector\u003cunsigned int\u003e(n + 1, 0)); for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c n; j++){ cin \u003e\u003e c; if(c == '.'){ board[i + 1][j + 1] = 0; validBoard[i][j] = 0; } else{ board[i + 1][j + 1] = -1; validBoard[i][j] = -1; } } } if(isValid(validBoard) == false){ cout \u003c\u003c \"INCONCEIVABLE\"; return 0; } board[0][1] = 1; int ret = solve(board); if (ret != 0){ cout \u003c\u003c ret; } else{ if(isValid(validBoard) == false){ cout \u003c\u003c \"INCONCEIVABLE\"; return 0; } else{ cout \u003c\u003c \"THE GAME IS A LIE\"; } } return 0; } ","date":"2021-01-27","objectID":"/coding_practice_2/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"OJ 1","date":"2021-01-26","objectID":"/coding_practice_1/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"OJ Practice 1, share my solution for these three OJ problems. ","date":"2021-01-26","objectID":"/coding_practice_1/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2013 Problem E: Timebomb #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int main() { string s; vector\u003cstring\u003e l; for(int i = 0; i \u003c 5; ++i){ std::getline (std::cin,s); l.push_back(s); } // for(string s : l){ // cout \u003c\u003c s \u003c\u003c endl; // } vector\u003cstring\u003e num_str = {\"75557\", \"11111\", \"71747\", \"71717\", \"55711\", \"74717\", \"74757\", \"71111\", \"75757\", \"75717\"}; unordered_map\u003cstring, int\u003e ref; for(int i = 0; i \u003c num_str.size(); ++i){ ref[num_str[i]] = i; } long long num = 0; vector\u003cint\u003e number; for(int i = 0; i \u003c l[0].size(); i += 4){ string s = \"\"; for(int k = 0; k \u003c 5; k++){ int counter = 0; for(int j = 0; j \u003c 3; j++){ if(l[k][i + j] == '*'){ counter += pow(2, 2- j); } } s += to_string(counter); } if(ref.find(s) == ref.end()){ cout \u003c\u003c \"BOOM!!\"; return 0; } else{ number.push_back(ref[s]); } } for(int i = 0; i \u003c number.size(); i += 1){ num = num * 10 + number[i]; } if(num % 6 == 0){ cout \u003c\u003c \"BEER!!\"; return 0; } else{ cout \u003c\u003c \"BOOM!!\"; return 0; } return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2015 Problem C: Cryptographer’s Conundrum #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int solve(string s){ int counter = 0; vector\u003cchar\u003e ref = {'P', 'E', 'R'}; for(int i = 0; i \u003c s.length(); ++i){ if(s[i] != ref[i % 3]){ counter += 1; } } return counter; } int main() { string s; cin \u003e\u003e s; cout \u003c\u003c solve(s) \u003c\u003c \"\\n\"; return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2011 Problem E: ls #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* *.* 4 main.c a.out readme yacc */ bool solve(string s, string p){ int s_len = s.length(), p_len = p.length(); vector\u003cvector\u003cbool\u003e\u003e dp(s_len + 1, vector\u003cbool\u003e(p_len + 1, false)); dp[0][0] = true; for(int j = 1; j \u003c= p_len; ++j){ if(p[j - 1] == '*'){ dp[0][j] = dp[0][j-1]; } else{ dp[0][j] = false; } } for(int i = 1; i \u003c= s_len; ++i){ for(int j = 1; j \u003c= p_len; ++j){ if(p[j-1] == '*'){ dp[i][j] = dp[i-1][j] || dp[i][j-1] || dp[i-1][j-1]; } else{ if(p[j-1] == s[i-1]){ dp[i][j] = dp[i-1][j-1]; } else{ dp[i][j] = false; } } } } return dp[s_len][p_len]; } int main() { int n = 0; string p, s; cin \u003e\u003e p; cin \u003e\u003e n; vector\u003cstring\u003e l; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e s; if(solve(s, p)){ l.push_back(s); } } for(string s : l){ cout \u003c\u003c s \u003c\u003c endl; } return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:3:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 315 - Count of Smaller Numbers After Self","date":"2021-01-23","objectID":"/leetcode_315/","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Use Segment Tree to solve Leetcode 315 - Count of Smaller Numbers After Self. ","date":"2021-01-23","objectID":"/leetcode_315/:0:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 315 You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. ","date":"2021-01-23","objectID":"/leetcode_315/:1:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 315 Example1: Input: nums = [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. ","date":"2021-01-23","objectID":"/leetcode_315/:2:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 315 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class SegmentTreeNode(object): # range[min, max] def __init__(self, min, max): self.min = min self.max = max self.mid = (self.max - self.min) // 2 + self.min self.count = 0 self.right = None self.left = None class SegmentTree(object): def __init__(self, root): self.root = root def update(self, value): self.updateHelper(value, self.root) def updateHelper(self, value, node): if node == None: return if value \u003c node.min or value \u003e node.max: return node.count += 1 if node.min == node.max: return working_mid = node.mid if node.left == None: node.left = SegmentTreeNode(node.min, working_mid) if node.right == None: node.right = SegmentTreeNode(working_mid + 1, node.max) if value \u003e working_mid: self.updateHelper(value, node.right) else: self.updateHelper(value, node.left) def queryRange(self, value): return self.queryRangeHelper(value, self.root) def queryRangeHelper(self, value, node): if node == None: return 0 if value \u003e= node.max: return node.count working_mid = node.mid if value \u003c= working_mid: return self.queryRangeHelper(value, node.left) else: return self.queryRangeHelper(value, node.right) + self.queryRangeHelper(value, node.left) class Solution: def countSmaller(self, nums: List[int]) -\u003e List[int]: if len(nums) == 0: return [] ret = [] root = SegmentTreeNode(min(nums), max(nums)) tree = SegmentTree(root) for i in range(len(nums) - 1, -1, -1): ret.append(tree.queryRange(nums[i] - 1)) tree.update(nums[i]) return ret[::-1] ","date":"2021-01-23","objectID":"/leetcode_315/:3:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Remark For each TreeNode, count refers to how many number between [max, min] O(nlogk) solution, where k is the max difference ","date":"2021-01-23","objectID":"/leetcode_315/:4:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 732 - My Calendar III","date":"2021-01-21","objectID":"/leetcode_732/","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Use Segment Tree to solve Leetcode 732 - My Calendar III. ","date":"2021-01-21","objectID":"/leetcode_732/:0:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 732 A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.) You are given some events [start, end), after each given event, return an integer k representing the maximum k-booking between all the previous events. Implement the MyCalendarThree class: MyCalendarThree() Initializes the object. int book(int start, int end) Returns an integer k representing the largest integer such that there exists a k-booking in the calendar. ","date":"2021-01-21","objectID":"/leetcode_732/:1:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 732 Example1: Input [\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"] [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]] Output [null, 1, 1, 2, 3, 3, 3] Explanation MyCalendarThree myCalendarThree = new MyCalendarThree(); myCalendarThree.book(10, 20); // return 1, The first event can be booked and is disjoint, so the maximum k-booking is a 1-booking. myCalendarThree.book(50, 60); // return 1, The second event can be booked and is disjoint, so the maximum k-booking is a 1-booking. myCalendarThree.book(10, 40); // return 2, The third event [10, 40) intersects the first event, and the maximum k-booking is a 2-booking. myCalendarThree.book(5, 15); // return 3, The remaining events cause the maximum K-booking to be only a 3-booking. myCalendarThree.book(5, 10); // return 3 myCalendarThree.book(25, 55); // return 3 ","date":"2021-01-21","objectID":"/leetcode_732/:2:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 732 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class TreeNode: # segment tree with lazy propogation for range max query # half-open interval [lo, hi) def __init__(self, low, high, val=0, lazy=0, leftChild = None, rightChild = None): self.low = low self.high = high # range max self.val = val # bookings to add to the children the next time children get visited self.lazy = lazy self.leftChild = leftChild self.rightChild = rightChild class MyCalendarThree: MIN_BOUND = 0 MAX_BOUND = 1e9 + 1 def __init__(self): self.root = TreeNode(MyCalendarThree.MIN_BOUND, MyCalendarThree.MAX_BOUND) def book(self, start: int, end: int) -\u003e int: # update the segment from top to down, using lazy propogation self.update(self.root, start, end) return self.root.val def update(self, node, start, end): # we found the match, increment the value and lazy to be propogated if node.low == start and node.high == end: node.val += 1 node.lazy += 1 return mid = (node.high - node.low) // 2 + node.low # top-down building the segment tree if node.leftChild == None and node.rightChild == None: node.leftChild = TreeNode(node.low, mid, node.lazy, node.lazy) node.rightChild = TreeNode(mid, node.high, node.lazy, node.lazy) else: node.leftChild.val += node.lazy node.leftChild.lazy += node.lazy node.rightChild.val += node.lazy node.rightChild.lazy += node.lazy node.lazy = 0 # after building the children, we are able to traverse downwards if mid \u003e= end: self.update(node.leftChild, start, end) elif mid \u003c= start: self.update(node.rightChild, start, end) else: self.update(node.leftChild, start, mid) self.update(node.rightChild, mid, end) node.val = max(node.leftChild.val, node.rightChild.val) return # credit to https://leetcode.com/problems/my-calendar-iii/discuss/1023625/Python-Segment-Tree-with-Lazy-Propagation ","date":"2021-01-21","objectID":"/leetcode_732/:3:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Remark We treat this problem as segment tree(interval tree) where each book would trigger the building of tree To build the tree top-down, we utilize Lazy Propagation ","date":"2021-01-21","objectID":"/leetcode_732/:4:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Data Structure"],"content":"This article reviews segment tree.","date":"2021-01-20","objectID":"/segment_tree/","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"This article reviews Segment Tree. Segment Tree ","date":"2021-01-20","objectID":"/segment_tree/:0:0","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Semantics This balanced tree data structure stores the aggregation of certain property within certain range. build(start, end, vals): construct the segment tree update(index, value): update the A[index] to value rangeQuery(start, end) query the aggregation of certain range [start, end] ","date":"2021-01-20","objectID":"/segment_tree/:0:1","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Implementation class SegmentTreeNode: def __init__(self, start, end, val, left=None, right=None): self.start = start self.end = end self.mid = start + (end - start) // 2 self.val = val self.left = left self.right = right class SegmentTree: def __init__(self, nums): self.nums = nums if self.nums: self.root = self.build(0, len(nums) - 1, nums) def build(self, start, end, nums): if start == end: return SegmentTreeNode(start, end, nums[start]) mid = (end - start) // 2 + start leftNode = self.build(start, mid, nums) rightNode = self.build(mid + 1, end, nums) return SegmentTreeNode(start, end, leftNode.val + rightNode.val, leftNode, rightNode) def update(self, index, value): self.updateHelper(self.root, index, value) def updateHelper(self, node, index, value): if node.start == index and node.end == index: node.val = value return if index \u003c= node.mid: self.updateHelper(node.left, index, value) else: self.updateHelper(node.right, index, value) node.val = node.left.val + node.right.val def queryRange(self, start, end): return self.queryRangeHelper(self.root, start, end) def queryRangeHelper(self, node, start, end): if node.start == start and node.end == end: return node.val elif end \u003c= node.mid: return self.queryRangeHelper(node.left, start, end) elif start \u003e node.mid: return self.queryRangeHelper(node.right, start, end) else: return self.queryRangeHelper(node.left, start, node.mid) + self.queryRangeHelper(node.right, node.mid + 1, end) ","date":"2021-01-20","objectID":"/segment_tree/:0:2","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Efficienty Analysis buil -\u003e O(n) update -\u003e O(log n) rangeQuery -\u003e ~ O(log n) ","date":"2021-01-20","objectID":"/segment_tree/:0:3","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Remarks query range with mutable arrays ","date":"2021-01-20","objectID":"/segment_tree/:0:4","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 947 - Most Stones Removed with Same Row or Column","date":"2021-01-17","objectID":"/leetcode_947/","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 947 - Most Stones Removed with Same Row or Column. ","date":"2021-01-17","objectID":"/leetcode_947/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 947 On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed. ","date":"2021-01-17","objectID":"/leetcode_947/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 947 Example1: Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5 Explanation: One way to remove 5 stones is as follows: 1. Remove stone [2,2] because it shares the same row as [2,1]. 2. Remove stone [2,1] because it shares the same column as [0,1]. 3. Remove stone [1,2] because it shares the same row as [1,0]. 4. Remove stone [1,0] because it shares the same column as [0,0]. 5. Remove stone [0,1] because it shares the same row as [0,0]. Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane. Example2: Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3 Explanation: One way to make 3 moves is as follows: 1. Remove stone [2,2] because it shares the same row as [2,0]. 2. Remove stone [2,0] because it shares the same column as [0,0]. 3. Remove stone [0,2] because it shares the same row as [0,0]. Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane. Example3: Input: stones = [[0,0]] Output: 0 Explanation: [0,0] is the only stone on the plane, so you cannot remove it. ","date":"2021-01-17","objectID":"/leetcode_947/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 947 from collections import deque, Counter class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): # already inserted if p in self.parents: return True else: self.num_sets += 1 self.parents[p] = p self.sizes[p] = 1 return False def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, [p, q]) if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sets -= 1 class Solution: def removeStones(self, stones: List[List[int]]) -\u003e int: row_stone = {} # row -\u003e stone location col_stone = {} # col -\u003e stone location for stone in stones: i, j = stone[0], stone[1] location = (i, j) if i in row_stone: row_stone[i].add(location) else: row_stone[i] = set() row_stone[i].add(location) if j in col_stone: col_stone[j].add(location) else: col_stone[j] = set() col_stone[j].add(location) disjoint_set = UnionFind() all_stone = set() for stone in stones: i, j = stone[0], stone[1] location = (i, j) if disjoint_set.contains(location): continue else: # do a little bfs here to find all the connected component my_queue = deque() my_queue.append(location) row_seen = set() col_seen = set() while(len(my_queue) != 0): cur_loc = my_queue.pop() disjoint_set.insert(cur_loc) disjoint_set.union(cur_loc, location) all_stone.add(cur_loc) i, j = cur_loc[0], cur_loc[1] if i not in row_seen: row_seen.add(i) for stone in row_stone[i]: my_queue.append(stone) if j not in col_seen: col_seen.add(j) for stone in col_stone[j]: my_queue.append(stone) leader_size = {} for stone in all_stone: real_leader = disjoint_set.find(stone) if real_leader not in leader_size: leader_size[real_leader] = disjoint_set.sizes[real_leader] else: leader_size[real_leader] = disjoint_set.sizes[real_leader] ret = 0 for leader in leader_size: ret += (leader_size[leader] - 1) return ret ","date":"2021-01-17","objectID":"/leetcode_947/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Remark We define connected-compoent as the componet of stones share same col/row with at least 1 other stone in the graph STEP1, remember all the locations of the stones STEP2, create disjoint set that stores all connected-component together STEP3, for each connected component, we greedily pick the size-1 of that component ","date":"2021-01-17","objectID":"/leetcode_947/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 827 - Making A Large Island","date":"2021-01-15","objectID":"/leetcode_827/","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 827 - Making A Large Island. ","date":"2021-01-15","objectID":"/leetcode_827/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). ","date":"2021-01-15","objectID":"/leetcode_827/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3. Example2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4. ","date":"2021-01-15","objectID":"/leetcode_827/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t : self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sets -= 1 return False class Solution: def largestIsland(self, grid: List[List[int]]) -\u003e int: dirs = [0, 1, 0, -1, 0] # Step1, union 1's and find 0's disjoint_set = UnionFind() all_zeros = set() ret = 0 m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == 1: base = i * n + j disjoint_set.insert(base) for t in range(len(dirs) - 1): if i + dirs[t] \u003e= 0 and i + dirs[t] \u003c m and j + dirs[t + 1] \u003e= 0 and j + dirs[t + 1] \u003c n and grid[i + dirs[t]][j + dirs[t + 1]] == 1: neighbour = (i + dirs[t]) * n + (j + dirs[t + 1]) disjoint_set.insert(neighbour) disjoint_set.union(neighbour, base) else: all_zeros.add((i, j)) # edge case, all 1's, just return the size of the grid if len(all_zeros) == 0: return m * n # for all possible zeros, try to flip it for zero in all_zeros: i, j = zero[0], zero[1] leader_size = {} for t in range(len(dirs) - 1): if i + dirs[t] \u003e= 0 and i + dirs[t] \u003c m and j + dirs[t + 1] \u003e= 0 and j + dirs[t + 1] \u003c n and grid[i + dirs[t]][j + dirs[t + 1]] == 1: leader = disjoint_set.find((i + dirs[t]) * n + (j + dirs[t + 1])) if leader in leader_size: continue else: leader_size[leader] = disjoint_set.sizes[leader] ret = max(ret, sum(list(leader_size.values())) + 1) return ret ","date":"2021-01-15","objectID":"/leetcode_827/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Naive Approach tries all the zeros, and recompute the connected component Union Find helps us to find the size of the connected component without computing the graph again, O(n*m) ","date":"2021-01-15","objectID":"/leetcode_827/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 1722 - Minimize Hamming Distance After Swap Operations.","date":"2021-01-14","objectID":"/leetcode_1722/","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 1722 - Minimize Hamming Distance After Swap Operations. ","date":"2021-01-14","objectID":"/leetcode_1722/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 1722 You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 \u003c= i \u003c= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source. ","date":"2021-01-14","objectID":"/leetcode_1722/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 1722 Example1: Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output: 1 Explanation: source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example1: Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output: 2 Explanation: There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. ","date":"2021-01-14","objectID":"/leetcode_1722/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 1722 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sizes = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.num_sizes += 1 self.parents[p] = p self.sizes[p] = 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # this means that we found a redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sizes -= 1 return False class Solution: def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(source) for i in range(n): disjoint_set.insert(i) # build the union graph # in each group, the numbers can be placed anywhere for edge in allowedSwaps: disjoint_set.union(edge[0], edge[1]) # hashmap, # group leader -\u003e set[indices in that group] leader_member = {} print(disjoint_set.parents) for member, leader in disjoint_set.parents.items(): # This is the real leader for this member leader = disjoint_set.find(member) if leader in leader_member: leader_member[leader].add(member) else: leader_member[leader] = set([member]) print(leader_member) ret = 0 # for all the members, try to figure out the distance for members in leader_member.values(): source_numbers = [source[i] for i in members] target_numbers = [target[i] for i in members] ret += sum((Counter(source_numbers) - Counter(target_numbers)).values()) return ret ","date":"2021-01-14","objectID":"/leetcode_1722/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To solve this problem, we need to observe that if (0, 1) is exchangeable and (0, 2) is exchangeable, then any pair in (0, 1, 2) can be exchangeble. The remaining problem is how to detect connected components in the graph -\u003e use Union Find. Counter, the subclass of dictionary, supports many great opeartions. ","date":"2021-01-14","objectID":"/leetcode_1722/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Entertainment"],"content":"牛振华三部曲","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/","tags":["moview review","chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Entertainment"],"content":"Stand Up, Don’t Bend Over 1993 Back to Back, Face to Face 1994 Signal Left, Turn Right 1995 闲来无事，写一篇影评，记录一下2021的开始。 偶然的机会看了一部反应中国政治生态的小短篇，之后有评论里提到一部《背靠背，脸对脸》的电影，简单的名字往往藏着不平凡的故事，youtube和b站搜了一下，有版权，随即看了一下。 这三部电影都由牛振华主演，黄建新执导，用幽默的手法反应当时90年代的都市百态、经济生活，政治生态。《背靠背，脸对脸》《站直喽，别趴下》《红灯停绿灯行》合称“都市百态三部曲”。 《背靠背，脸对脸》讲述的是一个文物馆的王双立副馆长，绞尽脑汁想上位一把手的故事。通过王副馆长在其转正过程中一波三折的经历，反应了现代化社会中复杂微妙的人际关系以及错综复杂的政治生态。牛振华饰演的王副馆长是一位有能力，懂得政治手段的领导，难能可贵的是，牛的表演展现了人的复杂性，矛盾性。和当今社会网络中许多线性的人设不同，现实中人的生活是对立统一的，在学会使用矛盾的观点看身边的问题之同时，辩证地理解人性的复杂。以及句兆杰饰演的会计在多次倒戈中体现出“没有永远的盟友，只有永远的利益”这点现实，值得回味。 《站直喽，别趴下》描述了“流氓”张永武（牛振华饰）通过养鱼发家致富，通过自己的努力和敢于拼搏的精神成为那栋楼里最有排面的人。原先看不起张永武的刘干部（达式常饰）和由高作家（冯巩饰）最终在利益的趋势下，像所谓的物质生活低头，改变了对张永武原先“地痞流氓”的标签。电影反应了当时社会“有钱没文化，有文化没钱”，张永武的渔业公司发展壮大后，要求高作家搬出这栋楼，在张永武一系列盘外招的干扰下，高作家连夜搬家，最后高作家蹲在地上收拾东西的镜头，抛出文化人是否向物质低头这个命题。 《红灯停绿灯行》讲述的是学车时发生的一系列故事，　记者苟宇佳（牛振华 饰）、下岗女工程芬（丁嘉丽 饰）、个体户绿豆（王劲松 饰）、大款老差（句号 饰）是驾校1025班的成员，在退伍军人侯教练手下练习。随着时间的推移，大家渐渐摸清彼此的习性。记者小苟八面玲珑，处事圆滑，一心想把学车费报销，结果天不遂人愿；待业女工阿芬被下海的丈夫发来离婚的传票，一人带着女儿，老实度日；早年丧父，母亲瘫痪在床的绿豆沾染上了毒品，白天学车，半夜偷井盖，却是个孝顺儿子；大款老差则是个打着盹儿都能赚上十万、八万的有钱人，不把驾校规定放在眼里；侯教练的教练身份为他带来了免费的香烟和赚回扣的机会，也因此引火烧身，弄得家里鸡犬不宁。 这段驾校生活，波折连连，却都一一化险为夷，5人间的暗战明战也都随着考试的顺利通关而结束。这段驾校的经历牵扯出了5个人的悲喜，除了学到了驾驶规则，似乎更学到了生存法则。credit to 豆瓣 总的来说，这三篇电影风格类似，大致都描述了错综复杂的人际关系和现代化社会的一些拜金主义苗头。人是复杂的而非线性的，生活是矛与盾的结合。网络很容易让人陷入一种单纯的思考状态，认为所有事物都是线性的，贴标签似的理解事情，这样显然很简单，也很容易，但写到这里，也想到百度CEO李彦宏曾对推荐算法有一番说辞，大致描述说推荐算法使得网民失去多样性，在计算了相似度以后，用户喜欢XX就一直推送XX，如果平台一直都是“投其所好”,把用户困在一个圈子里，丧失了获得多样性的机会，也使得很多用户失去了辩证思维。江泽民总书记曾说过 “对现实社会中的问题，我们要进行理性的思考。因为我们看到的现象，其中有的是真相，有的却是假象。只有把感性上升到理性，才能深化认识，才能把握事物的本质。”这几部电影在消遣时间的同时，也敲响了辩证思考的警钟，但从头论，本人也是被推荐算法带进这些电影的，不免有些讽刺。 希望以后思考问题能够深入本质，别太狭隘。 ","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/:0:0","tags":["moview review","chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 547 - Number of Provinces.","date":"2021-01-13","objectID":"/leetcode_547/","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 547 - Number of Provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]] Output: 2 Example2: Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]] Output: 3 ","date":"2021-01-13","objectID":"/leetcode_547/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 class Solution: def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(isConnected) for i in range(n): disjoint_set.insert(i) for i in range(n): for j in range(n): if isConnected[i][j]: disjoint_set.union(i, j) return disjoint_set.num_sets ","date":"2021-01-13","objectID":"/leetcode_547/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To find the connected component in undirected graph, Union Find(Disjoint Set) is the handy data structure to use. ","date":"2021-01-13","objectID":"/leetcode_547/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Data Structure"],"content":"This article reviews union find.","date":"2021-01-12","objectID":"/union_find/","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"This article reviews Union Find(Disjoint Set). Union Find | Disjoint Set ","date":"2021-01-12","objectID":"/union_find/:0:0","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Semantics This data structure stores the collection of disjoint(non-overlapping) sets(groups). find(p): find the leader of group that contains p union(p, q): merge two groups ","date":"2021-01-12","objectID":"/union_find/:0:1","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Implementation class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 ","date":"2021-01-12","objectID":"/union_find/:0:2","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Efficienty Analysis O(n) in memory, O(1) for union and look up in amortized analysis ","date":"2021-01-12","objectID":"/union_find/:0:3","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Remarks Check whether two elements belong to the same group. To find connected components in graph (usually undirected) Speed up implementation of kruskal’s algorithm ","date":"2021-01-12","objectID":"/union_find/:0:4","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":null,"content":" Welcome to  Haihao Sun’s field! Self Introduction Haihao SunTravelling \" Travelling Hi there! I am Haihao Sun, and my hobbies come and go. I enjoy travelling, playing Go, playing pokemon, and developing(AKA coding). I was born in Nanjing, and I currently live in San Diego . Skills JavaScript SQL C/C++  Java Python Extended Links Linkedin Blog Version I Github ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Page","uri":"/about/"}]