[{"categories":["cpp cheatsheet"],"content":"cpp handy reference","date":"2021-02-03","objectID":"/cpp_handy_1/","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"cpp cheatsheet 1. ","date":"2021-02-03","objectID":"/cpp_handy_1/:0:0","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"Binary Search related library function lower_bound upper_bound binary_search (beginIterator, endInterator, val) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:0","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"lower_bound lower_bound(beginIterator, endInterator, target) Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val. greater than or equal to the target if no elements satisfies the condition, simply return the endInterator(out of bound) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:1","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"upper_bound upper_bound(beginIterator, endInterator, target)s Returns an iterator pointing to the first element in the range [first,last) which compares greater than val. strictly greater than the target if no element satisfies the condition, simply return the endInterator(out of bound) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:2","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"binary_search binary_search(beginIterator, endInterator, val) true if exist, false otherwise. int main() { vector\u003cint\u003e _v; for(int i = 0; i \u003c 5; i++){ _v.push_back(i); _v.push_back(i + 3); } // must be sorted in increasing order // note that rbegin, rend, reverse order is not allowed sort(_v.begin(), _v.end()); cout \u003c\u003c lower_bound(_v.begin(), _v.end(), 4) - _v.begin() \u003c\u003c '\\n'; return 0; } ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:3","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["codeforce"],"content":"codeforce 1","date":"2021-02-03","objectID":"/codeforce_1/","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"codeforce 1475D, share my solution for these this codeforce problem. ","date":"2021-02-03","objectID":"/codeforce_1/:0:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Description D. Cleaning the Phone ","date":"2021-02-03","objectID":"/codeforce_1/:1:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Introduction D. Cleaning the Phone Polycarp often uses his smartphone. He has already installed 𝑛 applications on it. Application with number 𝑖 takes up 𝑎𝑖 units of memory. Polycarp wants to free at least 𝑚 units of memory (by removing some applications). Of course, some applications are more important to Polycarp than others. He came up with the following scoring system — he assigned an integer 𝑏𝑖 to each application: 𝑏𝑖=1 — regular application; 𝑏𝑖=2 — important application. According to this rating system, his phone has 𝑏1+𝑏2+…+𝑏𝑛 convenience points. Polycarp believes that if he removes applications with numbers 𝑖1,𝑖2,…,𝑖𝑘, then he will free 𝑎𝑖1+𝑎𝑖2+…+𝑎𝑖𝑘 units of memory and lose 𝑏𝑖1+𝑏𝑖2+…+𝑏𝑖𝑘 convenience points. For example, if 𝑛=5, 𝑚=7, 𝑎=[5,3,2,1,4], 𝑏=[2,1,1,2,1], then Polycarp can uninstall the following application sets (not all options are listed below): applications with numbers 1,4 and 5. In this case, it will free 𝑎1+𝑎4+𝑎5=10 units of memory and lose 𝑏1+𝑏4+𝑏5=5 convenience points; applications with numbers 1 and 3. In this case, it will free 𝑎1+𝑎3=7 units of memory and lose 𝑏1+𝑏3=3 convenience points. applications with numbers 2 and 5. In this case, it will free 𝑎2+𝑎5=7 memory units and lose 𝑏2+𝑏5=2 convenience points. Help Polycarp, choose a set of applications, such that if removing them will free at least 𝑚 units of memory and lose the minimum number of convenience points, or indicate that such a set does not exist. ","date":"2021-02-03","objectID":"/codeforce_1/:1:1","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Input D. Cleaning the Phone Input The first line contains one integer 𝑡 (1≤𝑡≤104) — the number of test cases. Then 𝑡 test cases follow. The first line of each test case contains two integers 𝑛 and 𝑚 (1≤𝑛≤2⋅105, 1≤𝑚≤109) — the number of applications on Polycarp’s phone and the number of memory units to be freed. The second line of each test case contains 𝑛 integers 𝑎1,𝑎2,…,𝑎𝑛 (1≤𝑎𝑖≤109) — the number of memory units used by applications. The third line of each test case contains 𝑛 integers 𝑏1,𝑏2,…,𝑏𝑛 (1≤𝑏𝑖≤2) — the convenience points of each application. It is guaranteed that the sum of 𝑛 over all test cases does not exceed 2⋅105. ","date":"2021-02-03","objectID":"/codeforce_1/:1:2","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Output D. Cleaning the Phone Output For each test case, output on a separate line: -1, if there is no set of applications, removing which will free at least 𝑚 units of memory; the minimum number of convenience points that Polycarp will lose if such a set exists. ","date":"2021-02-03","objectID":"/codeforce_1/:1:3","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Example Input \u0026 Output D. Cleaning the Phone 5 5 7 5 3 2 1 4 2 1 1 2 1 1 3 2 1 5 10 2 3 2 3 2 1 2 1 2 1 4 10 5 1 3 4 1 2 1 2 4 5 3 2 1 2 2 1 2 1 2 -1 6 4 3 ","date":"2021-02-03","objectID":"/codeforce_1/:1:4","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Example Explanation D. Cleaning the Phone In the first test case, it is optimal to remove applications with numbers 2 and 5, freeing 7 units of memory. 𝑏2+𝑏5=2. In the second test case, by removing the only application, Polycarp will be able to clear only 2 of memory units out of the 3 needed. In the third test case, it is optimal to remove applications with numbers 1, 2, 3 and 4, freeing 10 units of memory. 𝑏1+𝑏2+𝑏3+𝑏4=6. In the fourth test case, it is optimal to remove applications with numbers 1, 3 and 4, freeing 12 units of memory. 𝑏1+𝑏3+𝑏4=4. In the fifth test case, it is optimal to remove applications with numbers 1 and 2, freeing 5 units of memory. 𝑏1+𝑏2=3. ","date":"2021-02-03","objectID":"/codeforce_1/:1:5","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Solution D. Cleaning the Phone #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long int main() { int n; cin \u003e\u003e n; vector\u003cll\u003e ret; for(int i = 0; i \u003c n; i+=1){ int m, needed; cin \u003e\u003e m \u003e\u003e needed; vector\u003cll\u003e a(m + 1, 0); vector\u003cint\u003e b(m + 1, 0); vector\u003cll\u003e _1; vector\u003cll\u003e _2; ll sum = 0; for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e a[i]; sum += a[i]; } for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e b[i]; if(b[i] == 1){ _1.push_back(a[i]); } else{ _2.push_back(a[i]); } } if(sum\u003cneeded) { ret.push_back(-1); continue; } sort(_1.rbegin(), _1.rend()); sort(_2.rbegin(), _2.rend()); vector\u003cll\u003e _pre2; _pre2.push_back(0); for(int i = 0; i \u003c _2.size(); i++){ _pre2.push_back(_pre2[i] + _2[i]); } int len=_pre2.size(); sum=0; ll ans=1e18; int cur=lower_bound(_pre2.begin(),_pre2.end(),needed)-_pre2.begin(); // if cur == len, it means that no element inside the _pre2 \u003e= needed if(cur!=len) { ans=cur*2; } for(int i = 0; i \u003c _1.size(); i++){ sum += _1[i]; if(needed \u003c 0){ ans = min(ans, 1ll + i + 1); break; } int point = needed - sum; int cur=lower_bound(_pre2.begin(),_pre2.end(),point)-_pre2.begin(); if(cur != len){ ans = min(ans, i + 1 + 2 * 1ll * cur); } } ret.push_back(ans); } for(int i : ret){ cout \u003c\u003c i \u003c\u003c '\\n'; } return 0; } ","date":"2021-02-03","objectID":"/codeforce_1/:2:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Remark D. Cleaning the Phone Implicit Binary Search Idea is computing the prefix sum and set the pointer at application with importance 1, and then do binary search to find the lower_bound for the application with importance of 2 ","date":"2021-02-03","objectID":"/codeforce_1/:3:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["OJ Problem"],"content":"OJ 5","date":"2021-02-02","objectID":"/coding_practice_5/","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"OJ Practice 5, share my solutions for these three OJ problems during the UCSD ICPC Selection Contest. ","date":"2021-02-02","objectID":"/coding_practice_5/:0:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Methodic Multiplication #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; int countS(string s){ int ret = 0; for(int i = 0; i \u003c s.length(); i++){ if(s[i] == 'S'){ ret += 1; } } return ret; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; if(s1 == \"0\"){ cout \u003c\u003c \"0\"; } else if(s2 == \"0\"){ cout \u003c\u003c \"0\"; } else{ int count1 = countS(s1), count2 = countS(s2); int ret = count1 * count2; int idx = 0; vector\u003cchar\u003e resultS; for(int i = 0; i \u003c ret; i++){ resultS.push_back('S'); resultS.push_back('('); } resultS.push_back('0'); for(int i = 0; i \u003c ret; i++){ resultS.push_back(')'); } string retS(resultS.begin(), resultS.end()); cout \u003c\u003c retS; } return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:1:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Dams in Distress #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; /* 4 75 0 100 50 1 49 10 1 50 0 3 50 48 */ int main() { ll n, t; cin \u003e\u003e n \u003e\u003e t; unordered_map\u003cint, vector\u003cint\u003e\u003e graph; vector\u003cll\u003e needed(n + 1, 0); vector\u003cll\u003e require(n + 1, 0); vector\u003cll\u003e current(n + 1, 0); // the first one need t amount of water needed[0] = t; require[0] = t; for(int i = 1; i \u003c= n; i++){ int d, c, u; cin \u003e\u003e d \u003e\u003e c \u003e\u003e u; // from parent to child if(graph.find(d) == graph.end()){ graph[d] = vector\u003cint\u003e {i}; } else{ graph[d].push_back(i); } require[i] = c; current[i] = u; } deque\u003cint\u003e q; q.push_back(0); while(q.size()){ int p = q.front(); q.pop_front(); if(graph.find(p) != graph.end()){ for(int np : graph[p]){ ll cur_n = max(needed[p], require[np]) - current[np]; needed[np] = cur_n; q.push_back(np); } } } ll min_amount = LLONG_MAX; for(int i = 0; i \u003c= n; i++){ min_amount = min(min_amount, needed[i]); } cout \u003c\u003c min_amount; /*TLE solution ll min_amount = LLONG_MAX; for(int i = 0; i \u003c= n; i++){ ll needed = require[i] - current[i]; ll carry = require[i]; int idx = i; while(idx != 0){ int next_level = parent[idx]; if(carry + current[next_level] \u003c require[next_level]){ break; } else{ carry = carry + current[next_level]; idx = parent[idx]; } } if(idx == 0){ min_amount = min(min_amount, needed); } } cout \u003c\u003c min_amount; */ return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:2:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Array of Discord #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; /* 3 2020 2020 2020 */ /* 4 1 42 4711 9876 */ ll magicSmall(ll num){ if(num \u003c 10){ return 0; } else{ string s = to_string(num); // if the first digit is not 1, we change it to 1, and return it. if(s[0] != '1'){ s[0] = '1'; return stoll(s); } // if the first digit is 1, we find the first non-zero, and change it to zero else{ for(int i = 1; i \u003c s.length(); i+=1){ if(s[i] != '0'){ s[i] = '0'; return stoll(s); } } } } return num; } ll magicBig(ll num){ if(num \u003c 10){ return 9; } else{ string s = to_string(num); if(s[0] != '9'){ s[0] = '9'; return stoll(s); } // find the first non-9, and change it to 9 else{ for(int i = 1; i \u003c s.length(); i+=1){ if(s[i] != '9'){ s[i] = '9'; return stoll(s); } } } } return num; } int main() { int n; cin \u003e\u003e n; vector\u003cll\u003e nums(n, 0); for(int i = 0; i \u003c n; i++){ ll num; cin \u003e\u003e num; nums[i] = num; } // either make left bigger, scan from the left to right, if the changed number is biggr than the one on the right, // we can return the array of numers for(int i = 0; i \u003c nums.size() - 1; i++){ if(magicBig(nums[i]) \u003e nums[i+1]){ nums[i] = magicBig(nums[i]); for(ll i : nums){ cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } } // or make right smaller, scan from right to left, if the changed number is smaller than the one on the left, // return the array of numbers for(int i = nums.size() - 1; i \u003e= 1; i--){ if(magicSmall(nums[i]) \u003c nums[i - 1]){ nums[i] = magicSmall(nums[i]); for(ll i : nums){ cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } } cout \u003c\u003c \"impossible\"; return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:3:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Remark to Array of Discord Just use stoll, do not mess up with the overflow ","date":"2021-02-02","objectID":"/coding_practice_5/:4:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"OJ 4","date":"2021-01-29","objectID":"/coding_practice_4/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"OJ Practice 4, share my solutions for these three OJ problems. ","date":"2021-01-29","objectID":"/coding_practice_4/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"[NCPC 2011 Problem A: Car Trouble] #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* 6 0 1 1 1 1 2 2 3 1 3 0 3 0 4 2 5 0 5 1 4 */ set\u003cint\u003e solve(unordered_map\u003cint, vector\u003cint\u003e\u003e\u0026 graph){ set\u003cint\u003e seen; if (graph.find(0) == graph.end()){ return seen; } deque\u003cint\u003e q; q.push_back(0); while(q.size()){ int cur = q.front(); q.pop_front(); seen.insert(cur); for(int j = 0; j \u003c graph[cur].size(); ++j){ if(seen.find(graph[cur][j]) == seen.end()){ seen.insert(graph[cur][j]); q.push_back(graph[cur][j]); } } } return seen; } int main() { int m, f, t, n; unordered_map\u003cint, vector\u003cint\u003e\u003e graph; unordered_map\u003cint, vector\u003cint\u003e\u003e reverse_graph; vector\u003cint\u003e all_road; cin \u003e\u003e m; for(int i = 0; i \u003c m; i++){ cin \u003e\u003e f; cin \u003e\u003e n; all_road.push_back(f); if(reverse_graph.find(t) == reverse_graph.end()){ reverse_graph[f] = vector\u003cint\u003e{}; } if(graph.find(f) == graph.end()){ graph[f] = vector\u003cint\u003e{}; } for(int j = 0; j \u003c n; j++){ cin \u003e\u003e t; graph[f].push_back(t); reverse_graph[t].push_back(f); } } // UNREACHABLE vector\u003cint\u003e unreachable; // TRAPPED vector\u003cint\u003e trapped; set\u003cint\u003e not_trapped = solve(reverse_graph); set\u003cint\u003e not_unreachable = solve(graph); for(int i : all_road){ if(not_unreachable.find(i) == not_unreachable.end()){ unreachable.push_back(i); } if(not_trapped.find(i) == not_trapped.end()){ trapped.push_back(i); } } if(trapped.size() == 0 \u0026\u0026 unreachable.size() == 0){ cout \u003c\u003c \"NO PROBLEMS\"; return 0; } else{ for(int i : trapped){ cout \u003c\u003c \"TRAPPED \" \u003c\u003c i \u003c\u003c endl; } for(int i : unreachable){ cout \u003c\u003c \"UNREACHABLE \" \u003c\u003c i \u003c\u003c endl; } } return 0; } ","date":"2021-01-29","objectID":"/coding_practice_4/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"NCPC 2015​ Goblin Garden Guards #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* 5 0 0 100 0 0 100 100 100 50 50 1 0 0 50 */ int main() { int n, m; cin \u003e\u003e n; int x, y, r; vector\u003ctuple\u003cint, int\u003e\u003e g; vector\u003ctuple\u003cint, int, int\u003e\u003e s; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e x \u003e\u003e y; g.push_back(make_tuple(x, y)); } cin \u003e\u003e m; for (int i = 0; i \u003c m; i++) { cin \u003e\u003e x \u003e\u003e y \u003e\u003e r; s.push_back(make_tuple(x, y, r)); } vector\u003cvector\u003cbool\u003e\u003e board(10000 + 5, vector\u003cbool\u003e(10000 + 5, true)); /*TLE SOLUTION int ret = 0; for(int i = 0; i \u003c n; i++){ bool flag = true; int g_x = get\u003c0\u003e(g[i]), g_y = get\u003c1\u003e(g[i]); for(int j = 0; j \u003c m; j++){ int s_x = get\u003c0\u003e(s[j]), s_y = get\u003c1\u003e(s[j]), s_r = get\u003c2\u003e(s[j]); if( pow((g_x - s_x), 2) + pow((g_y - s_y), 2) \u003c= pow(s_r, 2)){ flag = false; break; } } if(flag){ ret += 1; } } */ for (int j = 0; j \u003c m; j++) { int s_x = get\u003c0\u003e(s[j]), s_y = get\u003c1\u003e(s[j]), s_r = get\u003c2\u003e(s[j]); for (int dx = -s_r; dx \u003c= s_r; dx++) { for (int dy = -s_r; dy \u003c= s_r; dy++) { if (s_x + dx \u003e= 0 \u0026\u0026 s_x + dx \u003c 10000 + 5 \u0026\u0026 s_y + dy \u003e= 0 \u0026\u0026 s_y + dy \u003c 10000 + 5) { // double check the name of variables is correct if (dx * dx + dy * dy \u003c= s_r * s_r) { board[s_x + dx][s_y + dy] = false; } } } } } int ret = 0; for (int i = 0; i \u003c n; i++) { int g_x = get\u003c0\u003e(g[i]), g_y = get\u003c1\u003e(g[i]); if (board[g_x][g_y]) { ret += 1; } } cout \u003c\u003c ret; return 0; } ","date":"2021-01-29","objectID":"/coding_practice_4/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"OJ 2","date":"2021-01-28","objectID":"/coding_practice_3/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"OJ Practice 3, share my solution for these three OJ problems. ","date":"2021-01-28","objectID":"/coding_practice_3/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"NCPC 2011 Problem B: Mega Inversion using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { const int N = 2 * 1e5 + 10; const int origin = 1e5 + 10; public: vector\u003cll\u003e countLarger(vector\u003cint\u003e\u0026 nums){ vector\u003cll\u003e segtree(2 * N + 2, 0); reverse(nums.begin(), nums.end()); for(int i = 0; i \u003c nums.size(); ++i){ nums[i] = -nums[i]; } vector\u003cll\u003e result; for (int i = nums.size()-1; i \u003e= 0; i--) { result.push_back(rangeQuery(segtree, origin + nums[i])); update(segtree, origin + nums[i]); } return result; } vector\u003cll\u003e countSmaller(vector\u003cint\u003e\u0026 nums) { vector\u003cll\u003e segtree(2*N + 2, 0); vector\u003cll\u003e result; for (int i = nums.size()-1; i \u003e= 0; i--) { result.push_back(rangeQuery(segtree, origin + nums[i])); update(segtree, origin + nums[i]); } // need to reverse result reverse(result.begin(), result.end()); return result; } void update(vector\u003cll\u003e\u0026 segtree, int index) { for (index += N; index \u003e 0; index \u003e\u003e= 1) { segtree[index]++; } } ll rangeQuery(vector\u003cll\u003e\u0026 segtree, int entry) { int left = 0; int right = entry; ll result = 0; for (left += N, right += N; left \u003c right; left \u003e\u003e= 1, right \u003e\u003e= 1) { if(entry == 6 + origin){ } if (left%2 == 1) result += segtree[left++]; if (right%2 == 1) result += segtree[--right]; } return result; } }; int main() { Solution s; int n; cin \u003e\u003e n; vector\u003cint\u003e nums; int t; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e t; nums.push_back(t); } vector\u003cll\u003e smaller = s.countSmaller(nums); vector\u003cll\u003e larger = s.countLarger(nums); ll ret = 0; for(int i = 0; i \u003c larger.size(); i ++){ ret += (larger[i] * smaller[i]); } cout \u003c\u003c ret; return 0; } ","date":"2021-01-28","objectID":"/coding_practice_3/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"OJ 2","date":"2021-01-27","objectID":"/coding_practice_2/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"OJ Practice 2, share my solution for these three OJ problems. ","date":"2021-01-27","objectID":"/coding_practice_2/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"Robots on a grid using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { public: int test() { } }; int solve(vector\u003cvector\u003cint\u003e\u003e\u0026 board){ int m = board.size(), n = board[0].size(); int step = 0; vector\u003cint\u003e dirs = {0, 1, 0, -1, 0}; set\u003cint\u003e seen; deque\u003cint\u003e q; q.push_back(0); seen.insert(0); while(q.size()){ int size = q.size(); for(int i = 0; i \u003c size; i++){ int p = q.front(); q.pop_front(); int r = p / n, c = p % n; if(r == m - 1 \u0026\u0026 c == n - 1){ return step; } else{ for(int i = 0; i \u003c 4; i++){ int nr = r + (board[r][c] * dirs[i]), nc = c + (board[r][c] * dirs[i + 1]); if(nr \u003e= 0 \u0026\u0026 nr \u003c m \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n){ int np = nr * n + nc; if(seen.find(np) == seen.end()){ seen.insert(np); q.push_back(np); } } } } } step += 1; } return -1; } int main() { int m, n; cin \u003e\u003e m \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e board(m, vector\u003cint\u003e(n, 0)); char c; for(int i = 0; i \u003c m; i++){ for(int j = 0; j \u003c n; j++){ cin \u003e\u003e c; board[i][j] = c - '0'; } } // for(int i = 0; i \u003c m; i++){ // for(int j = 0; j \u003c n; j++){ // cout \u003c\u003c board[i][j]; // } // } cout \u003c\u003c solve(board); return 0; } ","date":"2021-01-27","objectID":"/coding_practice_2/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"SERGRID - Grid using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int solve(vector\u003cvector\u003cunsigned int\u003e\u003e\u0026 board){ int n = board.size() - 1; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= n; j++){ if(board[i][j] == -1){ board[i][j] = 0; } else{ board[i][j] = (board[i][j - 1] % 0x7FFFFFFF + board[i - 1][j] % 0x7FFFFFFF) % 0x7FFFFFFF; } } } return board[n][n]; } bool isValid(vector\u003cvector\u003cint\u003e\u003e\u0026 board){ int n = board.size(); // invalid board if(board[0][0] == -1){ return false; } vector\u003cint\u003e dirs = {0, 1, 0, -1, 0}; // r * n + c set\u003cint\u003e seen; deque\u003cint\u003e d; seen.insert(0); d.push_back(0); while(d.size()){ int p = d.front(); d.pop_front(); int r = p / n, c = p % n; if(r == n - 1 \u0026\u0026 c == n - 1){ return true; } else{ for(int i = 0; i \u003c dirs.size() - 1; i++){ int nr = r + dirs[i], nc = c + dirs[i + 1]; if(nr \u003e= 0 \u0026\u0026 nr \u003c n \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n \u0026\u0026 board[nr][nc] == 0){ int np = nr * n + nc; if(seen.find(np) == seen.end()){ seen.insert(np); d.push_back(np); } } } } } return false; } int main() { int n; char c; cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e validBoard(n, vector\u003cint\u003e(n, 0)); vector\u003cvector\u003cunsigned int\u003e\u003e board(n + 1, vector\u003cunsigned int\u003e(n + 1, 0)); for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c n; j++){ cin \u003e\u003e c; if(c == '.'){ board[i + 1][j + 1] = 0; validBoard[i][j] = 0; } else{ board[i + 1][j + 1] = -1; validBoard[i][j] = -1; } } } if(isValid(validBoard) == false){ cout \u003c\u003c \"INCONCEIVABLE\"; return 0; } board[0][1] = 1; int ret = solve(board); if (ret != 0){ cout \u003c\u003c ret; } else{ if(isValid(validBoard) == false){ cout \u003c\u003c \"INCONCEIVABLE\"; return 0; } else{ cout \u003c\u003c \"THE GAME IS A LIE\"; } } return 0; } ","date":"2021-01-27","objectID":"/coding_practice_2/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"OJ 1","date":"2021-01-26","objectID":"/coding_practice_1/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"OJ Practice 1, share my solution for these three OJ problems. ","date":"2021-01-26","objectID":"/coding_practice_1/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2013 Problem E: Timebomb #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int main() { string s; vector\u003cstring\u003e l; for(int i = 0; i \u003c 5; ++i){ std::getline (std::cin,s); l.push_back(s); } // for(string s : l){ // cout \u003c\u003c s \u003c\u003c endl; // } vector\u003cstring\u003e num_str = {\"75557\", \"11111\", \"71747\", \"71717\", \"55711\", \"74717\", \"74757\", \"71111\", \"75757\", \"75717\"}; unordered_map\u003cstring, int\u003e ref; for(int i = 0; i \u003c num_str.size(); ++i){ ref[num_str[i]] = i; } long long num = 0; vector\u003cint\u003e number; for(int i = 0; i \u003c l[0].size(); i += 4){ string s = \"\"; for(int k = 0; k \u003c 5; k++){ int counter = 0; for(int j = 0; j \u003c 3; j++){ if(l[k][i + j] == '*'){ counter += pow(2, 2- j); } } s += to_string(counter); } if(ref.find(s) == ref.end()){ cout \u003c\u003c \"BOOM!!\"; return 0; } else{ number.push_back(ref[s]); } } for(int i = 0; i \u003c number.size(); i += 1){ num = num * 10 + number[i]; } if(num % 6 == 0){ cout \u003c\u003c \"BEER!!\"; return 0; } else{ cout \u003c\u003c \"BOOM!!\"; return 0; } return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2015 Problem C: Cryptographer’s Conundrum #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int solve(string s){ int counter = 0; vector\u003cchar\u003e ref = {'P', 'E', 'R'}; for(int i = 0; i \u003c s.length(); ++i){ if(s[i] != ref[i % 3]){ counter += 1; } } return counter; } int main() { string s; cin \u003e\u003e s; cout \u003c\u003c solve(s) \u003c\u003c \"\\n\"; return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2011 Problem E: ls #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* *.* 4 main.c a.out readme yacc */ bool solve(string s, string p){ int s_len = s.length(), p_len = p.length(); vector\u003cvector\u003cbool\u003e\u003e dp(s_len + 1, vector\u003cbool\u003e(p_len + 1, false)); dp[0][0] = true; for(int j = 1; j \u003c= p_len; ++j){ if(p[j - 1] == '*'){ dp[0][j] = dp[0][j-1]; } else{ dp[0][j] = false; } } for(int i = 1; i \u003c= s_len; ++i){ for(int j = 1; j \u003c= p_len; ++j){ if(p[j-1] == '*'){ dp[i][j] = dp[i-1][j] || dp[i][j-1] || dp[i-1][j-1]; } else{ if(p[j-1] == s[i-1]){ dp[i][j] = dp[i-1][j-1]; } else{ dp[i][j] = false; } } } } return dp[s_len][p_len]; } int main() { int n = 0; string p, s; cin \u003e\u003e p; cin \u003e\u003e n; vector\u003cstring\u003e l; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e s; if(solve(s, p)){ l.push_back(s); } } for(string s : l){ cout \u003c\u003c s \u003c\u003c endl; } return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:3:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 315 - Count of Smaller Numbers After Self","date":"2021-01-23","objectID":"/leetcode_315/","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Use Segment Tree to solve Leetcode 315 - Count of Smaller Numbers After Self. ","date":"2021-01-23","objectID":"/leetcode_315/:0:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 315 You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. ","date":"2021-01-23","objectID":"/leetcode_315/:1:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 315 Example1: Input: nums = [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. ","date":"2021-01-23","objectID":"/leetcode_315/:2:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 315 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class SegmentTreeNode(object): # range[min, max] def __init__(self, min, max): self.min = min self.max = max self.mid = (self.max - self.min) // 2 + self.min self.count = 0 self.right = None self.left = None class SegmentTree(object): def __init__(self, root): self.root = root def update(self, value): self.updateHelper(value, self.root) def updateHelper(self, value, node): if node == None: return if value \u003c node.min or value \u003e node.max: return node.count += 1 if node.min == node.max: return working_mid = node.mid if node.left == None: node.left = SegmentTreeNode(node.min, working_mid) if node.right == None: node.right = SegmentTreeNode(working_mid + 1, node.max) if value \u003e working_mid: self.updateHelper(value, node.right) else: self.updateHelper(value, node.left) def queryRange(self, value): return self.queryRangeHelper(value, self.root) def queryRangeHelper(self, value, node): if node == None: return 0 if value \u003e= node.max: return node.count working_mid = node.mid if value \u003c= working_mid: return self.queryRangeHelper(value, node.left) else: return self.queryRangeHelper(value, node.right) + self.queryRangeHelper(value, node.left) class Solution: def countSmaller(self, nums: List[int]) -\u003e List[int]: if len(nums) == 0: return [] ret = [] root = SegmentTreeNode(min(nums), max(nums)) tree = SegmentTree(root) for i in range(len(nums) - 1, -1, -1): ret.append(tree.queryRange(nums[i] - 1)) tree.update(nums[i]) return ret[::-1] ","date":"2021-01-23","objectID":"/leetcode_315/:3:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Remark For each TreeNode, count refers to how many number between [max, min] O(nlogk) solution, where k is the max difference ","date":"2021-01-23","objectID":"/leetcode_315/:4:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 732 - My Calendar III","date":"2021-01-21","objectID":"/leetcode_732/","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Use Segment Tree to solve Leetcode 732 - My Calendar III. ","date":"2021-01-21","objectID":"/leetcode_732/:0:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 732 A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.) You are given some events [start, end), after each given event, return an integer k representing the maximum k-booking between all the previous events. Implement the MyCalendarThree class: MyCalendarThree() Initializes the object. int book(int start, int end) Returns an integer k representing the largest integer such that there exists a k-booking in the calendar. ","date":"2021-01-21","objectID":"/leetcode_732/:1:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 732 Example1: Input [\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"] [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]] Output [null, 1, 1, 2, 3, 3, 3] Explanation MyCalendarThree myCalendarThree = new MyCalendarThree(); myCalendarThree.book(10, 20); // return 1, The first event can be booked and is disjoint, so the maximum k-booking is a 1-booking. myCalendarThree.book(50, 60); // return 1, The second event can be booked and is disjoint, so the maximum k-booking is a 1-booking. myCalendarThree.book(10, 40); // return 2, The third event [10, 40) intersects the first event, and the maximum k-booking is a 2-booking. myCalendarThree.book(5, 15); // return 3, The remaining events cause the maximum K-booking to be only a 3-booking. myCalendarThree.book(5, 10); // return 3 myCalendarThree.book(25, 55); // return 3 ","date":"2021-01-21","objectID":"/leetcode_732/:2:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 732 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class TreeNode: # segment tree with lazy propogation for range max query # half-open interval [lo, hi) def __init__(self, low, high, val=0, lazy=0, leftChild = None, rightChild = None): self.low = low self.high = high # range max self.val = val # bookings to add to the children the next time children get visited self.lazy = lazy self.leftChild = leftChild self.rightChild = rightChild class MyCalendarThree: MIN_BOUND = 0 MAX_BOUND = 1e9 + 1 def __init__(self): self.root = TreeNode(MyCalendarThree.MIN_BOUND, MyCalendarThree.MAX_BOUND) def book(self, start: int, end: int) -\u003e int: # update the segment from top to down, using lazy propogation self.update(self.root, start, end) return self.root.val def update(self, node, start, end): # we found the match, increment the value and lazy to be propogated if node.low == start and node.high == end: node.val += 1 node.lazy += 1 return mid = (node.high - node.low) // 2 + node.low # top-down building the segment tree if node.leftChild == None and node.rightChild == None: node.leftChild = TreeNode(node.low, mid, node.lazy, node.lazy) node.rightChild = TreeNode(mid, node.high, node.lazy, node.lazy) else: node.leftChild.val += node.lazy node.leftChild.lazy += node.lazy node.rightChild.val += node.lazy node.rightChild.lazy += node.lazy node.lazy = 0 # after building the children, we are able to traverse downwards if mid \u003e= end: self.update(node.leftChild, start, end) elif mid \u003c= start: self.update(node.rightChild, start, end) else: self.update(node.leftChild, start, mid) self.update(node.rightChild, mid, end) node.val = max(node.leftChild.val, node.rightChild.val) return # credit to https://leetcode.com/problems/my-calendar-iii/discuss/1023625/Python-Segment-Tree-with-Lazy-Propagation ","date":"2021-01-21","objectID":"/leetcode_732/:3:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Remark We treat this problem as segment tree(interval tree) where each book would trigger the building of tree To build the tree top-down, we utilize Lazy Propagation ","date":"2021-01-21","objectID":"/leetcode_732/:4:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Data Structure"],"content":"This article reviews segment tree.","date":"2021-01-20","objectID":"/segment_tree/","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"This article reviews Segment Tree. Segment Tree ","date":"2021-01-20","objectID":"/segment_tree/:0:0","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Semantics This balanced tree data structure stores the aggregation of certain property within certain range. build(start, end, vals): construct the segment tree update(index, value): update the A[index] to value rangeQuery(start, end) query the aggregation of certain range [start, end] ","date":"2021-01-20","objectID":"/segment_tree/:0:1","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Implementation class SegmentTreeNode: def __init__(self, start, end, val, left=None, right=None): self.start = start self.end = end self.mid = start + (end - start) // 2 self.val = val self.left = left self.right = right class SegmentTree: def __init__(self, nums): self.nums = nums if self.nums: self.root = self.build(0, len(nums) - 1, nums) def build(self, start, end, nums): if start == end: return SegmentTreeNode(start, end, nums[start]) mid = (end - start) // 2 + start leftNode = self.build(start, mid, nums) rightNode = self.build(mid + 1, end, nums) return SegmentTreeNode(start, end, leftNode.val + rightNode.val, leftNode, rightNode) def update(self, index, value): self.updateHelper(self.root, index, value) def updateHelper(self, node, index, value): if node.start == index and node.end == index: node.val = value return if index \u003c= node.mid: self.updateHelper(node.left, index, value) else: self.updateHelper(node.right, index, value) node.val = node.left.val + node.right.val def queryRange(self, start, end): return self.queryRangeHelper(self.root, start, end) def queryRangeHelper(self, node, start, end): if node.start == start and node.end == end: return node.val elif end \u003c= node.mid: return self.queryRangeHelper(node.left, start, end) elif start \u003e node.mid: return self.queryRangeHelper(node.right, start, end) else: return self.queryRangeHelper(node.left, start, node.mid) + self.queryRangeHelper(node.right, node.mid + 1, end) ","date":"2021-01-20","objectID":"/segment_tree/:0:2","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Efficienty Analysis buil -\u003e O(n) update -\u003e O(log n) rangeQuery -\u003e ~ O(log n) ","date":"2021-01-20","objectID":"/segment_tree/:0:3","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Remarks query range with mutable arrays ","date":"2021-01-20","objectID":"/segment_tree/:0:4","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 947 - Most Stones Removed with Same Row or Column","date":"2021-01-17","objectID":"/leetcode_947/","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 947 - Most Stones Removed with Same Row or Column. ","date":"2021-01-17","objectID":"/leetcode_947/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 947 On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed. ","date":"2021-01-17","objectID":"/leetcode_947/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 947 Example1: Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5 Explanation: One way to remove 5 stones is as follows: 1. Remove stone [2,2] because it shares the same row as [2,1]. 2. Remove stone [2,1] because it shares the same column as [0,1]. 3. Remove stone [1,2] because it shares the same row as [1,0]. 4. Remove stone [1,0] because it shares the same column as [0,0]. 5. Remove stone [0,1] because it shares the same row as [0,0]. Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane. Example2: Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3 Explanation: One way to make 3 moves is as follows: 1. Remove stone [2,2] because it shares the same row as [2,0]. 2. Remove stone [2,0] because it shares the same column as [0,0]. 3. Remove stone [0,2] because it shares the same row as [0,0]. Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane. Example3: Input: stones = [[0,0]] Output: 0 Explanation: [0,0] is the only stone on the plane, so you cannot remove it. ","date":"2021-01-17","objectID":"/leetcode_947/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 947 from collections import deque, Counter class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): # already inserted if p in self.parents: return True else: self.num_sets += 1 self.parents[p] = p self.sizes[p] = 1 return False def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, [p, q]) if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sets -= 1 class Solution: def removeStones(self, stones: List[List[int]]) -\u003e int: row_stone = {} # row -\u003e stone location col_stone = {} # col -\u003e stone location for stone in stones: i, j = stone[0], stone[1] location = (i, j) if i in row_stone: row_stone[i].add(location) else: row_stone[i] = set() row_stone[i].add(location) if j in col_stone: col_stone[j].add(location) else: col_stone[j] = set() col_stone[j].add(location) disjoint_set = UnionFind() all_stone = set() for stone in stones: i, j = stone[0], stone[1] location = (i, j) if disjoint_set.contains(location): continue else: # do a little bfs here to find all the connected component my_queue = deque() my_queue.append(location) row_seen = set() col_seen = set() while(len(my_queue) != 0): cur_loc = my_queue.pop() disjoint_set.insert(cur_loc) disjoint_set.union(cur_loc, location) all_stone.add(cur_loc) i, j = cur_loc[0], cur_loc[1] if i not in row_seen: row_seen.add(i) for stone in row_stone[i]: my_queue.append(stone) if j not in col_seen: col_seen.add(j) for stone in col_stone[j]: my_queue.append(stone) leader_size = {} for stone in all_stone: real_leader = disjoint_set.find(stone) if real_leader not in leader_size: leader_size[real_leader] = disjoint_set.sizes[real_leader] else: leader_size[real_leader] = disjoint_set.sizes[real_leader] ret = 0 for leader in leader_size: ret += (leader_size[leader] - 1) return ret ","date":"2021-01-17","objectID":"/leetcode_947/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Remark We define connected-compoent as the componet of stones share same col/row with at least 1 other stone in the graph STEP1, remember all the locations of the stones STEP2, create disjoint set that stores all connected-component together STEP3, for each connected component, we greedily pick the size-1 of that component ","date":"2021-01-17","objectID":"/leetcode_947/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 827 - Making A Large Island","date":"2021-01-15","objectID":"/leetcode_827/","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 827 - Making A Large Island. ","date":"2021-01-15","objectID":"/leetcode_827/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). ","date":"2021-01-15","objectID":"/leetcode_827/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3. Example2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4. ","date":"2021-01-15","objectID":"/leetcode_827/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t : self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sets -= 1 return False class Solution: def largestIsland(self, grid: List[List[int]]) -\u003e int: dirs = [0, 1, 0, -1, 0] # Step1, union 1's and find 0's disjoint_set = UnionFind() all_zeros = set() ret = 0 m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == 1: base = i * n + j disjoint_set.insert(base) for t in range(len(dirs) - 1): if i + dirs[t] \u003e= 0 and i + dirs[t] \u003c m and j + dirs[t + 1] \u003e= 0 and j + dirs[t + 1] \u003c n and grid[i + dirs[t]][j + dirs[t + 1]] == 1: neighbour = (i + dirs[t]) * n + (j + dirs[t + 1]) disjoint_set.insert(neighbour) disjoint_set.union(neighbour, base) else: all_zeros.add((i, j)) # edge case, all 1's, just return the size of the grid if len(all_zeros) == 0: return m * n # for all possible zeros, try to flip it for zero in all_zeros: i, j = zero[0], zero[1] leader_size = {} for t in range(len(dirs) - 1): if i + dirs[t] \u003e= 0 and i + dirs[t] \u003c m and j + dirs[t + 1] \u003e= 0 and j + dirs[t + 1] \u003c n and grid[i + dirs[t]][j + dirs[t + 1]] == 1: leader = disjoint_set.find((i + dirs[t]) * n + (j + dirs[t + 1])) if leader in leader_size: continue else: leader_size[leader] = disjoint_set.sizes[leader] ret = max(ret, sum(list(leader_size.values())) + 1) return ret ","date":"2021-01-15","objectID":"/leetcode_827/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Naive Approach tries all the zeros, and recompute the connected component Union Find helps us to find the size of the connected component without computing the graph again, O(n*m) ","date":"2021-01-15","objectID":"/leetcode_827/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 1722 - Minimize Hamming Distance After Swap Operations.","date":"2021-01-14","objectID":"/leetcode_1722/","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 1722 - Minimize Hamming Distance After Swap Operations. ","date":"2021-01-14","objectID":"/leetcode_1722/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 1722 You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 \u003c= i \u003c= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source. ","date":"2021-01-14","objectID":"/leetcode_1722/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 1722 Example1: Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output: 1 Explanation: source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example1: Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output: 2 Explanation: There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. ","date":"2021-01-14","objectID":"/leetcode_1722/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 1722 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sizes = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.num_sizes += 1 self.parents[p] = p self.sizes[p] = 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # this means that we found a redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sizes -= 1 return False class Solution: def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(source) for i in range(n): disjoint_set.insert(i) # build the union graph # in each group, the numbers can be placed anywhere for edge in allowedSwaps: disjoint_set.union(edge[0], edge[1]) # hashmap, # group leader -\u003e set[indices in that group] leader_member = {} print(disjoint_set.parents) for member, leader in disjoint_set.parents.items(): # This is the real leader for this member leader = disjoint_set.find(member) if leader in leader_member: leader_member[leader].add(member) else: leader_member[leader] = set([member]) print(leader_member) ret = 0 # for all the members, try to figure out the distance for members in leader_member.values(): source_numbers = [source[i] for i in members] target_numbers = [target[i] for i in members] ret += sum((Counter(source_numbers) - Counter(target_numbers)).values()) return ret ","date":"2021-01-14","objectID":"/leetcode_1722/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To solve this problem, we need to observe that if (0, 1) is exchangeable and (0, 2) is exchangeable, then any pair in (0, 1, 2) can be exchangeble. The remaining problem is how to detect connected components in the graph -\u003e use Union Find. Counter, the subclass of dictionary, supports many great opeartions. ","date":"2021-01-14","objectID":"/leetcode_1722/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Entertainment"],"content":"牛振华三部曲","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/","tags":["Movie Review","Chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Entertainment"],"content":"Stand Up, Don’t Bend Over 1993 Back to Back, Face to Face 1994 Signal Left, Turn Right 1995 闲来无事，写一篇影评，记录一下2021的开始。 偶然的机会看了一部反应中国政治生态的小短篇，之后有评论里提到一部《背靠背，脸对脸》的电影，简单的名字往往藏着不平凡的故事，youtube和b站搜了一下，有版权，随即看了一下。 这三部电影都由牛振华主演，黄建新执导，用幽默的手法反应当时90年代的都市百态、经济生活，政治生态。《背靠背，脸对脸》《站直喽，别趴下》《红灯停绿灯行》合称“都市百态三部曲”。 《背靠背，脸对脸》讲述的是一个文物馆的王双立副馆长，绞尽脑汁想上位一把手的故事。通过王副馆长在其转正过程中一波三折的经历，反应了现代化社会中复杂微妙的人际关系以及错综复杂的政治生态。牛振华饰演的王副馆长是一位有能力，懂得政治手段的领导，难能可贵的是，牛的表演展现了人的复杂性，矛盾性。和当今社会网络中许多线性的人设不同，现实中人的生活是对立统一的，在学会使用矛盾的观点看身边的问题之同时，辩证地理解人性的复杂。以及句兆杰饰演的会计在多次倒戈中体现出“没有永远的盟友，只有永远的利益”这点现实，值得回味。 《站直喽，别趴下》描述了“流氓”张永武（牛振华饰）通过养鱼发家致富，通过自己的努力和敢于拼搏的精神成为那栋楼里最有排面的人。原先看不起张永武的刘干部（达式常饰）和由高作家（冯巩饰）最终在利益的趋势下，像所谓的物质生活低头，改变了对张永武原先“地痞流氓”的标签。电影反应了当时社会“有钱没文化，有文化没钱”，张永武的渔业公司发展壮大后，要求高作家搬出这栋楼，在张永武一系列盘外招的干扰下，高作家连夜搬家，最后高作家蹲在地上收拾东西的镜头，抛出文化人是否向物质低头这个命题。 《红灯停绿灯行》讲述的是学车时发生的一系列故事，　记者苟宇佳（牛振华 饰）、下岗女工程芬（丁嘉丽 饰）、个体户绿豆（王劲松 饰）、大款老差（句号 饰）是驾校1025班的成员，在退伍军人侯教练手下练习。随着时间的推移，大家渐渐摸清彼此的习性。记者小苟八面玲珑，处事圆滑，一心想把学车费报销，结果天不遂人愿；待业女工阿芬被下海的丈夫发来离婚的传票，一人带着女儿，老实度日；早年丧父，母亲瘫痪在床的绿豆沾染上了毒品，白天学车，半夜偷井盖，却是个孝顺儿子；大款老差则是个打着盹儿都能赚上十万、八万的有钱人，不把驾校规定放在眼里；侯教练的教练身份为他带来了免费的香烟和赚回扣的机会，也因此引火烧身，弄得家里鸡犬不宁。 这段驾校生活，波折连连，却都一一化险为夷，5人间的暗战明战也都随着考试的顺利通关而结束。这段驾校的经历牵扯出了5个人的悲喜，除了学到了驾驶规则，似乎更学到了生存法则。credit to 豆瓣 总的来说，这三篇电影风格类似，大致都描述了错综复杂的人际关系和现代化社会的一些拜金主义苗头。人是复杂的而非线性的，生活是矛与盾的结合。网络很容易让人陷入一种单纯的思考状态，认为所有事物都是线性的，贴标签似的理解事情，这样显然很简单，也很容易，但写到这里，也想到百度CEO李彦宏曾对推荐算法有一番说辞，大致描述说推荐算法使得网民失去多样性，在计算了相似度以后，用户喜欢XX就一直推送XX，如果平台一直都是“投其所好”,把用户困在一个圈子里，丧失了获得多样性的机会，也使得很多用户失去了辩证思维。江泽民总书记曾说过 “对现实社会中的问题，我们要进行理性的思考。因为我们看到的现象，其中有的是真相，有的却是假象。只有把感性上升到理性，才能深化认识，才能把握事物的本质。”这几部电影在消遣时间的同时，也敲响了辩证思考的警钟，但从头论，本人也是被推荐算法带进这些电影的，不免有些讽刺。 希望以后思考问题能够深入本质，别太狭隘。 ","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/:0:0","tags":["Movie Review","Chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 547 - Number of Provinces.","date":"2021-01-13","objectID":"/leetcode_547/","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 547 - Number of Provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]] Output: 2 Example2: Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]] Output: 3 ","date":"2021-01-13","objectID":"/leetcode_547/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 class Solution: def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(isConnected) for i in range(n): disjoint_set.insert(i) for i in range(n): for j in range(n): if isConnected[i][j]: disjoint_set.union(i, j) return disjoint_set.num_sets ","date":"2021-01-13","objectID":"/leetcode_547/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To find the connected component in undirected graph, Union Find(Disjoint Set) is the handy data structure to use. ","date":"2021-01-13","objectID":"/leetcode_547/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Data Structure"],"content":"This article reviews union find.","date":"2021-01-12","objectID":"/union_find/","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"This article reviews Union Find(Disjoint Set). Union Find | Disjoint Set ","date":"2021-01-12","objectID":"/union_find/:0:0","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Semantics This data structure stores the collection of disjoint(non-overlapping) sets(groups). find(p): find the leader of group that contains p union(p, q): merge two groups ","date":"2021-01-12","objectID":"/union_find/:0:1","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Implementation class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 ","date":"2021-01-12","objectID":"/union_find/:0:2","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Efficienty Analysis O(n) in memory, O(1) for union and look up in amortized analysis ","date":"2021-01-12","objectID":"/union_find/:0:3","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Remarks Check whether two elements belong to the same group. To find connected components in graph (usually undirected) Speed up implementation of kruskal’s algorithm ","date":"2021-01-12","objectID":"/union_find/:0:4","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":null,"content":" Welcome to  Haihao Sun’s field! Self Introduction Haihao SunTravelling \" Travelling Hi there! I am Haihao Sun, and my hobbies come and go. I enjoy travelling, playing Go, playing pokemon, and developing(AKA coding). I was born in Nanjing, and I currently live in San Diego . Skills JavaScript SQL C/C++  Java Python Extended Links Linkedin Blog Version I Github ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Page","uri":"/about/"}]