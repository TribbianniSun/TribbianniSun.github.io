[{"categories":["interview cheatsheet"],"content":"简述TCP的time_wait摘抄","date":"2021-03-10","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/","tags":["wi21-week10","interview prep","网络协议"],"title":"简述TCP的time_wait摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/"},{"categories":["interview cheatsheet"],"content":"“简述TCP的time_wait摘抄” ","date":"2021-03-10","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/:0:0","tags":["wi21-week10","interview prep","网络协议"],"title":"简述TCP的time_wait摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/"},{"categories":["interview cheatsheet"],"content":"什么是 TIME_WAIT 主动关闭连接的一方最终进入TIME_WAIT状态等待一段才真正的释放内核中的连接记录，在释放记录之前这个连接使用的本地端口将一直被占用。 保持一段时间的TIME_WAIT的理由是：担心”ack N+1″没有送达，导致被动方重传”FIN N”，那么主动方应当再次响应”ack N+1″。 如果没有TIME_WAIT就直接复用该连接占用的端口，那么万一被动方重传”FIN N”，那么使用相同端口的新连接就会被错误关闭。 ","date":"2021-03-10","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/:1:0","tags":["wi21-week10","interview prep","网络协议"],"title":"简述TCP的time_wait摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/"},{"categories":["interview cheatsheet"],"content":"\u0008优化TIME_WAIT 谁主动关闭socket，谁TIME_WAIT。 如果双方响应正常，TIME_WAIT应该只是瞬间状态。 因此，不明确”客户端主动关闭”/”服务端主动关闭”就讨论TIME_WAIT就是耍流氓。 ","date":"2021-03-10","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/:2:0","tags":["wi21-week10","interview prep","网络协议"],"title":"简述TCP的time_wait摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/"},{"categories":["interview cheatsheet"],"content":"服务端主动关闭 无论有多少连接，服务端都只有一个端口，那就是监听端口，大量连接之间的差异仅仅是TCP 4元祖的客户端ip和port不同而已。 因此服务端TIME_WAIT压根不会耗尽端口，因为它就一个端口。 那么服务端就不需要优化了吗？对，没必要优化，一个TIME_WAIT的4元祖当遇到新的SYN时会复用，不需要特殊配置。 另外，当TIME_WAIT数量超过内核选项net.ipv4.tcp_max_tw_buckets的限制时，多余的TIME_WAIT连接将被立即关闭，然后在netstat -s中留下如下的溢出统计指标： TCPTimeWaitOverflow: 127688100 ","date":"2021-03-10","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/:3:0","tags":["wi21-week10","interview prep","网络协议"],"title":"简述TCP的time_wait摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/"},{"categories":["interview cheatsheet"],"content":"客户端主动关闭 客户端每个连接都会随机选择一个本地端口，所以最终会导致客户端大量端口处于TIME_WAIT状态，这和服务端主动关闭是最大的不同。 所以我们通常所说的TIME_WAIT问题都是针对客户端的，只是好像很少有人提及这一点。 网上有一种优化手段是把net.ipv4.tcp_max_tw_buckets调低，这样TIME_WAIT连接就会被删除，但是这不是一个最佳手段哈。 目前唯一安全的选项就是同时开启如下2个选项： net.ipv4.tcp_timestamps=1（连接发起方和接收方都需要开启） net.ipv4.tcp_tw_reuse=1（只影响连接发起方） 它的作用是向外发起连接的时候，可以复用TIME_WAIT的端口，但是有一个前提： 该端口最后一次通讯时间距离当前系统时间\u003e1秒 tcp timestamp选项的作用就是内核会记录端口的最后通讯时间，这样reuse选项才有判断依据。 那么客户端复用TIME_WAIT连接，对服务端有啥影响呢？ \u0008TIME_WAIT就是为了确保给被动方的FIN回复ACK成功，这样对方才会离开LAST-ACK彻底结束连接。 图中的叉号就是回复ACK丢失的情况，按道理应该继续TIME_WAIT等待被动关闭方重传FIN，然而我们这时候我们重用端口新建到服务端的连接，发送SYN会被对方忽略，因为对方还处在上一个连接的LAST-ACK状态。 被动方稍后重传FIN，客户端的端口已经是SYN-SENT新建连接状态，因此回复对方RST让对方退出LAST-ACK状态。此后，客户端重传SYN，被动关闭方正常回复SYN+ACK，连接建立完成。 看起来，唯一顾虑的就是SYN重传会不会导致连接变慢？可能需要实际测试测试。 另外还有2个辅助优化手段，就是扩大内核选择端口的范围，比如调大为： net.ipv4.ip_local_port_range = 5120 65000 还有降低TIME_WAIT的保持时间（可以更短，比如10秒）： net.ipv4.tcp_fin_timeout=30 这样客户端可以有更多的端口使用。 ","date":"2021-03-10","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/:4:0","tags":["wi21-week10","interview prep","网络协议"],"title":"简述TCP的time_wait摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/"},{"categories":["interview cheatsheet"],"content":"总结 在所有机器上，生效如下参数： net.ipv4.tcp_timestamps=1 net.ipv4.tcp_tw_reuse=1 net.ipv4.ip_local_port_range = 5120 65000 net.ipv4.tcp_fin_timeout=30 如果你的内核版本低，那么需要确保禁用掉一个垃圾选项，它已经在4.x内核里彻底删除了： net.ipv4.tcp_tw_recycle=0 这可以应对TIME_WAIT问题，但是不是解决短连接问题的所有参数（可以阅读我的上一篇关于K8S的博客）。 ","date":"2021-03-10","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/:5:0","tags":["wi21-week10","interview prep","网络协议"],"title":"简述TCP的time_wait摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E7%AE%80%E8%BF%B0tcp%E7%9A%84time_wait/"},{"categories":["interview cheatsheet"],"content":"LinuxC内存管理摘抄","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"LinuxC内存管理摘抄 提到C语言，我们知道C语言和其他高级语言的最大的区别就是C语言是要操作内存的！ 我们需要知道，变量，其实是内存地址的一个抽像名字罢了。在静态编译的程序中，所有的变量名都会在编译时被转成内存地址。机器是不知道我们取的名字的，只知道地址。 内存的使用是程序设计中需要考虑的重要因素之一，这不仅由于系统内存是有限的（尤其在嵌入式系统中），而且内存分配也会直接影响到程序的效率。因此，我们要对C语言中的内存管理，有个系统的了解。 在C语言中，定义了4个内存区间：代码区 code；全局变量（静态变量区）static；局部变量区即stack；动态存储区即heap；具体如下： 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的 另一块区域。 - 程序结束后由系统释放。 常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 程序代码区—存放函数体的二进制代码。 ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:0:0","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"编译过程 首先我们要知道，源代码编译成程序，程序是放在硬盘上的，而非内存里！只有执行时才会被调用到内存中！ 我们来看看程序结构，ELF是是Linux的主要可执行文件格式。ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。具体如下： 1、Program header描述的是一个段在文件中的位置、大小以及它被放进内存后所在的位置和大小。 1、Program header描述的是一个段在文件中的位置、大小以及它被放进内存后所在的位置和大小。 即要加载的信息； 2、Sections保存着object 文件的信息，从连接角度看：包括指令，数据，符号表，重定位信息等等。在图中，我们可以看到Sections中包括： (1) .text 文本结 存放指令； (2) .rodata 数据结 readonly; (3) .data 数据结 可读可写； 3、Section头表（section header table）包含了描述文件sections的信息。每个section在这个表中有一个入口；每个入口给出了该section的名字，大小，等等信息。 相当于 索引！ ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:1:0","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"加载到内存里 而程序被加载到内存里面，又是如何分布的呢？我们看看上图中： 1、正文和初始化的数据和未初始化的数据就是我们所说的数据段，正文即代码段； 2、正文段上面是常量区，常量区上面是全局变量和静态变量区，二者占据的就是初始化的数据和未初始化的数据那部分； 3、再上面就是堆，动态存储区，这里是上增长； 4、堆上面是栈，存放的是局部变量，就是局部变量所在代码块执行完毕后，这块内存会被释放，这里栈区是下增长； 5、命令行参数就是$0 $1之类的，环境变量什么的前面的文章已经讲过，有兴趣的可以去看看。 ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:2:0","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"静态内存 内存管理—存储模型 存储模型决定了一个变量的内存分配方式和访问特性，在C语言中主要有三个维度来决定：1、存储时期 2、作用域 3、链接 存储时期 存储时期：变量在内存中的保留时间（生命周期） 存储时期分为两种情况,关键是看变量在程序执行过程中会不会被系统自动回收掉。 1) 静态存储时期 Static 在程序执行过程中一旦分配就不会被自动回收。 通常来说，任何不在函数级别代码块内定义的变量。 无论是否在代码块内，只要采用 static关键字修饰的变量。 2) 自动存储时期 Automatic 除了静态存储以外的变量都是自动存储时期的，或者说只要是在代码块内定义的非static的变量，系统会肚脐自动非配和释放内存； 作用域 作用域：一个变量在定义该变量的自身文件中的可见性（访问或者引用） 在C语言中，一共有3中作用域： 1) 代码块作用域 在代码块中定义的变量都具有该代码的作用域。从这个变量定义地方开始，到这个代码块结束，该变量是可见的； 2) 函数原型作用域 出现在函数原型中的变量，都具有函数原型作用域，函数原型作用域从变量定义处一直到原型声明的末尾。 3) 文件作用域 一个在所有函数之外定义的变量具有文件作用域，具有文件作用域的变量从它的定义处到包含该定义的文件结尾处都是可见的； 链接 链接：一个变量在组成程序的所有文件中的可见性（访问或者引用）； C语言中一共有三种不同的链接： 1) 外部链接 如果一个变量在组成一个程序的所有文件中的任何位置都可以被访问，则称该变量支持外部链接； 2) 内部链接 如果一个变量只可以在定义其自身的文件中的任何位置被访问，则称该变量支持内部链接。 3) 空链接 如果一个变量只是被定义其自身的当前代码块所私有，不能被程序的其他部分所访问，则成该变量支持空链接 #include \u003cstdio.h\u003e int a = 0;// 全局初始化区 char *p1; //全局未初始化区 int main() { int b; //b在栈区 char s[] = \"abc\"; //栈 char *p2; //p2在栈区 char *p3 = \"123456\"; //123456\\0在常量区，p3在栈上。 static int c =0； //全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。 strcpy(p1, \"123456\"); //123456\\0放在常量区，编译器可能会将它与p3所指向的\"123456\"优化成一个地方。 } ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:3:0","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"动态内存 当程序运行到需要一个动态分配的变量时，必须向系统申请取得堆中的一块所需大小的存储空间，用于存储该变量。当不在使用该变量时，也就是它的生命结束时，要显示释放它所占用的存储空间，这样系统就能对该空间进行再次分配，做到重复使用有限的资源。下面介绍动态内存申请和释放的函数。 ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:4:0","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"malloc函数 使用该函数时，有下面几点要注意： 1）只关心申请内存的大小； 2）申请的是一块连续的内存。记得一定要写出错判断； 3）显示初始化。即我们不知这块内存中有什么东西，要对其清零； ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:4:1","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"free函数 使用free(),也有下面几点要注意： 1）必须提供内存的起始地址； 调用该函数时，必须提供内存的起始地址，不能够提供部分地址，释放内存中的一部分是不允许的。 2）malloc和free配对使用； 编译器不负责动态内存的释放，需要程序员显示释放。因此，malloc与free是配对使用的，避免 内存泄漏。 3）不允许重复释放 因为这块内存被释放后，可能已另分配，这块区域被别人占用，如果再次释放，会造成数据丢失； ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:4:2","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"我们经常将堆和栈相比较： ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:5:0","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"申请方式  stack: 由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 heap: 需要程序员自己申请，并指明大小，在c中malloc函数 ,如p1 = (char *)malloc(10); ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:5:1","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"申请后系统的响应  栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:5:2","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"申请大小的限制  栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:5:3","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"申请效率的比较：  栈由系统自动分配，速度较快。但程序员是无法控制的。 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。 ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:5:4","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"堆和栈中的存储内容  栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:5:5","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"存取效率的比较  char s1[] = “aaaaaaaaaaaaaaa”; char *s2 = “bbbbbbbbbbbbbbbbb”; aaaaaaaaaaa是在运行时刻赋值的； 而bbbbbbbbbbb是在编译时就确定的； 但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。 #include void main() { char a = 1; char c[] = \"1234567890\"; char *p =\"1234567890\"; a = c[1]; a = p[1]; return; } 0: a = c[1]; 00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh] 0040106A 88 4D FC mov byte ptr [ebp-4],cl 11: a = p[1]; 0040106D 8B 55 EC mov edx,dword ptr [ebp-14h] 00401070 8A 42 01 mov al,byte ptr [edx+1] 00401073 88 45 FC mov byte ptr [ebp-4],al 第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。 ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:5:6","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"小结 堆和栈的区别可以用如下的比喻来看出：  栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。  堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 ","date":"2021-03-10","objectID":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:6:0","tags":["wi21-week10","interview prep","C/C++"],"title":"LinuxC内存管理摘抄","uri":"/cpp_linuxc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"B Tree和b+tree的区别摘抄","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"B Tree和b+tree的区别摘抄 以B tree和B+ tree的区别来分析mysql索引实现 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"B树 B树是一种多路自平衡搜索树，它类似普通的二叉树，但是B树允许每个节点有更多的子节点。B树示意图如下： ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"B树的特点： 所有key value都分布在整个树中 所有关键字只出现在一个节点中 搜索有可能在非叶子结点结束 在关键字全集中做一次查找，性能逼近二分查找算法 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"B+树 B+树是B树的变体，也是一种多路平衡查找树，B+树的示意图为： ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"从图中也可以看到，B+树与B树的不同在于： 所有关键字储存在叶子结点， 非叶子结点不存储真正的data 为所有叶子结点增加了一个指针 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:2:1","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"那么问题来了，为什么用B/B+树这种结构来实现索引呢？ 红黑树等结构也可以用来实现索引，但是文件系统及数据库管理普遍使用B/B+树来实现索引，mysql是基于磁盘的数据库，索引是以索引文件的形式存储在磁盘中的，索引的查找过程就会涉及到磁盘的 IO, 磁盘的IO比内存的消耗要高很多个数量级，所以索引的组织结构要设计得在找关键字时要尽量减少磁盘的IO次数，为什么要使用B/B+树，跟磁盘的存储原理有关。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:3:0","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"局部性原理与磁盘预读 为了提升效率，要尽量减少磁盘IO的次数。实际过程中，磁盘并不是每次严格按需读取，而是每次都会预读。磁盘读取完需要的数据后，会按顺序再多读一部分数据到内存中，这样做的理论依据是计算机科学中注明的局部性原理：(locality) 当一个数据被用到时，其附近的数据也通常会马上被使用 程序运行期间所需要的数据通常比较集中 由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)， 因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。 MySQL(默认使用InnoDB引擎),将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改)。linux 默认页大小为4K。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:3:1","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"B-Tree借助计算机磁盘预读的机制，并使用如下技巧： 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个结点只需一次I/O。 假设 B-Tree 的高度为 h,B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3，也即索引的B+树层次一般不超过三层，所以查找效率很高）。 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:3:2","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"为什么mysql的索引使用B+树而不是B树呢？？ B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高。 mysql是关系型数据库，经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。而B树每个节点的key和data在一起，无法进行区间查找。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:3:3","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"附加知识点理解 B树是为了磁盘或其他设备而设计的多岔（相对于二岔）平衡查找树。，所以B树又叫平衡多路查找树。一颗m阶的B树的特性为： 树中每个节点含有最多m个孩子(m \u003e 2)。 除根节点和叶子节点外，其他每个中间节点都至少有[ceil(m/2)]个孩子，ceil为向上取整。（不是很明白。。。） 所有叶子节点都出现在同一层，且叶子节点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null) 每个非叶子节点包含有n个关键字信息(n，P0，K1，P1，K2，P2，……，Kn，Pn)，其中： a) Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)\u003c Ki。 b) Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 c) 关键字的个数n必须满足： [ceil(m / 2)-1]\u003c= n \u003c= m-1。 这三天摘抄自文末参考，大致理解一下就行。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:4:0","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"example 比如，我们通过上面那张btree结构来查找29这个元素，查找过程为： （1）根据根节点找到文件目录的跟磁盘块1，将其中的信息装入到内存中【磁盘IO操作第1次】 （2）此时内存中有两个文件名17,35和三个存储其他磁盘页面地址的数据（指针），根据算法我们发现17 \u003c 29 \u003c35，因此我们找到指针p2 （3）根据指针p2我们找到磁盘块3，并将其中信息装入到内存中【磁盘IO操作第2次】 （4）此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据（指针），根据算法我们发现26 \u003c29\u003c30，因为我们找到指针p2 （5）根据指针p2我们定位到磁盘块8，并将其中信息装入内存【磁盘IO操作第3次】 （6）此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/:5:0","tags":["wi21-week10","interview prep","Database"],"title":"B Tree和b+tree的区别摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"浅谈query_processing摘抄","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/","tags":["wi21-week10","interview prep","Database"],"title":"浅谈query_processing","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/"},{"categories":["interview cheatsheet"],"content":"浅谈query_processing 我们知道，目前通用的数据库查询语言是SQL语言（Structured Query Language）。SQL语言也是一种编译型语言，需要SQL编译器编译后才能执行，但它与C、C++、Java等语言不同，SQL语言是一种非过程化语言，这意味着使用SQL进行操作的时候，你只需要指定你要达到什么目的，而无需指明要怎样达到目的。 既然用户只需要解决“做什么”的问题，那么，“怎么做”的问题正是本文要讨论的问题。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/:0:0","tags":["wi21-week10","interview prep","Database"],"title":"浅谈query_processing","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/"},{"categories":["interview cheatsheet"],"content":"优化器（Optimizer） 优化器也称查询优化器（Query Optimizer），它的主要工作是优化数据访问，根据提交的SQL语句，综合各种已有的信息（主要是系统编目表）来产生最优的可执行的访问方案。 优化器在整个数据库系统中占据着至高无上的地位，它是数据库性能的决定因素，是所有数据库引擎中最重要的组件。 优化器的工作可以直观的理解为以下4个步骤： 接收并验证SQL语句的语法语义； 分析环境并优化满足SQL语句的方法； 创建计算机可读指令来执行优化的SQL； 执行指令或存储他们以便将来执行。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/:1:0","tags":["wi21-week10","interview prep","Database"],"title":"浅谈query_processing","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/"},{"categories":["interview cheatsheet"],"content":"查询过程 SQL Query -\u003e Parse Query -\u003e Check Semantics -\u003e Rewrite Query -\u003e Optimize Access Plan -\u003e Generate Executable Code -\u003e Execute Plan ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/:2:0","tags":["wi21-week10","interview prep","Database"],"title":"浅谈query_processing","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/"},{"categories":["interview cheatsheet"],"content":"语法分析（Parse Query） SQL语句被提交给SQL编译器，编译器通过语法树（Parse Tree）分析该语句，检查其语法，如果存在语法错误，编译器就停止处理并返回错误信息；如果不存在语法问题，编译器会将SQL语句转换为可被优化器分析的逻辑查询语句（关系代数relational algebra语句），并据此创建该查询的查询图模。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/:3:0","tags":["wi21-week10","interview prep","Database"],"title":"浅谈query_processing","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/"},{"categories":["interview cheatsheet"],"content":"语义检查（Check Semantics） 语法分析完成后，编译器会根据查询图模型进行语义检查（比如检查语句中的数据类型是否与数据库的表列的数据类型一致），语义检查完成后也会将相关信息添加到查询图模型，包括参考约束，表检查约束，触发器，和视图信息等。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/:4:0","tags":["wi21-week10","interview prep","Database"],"title":"浅谈query_processing","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/"},{"categories":["interview cheatsheet"],"content":"查询重写（Rewrite Query） 如果SQL语句的语法语义都没有问题，就可以正式进行查询操作了。这是优化器进行查询优化的开始阶段，其目的是将提交的SQL语句优化成效率更高的形式。 这种优化可以是基于查询成本的考虑，也可以是基于查询规则的考虑，是基于关系代数语句进行的调整。举一个直观的例子： Select EMPLOYEE.Name, WELFARE.Bonus From EMPLOYEE, WELFARE Where EMPLOYEE.Seniority \u003e 5 And EMPLOYEE.Seniority = WELFARE.Seniority ; Select EMPLOYEE.Name, WELFARE.Bonus From EMPLOYEE, WELFARE Where EMPLOYEE.Seniority \u003e 5 And WELFARE.Seniority \u003e 5 And EMPLOYEE.Seniority = WELFARE.Seniority ; 很显然，两条语句的功能相同，第二条后面的“WELFARE.Seniority \u003e 5”条件还有点多余，那么，那条语句的执行效率更高？ 答案是第二条！因为第一条将EMPLOYEE中Seniority\u003e5的行与WELFARE中的所有行作外连接再来找Seniority相等的行，而第二条则是将EMPLOYEE中Seniority\u003e5的行和WELFARE中Seniority\u003e5的行作外连接再来找Seniority相等的行。显然，第二条语句只有更少的行参与外连接，效率自然更高。 可是，我们通常写出的查询语句都是第一条的形式，而查询重写却可以将之优化，优化器的查询重写器能自动帮我们完成查询语句的优化，找到更高效的查询形式。 当然了，查询重写并不是直接对SQL语句作上述例子那样的优化，它操作的是由语法分析转换过的关系代数语句，且需要根据重写图模型提供的信息作出形式优化。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/:5:0","tags":["wi21-week10","interview prep","Database"],"title":"浅谈query_processing","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/"},{"categories":["interview cheatsheet"],"content":"优化访问计划（Optimizer Access Plan） 根据查询图模型提供的信息，优化器会生成许多能够满足查询请求的访问计划（执行方案方案），然后优化器综合系统编目表中关于表，索引，列和函数等等的统计信息，估计每种访问计划的执行成本，并选择具有最小成本的方案作为最终的访问计划（Acess Plan）。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/:6:0","tags":["wi21-week10","interview prep","Database"],"title":"浅谈query_processing","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/"},{"categories":["interview cheatsheet"],"content":"生成可执行代码（Generate Executable Code） 根据最终选定的访问计划生成执行代码，类似C语言编译后生成可被机器识别的机器码一样。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/:7:0","tags":["wi21-week10","interview prep","Database"],"title":"浅谈query_processing","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/"},{"categories":["interview cheatsheet"],"content":"执行访问计划（Execute Plan） 执行可执行代码，获取查询结果集。 ","date":"2021-03-09","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/:8:0","tags":["wi21-week10","interview prep","Database"],"title":"浅谈query_processing","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%B5%85%E8%B0%88query_processing/"},{"categories":["interview cheatsheet"],"content":"什么是TCP粘包摘抄","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"什么是TCP粘包摘抄 在socket网络编程中，都是端到端通信，由客户端端口+服务端端口+客户端IP+服务端IP+传输协议组成的五元组可以明确的标识一条连接。在TCP的socket编程中，发送端和接收端都有成对的socket。发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。那么这样一来，接收端就必须使用高效科学的拆包机制来分辨这些数据。 ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:0:0","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"1.Q: 什么是TCP粘包问题? TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。 ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:1:0","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"2.Q：造成TCP粘包的原因 ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:2:0","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"发送方原因 TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事： 只有上一个分组得到确认，才会发送下一个分组 收集多个小分组，在一个确认到来时一起发送 Nagle算法造成了发送方可能会出现粘包问题 ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:2:1","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"接收方原因 TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。 ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:2:2","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"3.Q：什么时候需要处理粘包现象？ 如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象 如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了 ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:3:0","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"4.Q：如何处理粘包现象？ ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:4:0","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"发送方 对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。 ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:4:1","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"接收方 接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。 ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:4:2","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"应用层 应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。 解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？ 格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。 发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。 ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:4:3","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"5.Q：UDP会不会产生粘包问题呢？ TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。 UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。 举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。 ","date":"2021-03-09","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/:5:0","tags":["wi21-week10","interview prep","网络协议"],"title":"什么是TCP粘包摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%BB%80%E4%B9%88%E6%98%AFtcp%E7%B2%98%E5%8C%85/"},{"categories":["interview cheatsheet"],"content":"用户态和内核态摘抄","date":"2021-03-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/","tags":["wi21-week9","interview prep","OS"],"title":"用户态和内核态","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"},{"categories":["interview cheatsheet"],"content":"用户态和内核态摘抄 我们先来看一张Linux整体架构图。 从图上我们可以看出来通过系统调用将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间）。那内核态到底是什么呢？其实从本质上说就是我们所说的内核，它是一种特殊的软件程序，特殊在哪儿呢？控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行。 用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫系统调用。 ","date":"2021-03-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/:0:0","tags":["wi21-week9","interview prep","OS"],"title":"用户态和内核态","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"},{"categories":["interview cheatsheet"],"content":"系统调用 系统调用时操作系统的最小功能单位。根据不同的应用场景，不同的Linux发行版本提供的系统调用数量也不尽相同，大致在240-350之间。这些系统调用组成了用户态跟内核态交互的基本接口，例如：用户态想要申请一块20K大小的动态内存，就需要brk系统调用，将数据段指针向下偏移，如果用户态多处申请20K动态内存，同时又释放呢？这个内存的管理就变得非常的复杂。 ","date":"2021-03-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/:1:0","tags":["wi21-week9","interview prep","OS"],"title":"用户态和内核态","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"},{"categories":["interview cheatsheet"],"content":"库函数 库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现。它对系统调用进行封装，提供简单的基本接口给用户，这样增强了程序的灵活性，当然对于简单的接口，也可以直接使用系统调用访问资源，例如：open（），write（），read（）等等。库函数根据不同的标准也有不同的版本，例如：glibc库，posix库等。 ","date":"2021-03-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/:2:0","tags":["wi21-week9","interview prep","OS"],"title":"用户态和内核态","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"},{"categories":["interview cheatsheet"],"content":"shell shell顾名思义，就是外壳的意思。就好像把内核包裹起来的外壳。它是一种特殊的应用程序，俗称命令行。为了方便用户和系统交互，一般一个shell对应一个终端，呈现给用户交互窗口。当然shell也是编程的，它有标准的shell语法，符合其语法的文本叫shell脚本。很多人都会用shell脚本实现一些常用的功能，可以提高工作效率。 我们再来看一个更加细化的Linux体系架构图。我们可以总结下：内核控制并且管理硬件资源，包括进程的调度和管理、内存管理、文件系统管理、设备驱动管理、网络管理等等。并且提供应用程序统一的系统调用接口。这种分层的架构，极大的提升了系统的稳定性和扩展性，兼容性。 ","date":"2021-03-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/:3:0","tags":["wi21-week9","interview prep","OS"],"title":"用户态和内核态","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"},{"categories":["interview cheatsheet"],"content":"用户态到内核态怎样切换？ 往往我们的系统的资源是固定的，例如内存2G，CPU固定，磁盘2TB，网络接口固定。所以就需要操作系统对资源进行有效的利用。假设某个应用程序过分的访问这些资源，就会导致整个系统的资源被占用，如果不对这种行为进行限制和区分，就会导致资源访问的冲突。所以，Linux的设计的初衷：给不同的操作给与不同的“权限”。Linux操作系统就将权限等级分为了2个等级，分别就是内核态和用户态。 各位有没有发现，前面讲了这么多内核态和用户态什么不同，其实用一句话就能概括：它们权限不同。用户态的进程能够访问的资源受到了极大的控制，而运行在内核态的进程可以“为所欲为”。一个进程可以运行在用户态也可以运行在内核态，那它们之间肯定存在用户态和内核态切换的过程。打一个比方：C库接口malloc申请动态内存，malloc的实现内部最终还是会调用brk（）或者mmap（）系统调用来分配内存。 ","date":"2021-03-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/:4:0","tags":["wi21-week9","interview prep","OS"],"title":"用户态和内核态","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"},{"categories":["interview cheatsheet"],"content":"那为问题又来了，从用户态到内核态到底怎么进入？只能通过系统调用吗？还有其他方式吗？ 从用户态到内核态切换可以通过三种方式： 系统调用，这个上面已经讲解过了，其实系统调用本身就是中断，但是软件中断，跟硬中断不同。 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。 ","date":"2021-03-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/:5:0","tags":["wi21-week9","interview prep","OS"],"title":"用户态和内核态","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"},{"categories":["interview cheatsheet"],"content":"总结 本片文章，没有非常深入的Linux内核实现，只是从宏观的角度阐述了下。看完上面的文章，也能得出一点结论就是：系统调用真的开销蛮大的。涉及到上下文的切换。在上篇文章中【Linux的直接I/O原理】中有讲述到这些，Linux内核真的是复杂的工程，更多技术细节，需要点滴积累。 ","date":"2021-03-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/:6:0","tags":["wi21-week9","interview prep","OS"],"title":"用户态和内核态","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"},{"categories":["interview cheatsheet"],"content":"简述JVM的内存模型摘抄","date":"2021-03-06","objectID":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","tags":["wi21-week9","interview prep","Java"],"title":"简述JVM的内存模型摘抄","uri":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["interview cheatsheet"],"content":"JVM：简述对JVM内存数据区域的认识摘抄 ","date":"2021-03-06","objectID":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"简述JVM的内存模型摘抄","uri":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["interview cheatsheet"],"content":"程序计数器 (Program Counter Register) 行号指示器，字节码指令的分支、循环、跳转、异常处理、线程恢复(CPU切换)，每条线程都需要一个独立的计数器，线程私有内存互不影响，该区域不会发生内存溢出异常。 ","date":"2021-03-06","objectID":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:0","tags":["wi21-week9","interview prep","Java"],"title":"简述JVM的内存模型摘抄","uri":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["interview cheatsheet"],"content":"虚拟机栈(VM Stack) 虚拟机栈(VM Stack)是线程私有的，声明周期与线程相同，虚拟机栈是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧，即方法运行期间的基础数据结构。 栈帧用于存储：局部变量表、操作数栈、动态链接、方法出口等，每个方法执行中都对应虚拟机栈帧从入栈到处栈的过程。是一种数据结构，是虚拟机中的局部变量表，对应物理层之上的程序数据模型。 局部变量表，是一种程序运行数据模型，存放了编译期可知的各种数据类型例如： Boolean、byte、char、short、int、float、long、double、对象引用类型(对象内存地址变量，指针或句柄)。程序运行时，根据局部变量表分配栈帧空间大小。在运行中，大小是不变的异常类型：stackOverFlowError 线程请求栈深度大于虚拟机允许深度 OutOfMemory 内存空间耗尽无法进行扩展。 ","date":"2021-03-06","objectID":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:0","tags":["wi21-week9","interview prep","Java"],"title":"简述JVM的内存模型摘抄","uri":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["interview cheatsheet"],"content":"本地方法栈(Native Method Stack) 与虚拟机栈类似，虚拟机栈为Java程序服务，本地方法栈支持虚拟机的运行服务，具体实现由虚拟机厂商决定，也会抛出 stackOverFlowError、OutOfMemory异常。 ","date":"2021-03-06","objectID":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:3:0","tags":["wi21-week9","interview prep","Java"],"title":"简述JVM的内存模型摘抄","uri":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["interview cheatsheet"],"content":"堆(Heap) 堆(Heap)是虚拟机管理内存中最大的一部分，被所有线程共享，用于存放对象实例(对象、数组)，物理上不连续的内存空间，由于GC收集器，分代收集，所以划分为： 新生代 Eden、 From SurVivor空间、 To SurVivor空间， allot buffer(分配空间)， 可能会划分出多个线程私有的缓冲区，老年代。 ","date":"2021-03-06","objectID":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:4:0","tags":["wi21-week9","interview prep","Java"],"title":"简述JVM的内存模型摘抄","uri":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["interview cheatsheet"],"content":"方法区(Method Area) 方法区(Method Area)与堆区一样属于线程共享的内存区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码（动态加载OSGI）等数据。理论上属于java虚拟机的一部分，为了区分开来叫做 Non-Heap非堆。 这个区域可以选择不进行垃圾回收，该区域回收目的主要是常量池的回收，及类型的卸载class,内存区不足时会抛出OutOfMemory异常 运行时常量池：方法区的一部分，Class的版本、字段、接口、方法等，及编译期生成的各种字面量、符号引用，编译类加载后存放在该区域。会抛出OutOfMemory异常。 ","date":"2021-03-06","objectID":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:5:0","tags":["wi21-week9","interview prep","Java"],"title":"简述JVM的内存模型摘抄","uri":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["interview cheatsheet"],"content":"直接内存(Direct Memory) 直接内存(Direct Memory)不属于虚拟内存区域，是一种基于通道与缓冲区的IO方式，可以使用本地函数直接分配堆外内存，在堆中存储引用的外部内存地址，通过引用完成对直接引用内存的操作，1.4之后提供的NIO显著提高效率，避免了堆内存与Native内存的来回复制操作，不受虚拟机内存控制，会抛出OUTOfMemory异常。 ","date":"2021-03-06","objectID":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:6:0","tags":["wi21-week9","interview prep","Java"],"title":"简述JVM的内存模型摘抄","uri":"/java_%E7%AE%80%E8%BF%B0jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["interview cheatsheet"],"content":"TCP和UDP区别摘抄","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"TCP和UDP区别摘抄 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:0:0","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"写在前面 首先咱们弄清楚，TCP协议和UDP协议与TCP/IP协议的联系，很多人犯糊涂了， 一直都是说TCP协议与UDP协议的区别，我觉得这是没有从本质上弄清楚网络通信！ TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。 TCP/IP协议集包括应用层,传输层，网络层，网络访问层。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:1:0","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"其中应用层包括: 超文本传输协议（HTTP）:万维网的基本协议； 文件传输（TFTP简单文件传输协议）； 远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令； 网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等； 域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:2:0","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"其次网络层包括: Internet协议（IP）； Internet控制信息协议（ICMP）； 地址解析协议（ARP）； 反向地址解析协议（RARP）。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:3:0","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"网络访问层 网络访问层又称作主机到网络层（host-to-network），网络访问层的功能包括IP地址与物理地址硬件的映射， 以及将IP封装成帧.基于不同硬件类型的网络接口，网络访问层定义了和物理介质的连接. 当然我这里说得不够完善，TCP/IP协议本来就是一门学问，每一个分支都是一个很复杂的流程， 但我相信每位学习软件开发的同学都有必要去仔细了解一番。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:4:0","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"下面着重讲解一下TCP协议和UDP协议的区别 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:5:0","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"TCP: TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂， 只简单的描述下这三次对话的简单过程： 1）主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话； 2）主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 ：“可以，你什么时候发？”，这是第二次对话； 3）主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。 三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:5:1","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"TCP三次握手过程 第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。 第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我 第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：“我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:5:2","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"三次握手的特点 没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:5:3","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"TCP建立连接要进行3次握手，而断开连接要进行4次 第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ； 第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1； 第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ； 第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。 由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:5:4","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"名词解释 1、ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。 2、SYN 同步序列号，TCP建立连接时将这个位置1。 3、FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:5:5","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"TCP的包头结构： 源端口 16位； 目标端口 16位； 序列号 32位； 回应序号 32位； TCP头长度 4位； reserved 6位； 控制代码 6位； 窗口大小 16位； 偏移量 16位； 校验和 16位； 选项 32位(可选)； 这样我们得出了TCP包头的最小长度，为20字节。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:5:6","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"UDP（User Data Protocol，用户数据报协议） UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。 UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。 UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。 UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。 我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。 ping命令是用来探测主机到主机之间是否可通信，如果不能ping到某台主机，表明不能和这台主机建立连接。ping命令是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机。 ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:5:7","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"UDP的包头结构： 源端口 16位 目的端口 16位 长度 16位 校验和 16位 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:5:8","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"小结TCP与UDP的区别： 基于连接与无连接； 对系统资源的要求（TCP较多，UDP少）； UDP程序结构较简单； 流模式与数据报模式 ； TCP保证数据正确性，UDP可能丢包； TCP保证数据顺序，UDP不保证。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/:6:0","tags":["wi21-week9","interview prep","网络协议"],"title":"TCP和UDP区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"HTTP和HTTPS区别摘抄","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_http%E5%92%8Chttps%E5%8C%BA%E5%88%AB/","tags":["wi21-week9","interview prep","网络协议"],"title":"HTTP和HTTPS区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_http%E5%92%8Chttps%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"HTTP和HTTPS区别摘抄 http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。 https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_http%E5%92%8Chttps%E5%8C%BA%E5%88%AB/:0:0","tags":["wi21-week9","interview prep","网络协议"],"title":"HTTP和HTTPS区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_http%E5%92%8Chttps%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"https加密过程 客户端请求服务器获取 证书公钥 客户端(SSL/TLS)解析证书（无效会弹出警告） 生成随机值 用 公钥加密 随机值生成密钥 客户端将 秘钥 发送给服务器 服务端用 私钥 解密 秘钥 得到随机值 将信息和随机值混合在一起 进行对称加密 将加密的内容发送给客户端 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_http%E5%92%8Chttps%E5%8C%BA%E5%88%AB/:1:0","tags":["wi21-week9","interview prep","网络协议"],"title":"HTTP和HTTPS区别摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_http%E5%92%8Chttps%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"PRC和REST摘抄","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_prc%E5%92%8Crest/","tags":["wi21-week9","interview prep","网络协议"],"title":"PRC和REST摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_prc%E5%92%8Crest/"},{"categories":["interview cheatsheet"],"content":"RPC 和 REST 的优缺点、区别、如何选择 接口调用通常包含两个部分，序列化和通信协议： 常见的序列化协议包括json、xml、hession、protobuf、thrift、text、bytes等； 通信协议比较流行的是http、soap、websockect。 首先解释下两种接口调用： Rest：严格的说接口很规范，操作对象即为资源，对资源的四种操作（post、get、put、delete），并且参数都放在URL上。不严格的说Http+json、Http+xml，常见的http api都可以称为Rest接口。 RPC：常说的远程方法调用，就是像调用本地方法一样调用远程方法，通信协议大多采用二进制方式。RPC通常基于TCP实现，常用框架例如dubbo，netty、mina、thrift。 http vs 高性能二进制协议 http相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果是对外开放API，外部的编程语言多种多样，无法拒绝对每种语言的支持。相应的，如果采用http，无疑在实现SDK之前，支持了所有语言，所以现在开源中间件，基本最先支持的几个协议都包含RESTful。 RPC协议性能要高的多，例如Protobuf、Thrift、Kyro等，（如果算上序列化）吞吐量大概能达到http的二倍。响应时间也更为出色。千万不要小看这点性能损耗，公认微服务做的比较好的，例如，netflix、阿里，曾经都传出过为了提升性能而合并服务。如果是交付型的项目，性能更为重要，因为你卖给客户往往靠的就是性能上微弱的优势。 无论是Google、Amazon、netflix（据说很可能转向grpc），还是阿里，实际上内部都是采用性能更高的RPC方式。而对外开放的才是RESTful。 Rest 调用及测试都很方便，RPC就显得有点麻烦，但是RPC的效率是毋庸置疑的。所以建议在多系统之间采用RPC，对外提供服务，Rest是很适合的。 duboo在生产者和消费者两个微服务之间的通信采用的就是RPC，无疑在服务之间的调用RPC更变现的优秀。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_prc%E5%92%8Crest/:0:0","tags":["wi21-week9","interview prep","网络协议"],"title":"PRC和REST摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_prc%E5%92%8Crest/"},{"categories":["interview cheatsheet"],"content":"RPC的好处 RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。 服务化的一个好处就是，不限定服务的提供方使用什么技术选型，能够实现大公司跨团队的技术解耦。 如果没有统一的服务框架—RPC框架，各个团队的服务提供方就需要各自实现一套序列化、反序列化、网络框架、连接池、收发线程、超时处理、状态机等“业务之外”的重复技术劳动，造成整体的低效。所以，统一RPC框架把上述“业务之外”的技术劳动统一处理，是服务化首要解决的问题 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_prc%E5%92%8Crest/:1:0","tags":["wi21-week9","interview prep","网络协议"],"title":"PRC和REST摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_prc%E5%92%8Crest/"},{"categories":["interview cheatsheet"],"content":"几种协议 Socket使用时可以指定协议TCP、UDP等； RIM使用Jrmp协议，Jrmp又是基于TCP/IP； RPC底层使用Socket接口，定义了一套远程调用方法； HTTP是建立在TCP上，不是使用Socket接口，需要连接方主动发数据给服务器，服务器无法主动发数据给客户端。 Web Service提供的服务是基于web容器的，底层使用http协议，类似一个远程的服务提供者，比如天气预报服务，对各地客户端提供天气预报，是一种请求应答的机制，是跨系统跨平台的。就是通过一个servlet，提供服务出去。 hessian是一套用于建立web service的简单的二进制协议，用于替代基于XML的web service，是建立在rpc上的，hessian有一套自己的序列化格式将数据序列化成流，然后通过http协议发送给服务器。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_prc%E5%92%8Crest/:2:0","tags":["wi21-week9","interview prep","网络协议"],"title":"PRC和REST摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_prc%E5%92%8Crest/"},{"categories":["interview cheatsheet"],"content":"三次握手_四次挥手摘抄","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","tags":["wi21-week9","interview prep","网络协议"],"title":"三次握手_四次挥手摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["interview cheatsheet"],"content":"三次握手_四次挥手摘抄 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:0","tags":["wi21-week9","interview prep","网络协议"],"title":"三次握手_四次挥手摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["interview cheatsheet"],"content":"什么是三次握手，四次挥手 TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。 TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。 TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:1:0","tags":["wi21-week9","interview prep","网络协议"],"title":"三次握手_四次挥手摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["interview cheatsheet"],"content":"TCP服务模型 在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。 一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。 当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。 一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。 序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:2:0","tags":["wi21-week9","interview prep","网络协议"],"title":"三次握手_四次挥手摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["interview cheatsheet"],"content":"三次握手 换个易于理解的视角来看为什么要3次握手。 客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。 经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。 每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？ 而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:3:0","tags":["wi21-week9","interview prep","网络协议"],"title":"三次握手_四次挥手摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["interview cheatsheet"],"content":"四次挥手 TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:4:0","tags":["wi21-week9","interview prep","网络协议"],"title":"三次握手_四次挥手摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["interview cheatsheet"],"content":"“三次握手，四次挥手”怎么完成？ 其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。 3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:5:0","tags":["wi21-week9","interview prep","网络协议"],"title":"三次握手_四次挥手摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["interview cheatsheet"],"content":"三次握手如何实现 客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c). 服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。 为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:6:0","tags":["wi21-week9","interview prep","网络协议"],"title":"三次握手_四次挥手摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["interview cheatsheet"],"content":"四次挥手如何实现 客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。 服务端发起自己的FIN段，ACK=K+1, Seq=L -客户端确认。ACK=L+1 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:7:0","tags":["wi21-week9","interview prep","网络协议"],"title":"三次握手_四次挥手摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["interview cheatsheet"],"content":"为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。 ","date":"2021-03-05","objectID":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:8:0","tags":["wi21-week9","interview prep","网络协议"],"title":"三次握手_四次挥手摘抄","uri":"/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["interview cheatsheet"],"content":"调度进程的算法摘抄","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/","tags":["wi21-week9","interview prep","OS"],"title":"调度进程的算法摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"调度进程的算法摘抄 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/:0:0","tags":["wi21-week9","interview prep","OS"],"title":"调度进程的算法摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"First come First served 先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。算法总是把处理机分配给最先进入就绪队列的进程，一个进程一旦分得处理机，便一直执行下去，直到该进程完成或阻塞时，才释放处理机。 缺点：比较有利于长作业，而不利于短作业。 有利于CPU繁忙的作业，而不利于I/O繁忙的作业。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/:1:0","tags":["wi21-week9","interview prep","OS"],"title":"调度进程的算法摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"Shortest First 最短优先调度算法是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。 缺点：长作业的运行得不到保证。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/:2:0","tags":["wi21-week9","interview prep","OS"],"title":"调度进程的算法摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"轮转法(RoundRobin) 将系统中所有的就绪进程按照FCFS原则，排成一个队列。每次调度时将CPU分派给队首进程，让其执行一个时间片。时间片的长度从几个ms到几百ms。在一个时间片结束时，发生时钟中断。调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。 进程可以未使用完一个时间片，就出让CPU(如阻塞)。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/:3:0","tags":["wi21-week9","interview prep","OS"],"title":"调度进程的算法摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"多级反馈队列算法 (Multilevel Feedback Queue Scheduling) 设置多个就绪队列，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长，如逐级加倍。2 新进程进入内存后，先投入队列1的末尾，按FCFS算法调度;若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按FCFS算法调度;如此下去，降低到最后的队列，则按\"时间片轮转\"算法调度直到完成。仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。 进程调度虽然是在系统内部的低级调度，但进程调度的优劣直接影响作业调度的性能。那么，怎样评价进程调度的优劣呢？反映作业调度优劣的周转时间和平均周转时间只在某种程度上反映了进程调度的性能，例如，其执行时间部分中实际上包含有进程等待(包括就绪状态时的等待)时间，而进程等待时间的多少是要依靠进程调度策略和等待事件何时发生等来决定的。因此，进程调度性能的商量是操作系统设计的一个重要指标。我们说进程调度性能的衡量方法可分为定形和定量两种。在定形衡量方面，首先是调度的可靠住。包括一次进程调度是否可能引起数据结构的破坏等。这要求我们对调度时机的选择和保存CPU现场十分谨慎。另外，简洁性也是衡量进程调度的一个重要指标，由于调度程序的执行涉及到多个进程和必须进行上下文切换，如果调度程序过于繁琐和复杂，将会耗去较大的系统开销。这在用户进程调用系统调用较多的情况下，将会造成响应时间大幅度增加。进程调度的定量评价包括CPU的利用率评价、进程在就绪队列中的等待时间与执行时间之比等。实际上由于进程进入就绪队列的随机模型很难确定，而且进程上下文切换等也将影响进程的执行效率，LL而对进程调度进行解析是很困难的。一般情况下，大多利用模拟或测试系统响应时间的方法来评价进程调度的性能。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/:4:0","tags":["wi21-week9","interview prep","OS"],"title":"调度进程的算法摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"进程间有哪些通信方式摘抄","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","tags":["wi21-week9","interview prep","OS"],"title":"进程间有哪些通信方式摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":["interview cheatsheet"],"content":"进程间有哪些通信方式摘抄 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:0:0","tags":["wi21-week9","interview prep","OS"],"title":"进程间有哪些通信方式摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":["interview cheatsheet"],"content":"匿名管道通信 匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 通过匿名管道实现进程间通信的步骤如下： 父进程创建管道，得到两个⽂件描述符指向管道的两端 父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。 父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:0:1","tags":["wi21-week9","interview prep","OS"],"title":"进程间有哪些通信方式摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":["interview cheatsheet"],"content":"高级管道通信 高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:0:2","tags":["wi21-week9","interview prep","OS"],"title":"进程间有哪些通信方式摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":["interview cheatsheet"],"content":"有名管道通信 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:0:3","tags":["wi21-week9","interview prep","OS"],"title":"进程间有哪些通信方式摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":["interview cheatsheet"],"content":"消息队列通信 消息队列(message queue) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:0:4","tags":["wi21-week9","interview prep","OS"],"title":"进程间有哪些通信方式摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":["interview cheatsheet"],"content":"信号量通信 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:0:5","tags":["wi21-week9","interview prep","OS"],"title":"进程间有哪些通信方式摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":["interview cheatsheet"],"content":"信号 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:0:6","tags":["wi21-week9","interview prep","OS"],"title":"进程间有哪些通信方式摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":["interview cheatsheet"],"content":"共享内存通信 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:0:7","tags":["wi21-week9","interview prep","OS"],"title":"进程间有哪些通信方式摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":["interview cheatsheet"],"content":"套接字( socket ) ： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:0:8","tags":["wi21-week9","interview prep","OS"],"title":"进程间有哪些通信方式摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":["interview cheatsheet"],"content":"进程和线程之间的区别摘抄","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["wi21-week9","interview prep","OS"],"title":"进程和线程之间的区别摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"线程和进程的区别摘抄 1. 线程与进程的区别 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["wi21-week9","interview prep","OS"],"title":"进程和线程之间的区别摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"1.1 概述 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["wi21-week9","interview prep","OS"],"title":"进程和线程之间的区别摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"1.2 区别 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 一个程序至少有一个进程，一个进程至少有一个线程 线程的划分尺度小于进程，使得多线程的程序并发跟高 另外线程在执行过程中有独立的内存单元，而多个线程共享内存，极大的提高了程序的运行效率 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["wi21-week9","interview prep","OS"],"title":"进程和线程之间的区别摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"1.3 优缺点: 线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。 2.多进程，多线程 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/:3:0","tags":["wi21-week9","interview prep","OS"],"title":"进程和线程之间的区别摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"2.1 概述: 进程就是一个程序运行的时候被CPU抽象出来的，一个程序运行后被抽象为一个进程，但是线程是从一个进程里面分割出来的，由于CPU处理进程的时候是采用时间片轮转的方式，所以要把一个大个进程给分割成多个线程，例如：网际快车中文件分成100部分 10个线程 文件就被分成了10份来同时下载 1-10 占一个线程 11-20占一个线程,依次类推,线程越多,文件就被分的越多,同时下载 当然速度也就越快 进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。而进程则不同，它是程序在某个数据集上的执行，是一个动态实体。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消，反映了一个程序在一定的数据集上运行的全部动态过程。进程是操作系统分配资源的单位。在Windows下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。线程(Thread)是进程的一个实体，是CPU调度和分派的基本单位。线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程和进程的关系是：线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。 在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。现代的操作系统几乎都是多任务操作系统，能够同时管理多个进程的运行。 多任务带来的好处是明显的，比如你可以边听mp3边上网，与此同时甚至可以将下载的文档打印出来，而这些任务之间丝毫不会相互干扰。那么这里就涉及到并行的问题，俗话说，一心不能二用，这对计算机也一样，原则上一个CPU只能分配给一个进程，以便运行这个进程。我们通常使用的计算机中只有一个CPU，也就是说只有一颗心，要让它一心多用，同时运行多个进程，就必须使用并发技术。实现并发技术相当复杂，最容易理解的是“时间片轮转进程调度算法”，它的思想简单介绍如下：在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。但实际上在任何一个时间内有且仅有一个进程占有CPU。 如果一台计算机有多个CPU，情况就不同了，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，多个进程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。 在Windows中，进行CPU分配是以线程为单位的，一个进程可能由多个线程组成，这时情况更加复杂，但简单地说，有如下关系： 总线程数\u003c= CPU数量：并行运行 总线程数\u003e CPU数量：并发运行 并行运行的效率显然高于并发运行，所以在多CPU的计算机中，多任务的效率比较高。但是，如果在多CPU计算机中只运行一个进程(线程)，就不能发挥多CPU的优势。 多任务操作系统(如Windows)的基本原理是:操作系统将CPU的时间片分配给多个线程,每个线程在操作系统指定的时间片内完成(注意,这里的多个线程是分属于不同进程的).操作系统不断的从一个线程的执行切换到另一个线程的执行,如此往复,宏观上看来,就好像是多个线程在一起执行.由于这多个线程分属于不同的进程,因此在我们看来,就好像是多个进程在同时执行,这样就实现了多任务. ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/:4:0","tags":["wi21-week9","interview prep","OS"],"title":"进程和线程之间的区别摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"2.2 分类 根据进程与线程的设置，操作系统大致分为如下类型： 单进程、单线程，MS-DOS大致是这种操作系统； 多进程、单线程，多数UNIX(及类UNIX的LINUX)是这种操作系统； 多进程、多线程，Win32(Windows NT/2000/XP等)、Solaris 2.x和OS/2都是这种操作系统； 单进程、多线程，VxWorks是这种操作系统。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/:5:0","tags":["wi21-week9","interview prep","OS"],"title":"进程和线程之间的区别摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"2.3 引入线程带来的主要好处： (1) 在进程内创建、终止线程比创建、终止进程要快； (2) 同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。 ","date":"2021-03-05","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/:6:0","tags":["wi21-week9","interview prep","OS"],"title":"进程和线程之间的区别摘抄","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"ACID_SQL日常概念摘抄","date":"2021-03-04","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/","tags":["wi21-week9","interview prep","Database"],"title":"ACID_SQL日常概念摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/"},{"categories":["interview cheatsheet"],"content":"ACID - SQL 摘抄 ","date":"2021-03-04","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/:0:0","tags":["wi21-week9","interview prep","Database"],"title":"ACID_SQL日常概念摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/"},{"categories":["interview cheatsheet"],"content":"事务的 ACID 事务具有四个特征： 原子性（ Atomicity ）- via Undo/Redo log 一致性（ Consistency ） 隔离性（ Isolation ） 持续性（ Durability ） ","date":"2021-03-04","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/:1:0","tags":["wi21-week9","interview prep","Database"],"title":"ACID_SQL日常概念摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/"},{"categories":["interview cheatsheet"],"content":"Mysql的四种隔离级别 SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。 Read Uncommitted（读取未提交内容） 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。 Read Committed（读取提交内容） 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。 Repeatable Read（可重读） 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。 Serializable（可串行化） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如： 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。 在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示： MySQL中的锁 「面试官：」 哦？性能越来越差？为什么会性能越来越差？你能说一说原因吗？ 「我：」 这个得从Mysq的锁说起，在Mysql中的锁可以分为分**「享锁/读锁（Shared Locks）」**、**「排他锁/写锁（Exclusive Locks）」** 、**「间隙锁」**、**「行锁（Record Locks）」**、**「表锁」**。 ","date":"2021-03-04","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/:2:0","tags":["wi21-week9","interview prep","Database"],"title":"ACID_SQL日常概念摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/"},{"categories":["interview cheatsheet"],"content":"可重复读的实现——MultiVersionConcurrencyControl 如图中所示，假如三个事务更新了同一行数据，那么就会有对应的三个数据版本。 实际上版本1、版本2并非实际物理存在的，而图中的U1和U2实际就是undo log，这v1和v2版本是根据当前v3和undo log计算出来的。 SQL会在语句启动时加snapshot ","date":"2021-03-04","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/:3:0","tags":["wi21-week9","interview prep","Database"],"title":"ACID_SQL日常概念摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/"},{"categories":["interview cheatsheet"],"content":"写数据时候的锁问题  假如两个事务执行写操作，又怎么保证并发呢？ 假如事务1和事务2都要执行update操作，事务1先update数据行的时候，先回获取行锁，锁定数据，当事务2要进行update操作的时候，也会取获取该数据行的行锁，但是已经被事务1占有，事务2只能wait。若是事务1长时间没有释放锁，事务2就会出现超时异常 。 那没有索引的条件下呢？没办法快速定位到数据行呢？ 若是没有索引的条件下，就获取所有行，都加上行锁，然后Mysql会再次过滤符合条件的的行并释放锁，只有符合条件的行才会继续持有锁。 ","date":"2021-03-04","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/:4:0","tags":["wi21-week9","interview prep","Database"],"title":"ACID_SQL日常概念摘抄","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_acid_sql%E6%97%A5%E5%B8%B8%E6%A6%82%E5%BF%B5/"},{"categories":["interview cheatsheet"],"content":"CAS的性质和应用摘抄","date":"2021-03-04","objectID":"/java_cas%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%BA%94%E7%94%A8/","tags":["wi21-week9","interview prep","Java"],"title":"CAS的性质和应用摘抄","uri":"/java_cas%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%BA%94%E7%94%A8/"},{"categories":["interview cheatsheet"],"content":"CAS 摘抄 CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。 CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。 ","date":"2021-03-04","objectID":"/java_cas%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%BA%94%E7%94%A8/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"CAS的性质和应用摘抄","uri":"/java_cas%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%BA%94%E7%94%A8/"},{"categories":["interview cheatsheet"],"content":"CAS的缺点： CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。 循环时间长开销很大。 只能保证一个共享变量的原子操作。 ABA问题。 **循环时间长开销很大：**我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。 **只能保证一个共享变量的原子操作：**当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。 什么是ABA问题？ABA问题怎么解决？ CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。 但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗？ 如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。 ","date":"2021-03-04","objectID":"/java_cas%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%BA%94%E7%94%A8/:1:0","tags":["wi21-week9","interview prep","Java"],"title":"CAS的性质和应用摘抄","uri":"/java_cas%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%BA%94%E7%94%A8/"},{"categories":["interview cheatsheet"],"content":"Java中锁的种类摘抄","date":"2021-03-04","objectID":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/","tags":["wi21-week9","interview prep","Java"],"title":"Java中锁的种类摘抄","uri":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/"},{"categories":["interview cheatsheet"],"content":"Java中锁的种类摘抄 ","date":"2021-03-04","objectID":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Java中锁的种类摘抄","uri":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/"},{"categories":["interview cheatsheet"],"content":"公平锁/非公平锁 公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS(AbstractQueuedSynchronizer)的来实现线程调度，所以并没有任何办法使其变成公平锁。 ","date":"2021-03-04","objectID":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/:1:0","tags":["wi21-week9","interview prep","Java"],"title":"Java中锁的种类摘抄","uri":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/"},{"categories":["interview cheatsheet"],"content":"可重入锁 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。 synchronized void setA() throws Exception{ Thread.sleep(1000); setB();} synchronized void setB() throws Exception{ Thread.sleep(1000);} 上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。 ","date":"2021-03-04","objectID":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/:2:0","tags":["wi21-week9","interview prep","Java"],"title":"Java中锁的种类摘抄","uri":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/"},{"categories":["interview cheatsheet"],"content":"独享锁/共享锁 独享锁是指该锁一次只能被一个线程所持有。 共享锁是指该锁可被多个线程所持有。 对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。对于Synchronized而言，当然是独享锁。 ","date":"2021-03-04","objectID":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/:3:0","tags":["wi21-week9","interview prep","Java"],"title":"Java中锁的种类摘抄","uri":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/"},{"categories":["interview cheatsheet"],"content":"互斥锁/读写锁 上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。 互斥锁在Java中的具体实现就是ReentrantLock 读写锁在Java中的具体实现就是ReadWriteLock ","date":"2021-03-04","objectID":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/:4:0","tags":["wi21-week9","interview prep","Java"],"title":"Java中锁的种类摘抄","uri":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/"},{"categories":["interview cheatsheet"],"content":"乐观锁/悲观锁 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。 从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。 ","date":"2021-03-04","objectID":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/:5:0","tags":["wi21-week9","interview prep","Java"],"title":"Java中锁的种类摘抄","uri":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/"},{"categories":["interview cheatsheet"],"content":"分段锁 分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。 我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。 当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。 但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。 分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 ","date":"2021-03-04","objectID":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/:6:0","tags":["wi21-week9","interview prep","Java"],"title":"Java中锁的种类摘抄","uri":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/"},{"categories":["interview cheatsheet"],"content":"偏向锁/轻量级锁/重量级锁 这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。 ","date":"2021-03-04","objectID":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/:7:0","tags":["wi21-week9","interview prep","Java"],"title":"Java中锁的种类摘抄","uri":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/"},{"categories":["interview cheatsheet"],"content":"自旋锁 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。 典型的自旋锁实现的例子，可以参考自旋锁的实现。 ","date":"2021-03-04","objectID":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/:8:0","tags":["wi21-week9","interview prep","Java"],"title":"Java中锁的种类摘抄","uri":"/java_%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/"},{"categories":["interview cheatsheet"],"content":"Equals和==的区别的摘抄","date":"2021-03-04","objectID":"/java_equals%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["wi21-week9","interview prep","Java"],"title":"Equals和==的区别","uri":"/java_equals%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"Equals和==的区别 常常会用equals和==判断两个对象是否相等，那么两者有什么不同呢？主要有以下几点区别 首先区别的是 equals 是方法，但是 == 是操作符 对于基本类型的变量(int, short, long, float, double), 只能用==去比较，一般比较的就是他们的value 对于引用类型的变量来说，例如String类型，就是String继承了Object类， equals是Object类的通用方法，对于该类型对象的比较，默认情况下，也就是没有复写 Object 类的 equals 方法，使用 == 和 equals 比较是一样效果的，都是比较的是它们在内存中的存放地址。 但是对于某些类来说，为了满足自身业务需求，可能存在 equals 方法被复写的情况，这时使用 equals 方法比较需要看具体的情况，例如 String 类，使用 equals 方法会比较它们的值；|| 区别就看有没有重写这个equals method String a = \"Hello World\"; String b = new String(\"Hello World\"); String c = b; //引用传递 System.out.println(\"a == b:\" + a == b); //false System.out.println(\"b == c:\" + b == c); //true System.out.println(\"a == c:\" + a == c); //false System.out.println(\"a.equals(b):\" + a.equals(b)); //true System.out.println(\"b.equals(c):\" + b.equals(c)); //true System.out.println(\"a.equals(c):\" + a.equals(c)); //true /* 最终的打印会是： a == b:false b == c:true a == c:false a.equals(b):true b.equals(c):true a.equals(c):true */ 因为 String b 通过 new 的方式已经开辟了新的堆内存，而 String a = “Hello World” 是存放在常量池里的，两者在 Java 内存里存在放的位置是不同的，所以 a == b 为 false；而 equals 方法当两者存放的内存地址不同时，会比较两者的值，两者的值都是 “Hello World” ，所以 a.equals(b) 为 true。 ","date":"2021-03-04","objectID":"/java_equals%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Equals和==的区别","uri":"/java_equals%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["interview cheatsheet"],"content":"Synchronized和lock的使用分析摘抄","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"Synchronized和lock的使用分析摘抄 1. 说一说自己对于 synchronized 关键字的了解 synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。 因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。 庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 synchronized 关键字。 实现原理： JVM 是通过进入、退出 对象监视器(Monitor) 来实现对方法、同步块的同步的，而对象监视器的本质依赖于底层操作系统的 互斥锁(Mutex Lock) 实现。 具体实现是在编译之后在同步方法调用前加入一个monitor.enter指令，在退出方法和异常处插入monitor.exit的指令。 对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程monitor.exit之后才能尝试继续获取锁。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.2. 说说自己是怎么使用 synchronized 关键字 synchronized 关键字最主要的三种使用方式： ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:1:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 synchronized void method() { //业务代码 } ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:1:1","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"2.修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。所以，如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 synchronized static void method() { //业务代码 } ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:1:2","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"3.修饰代码块 ： 指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进入同步代码前要获得 当前 class 的锁 synchronized(this) { //业务代码 } ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:1:3","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"总结 synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。 synchronized 关键字加到实例方法上是给对象实例上锁。 尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！ public class Singleton { private volatile static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) { //类对象加锁 synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } 另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。 uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-\u003e3-\u003e2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:1:4","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.3. 构造方法可以使用 synchronized 关键字修饰么？ 先说结论：构造方法不能使用 synchronized 关键字修饰。 构造方法本身就属于线程安全的，不存在同步的构造方法一说。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:2:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.3.1. synchronized 同步语句块的情况 public class SynchronizedDemo { public void method() { synchronized (this) { System.out.println(\"synchronized 代码块\"); } } } synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。 在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 ObjectMonitor对象。 另外，wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。 在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。 在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:2:1","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.3.2. synchronized 修饰方法的的情况 public class SynchronizedDemo2 { public synchronized void method() { System.out.println(\"synchronized 方法\"); } } synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:2:2","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.3.3.总结 synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:2:3","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:3:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态 JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:3:1","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.5. 谈谈 synchronized 和 ReentrantLock 的区别 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:4:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.5.1. 两者都是可重入锁 “可重入锁” 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:4:1","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.5.2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:4:2","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"1.5.3.ReentrantLock 比 synchronized 增加了一些高级功能 等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。 可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。 2. volatile 关键字 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:4:3","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"2.1. CPU 缓存模型 为什么要弄一个 CPU 高速缓存呢？ 类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。 我们甚至可以把内存可以看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。 总结：CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。 为了更好地理解，我画了一个简单的 CPU Cache 示意图如下（实际上，现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache）: CPU Cache 的工作方式： 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 内存缓存不一致性的问题 ！比如我执行一个 i++操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:5:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"2.2. 讲一下 JMM(Java 内存模型) 在 JDK1.2 之前，Java 的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。 所以，volatile 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:6:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"2.3. 并发编程的三个重要特性 原子性 : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。synchronized 可以保证代码片段的原子性。 可见性 ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile 关键字可以保证共享变量的可见性。 有序性 ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:7:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"2.4. 说说 synchronized 关键字和 volatile 关键字的区别 synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！ volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定比synchronized关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。 3. ThreadLocal (以后变强了补上) 4. 线程池 (以后变强了补上) 5. Atomic 原子类 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:8:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"5.1. 介绍一下 Atomic 原子类 Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。 所以，所谓原子类说简单点就是具有原子/原子操作特征的类。 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:9:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"5.2. JUC 包中的原子类是哪 4 类? 基本类型 AtomicInteger：整形原子类 AtomicLong：长整型原子类 AtomicBoolean：布尔型原子类 数组类型 AtomicIntegerArray：整形数组原子类 AtomicLongArray：长整形数组原子类 AtomicReferenceArray：引用类型数组原子类 引用类型 AtomicReference：引用类型原子类 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 AtomicMarkableReference ：原子更新带有标记位的引用类型 对象的属性修改类型 AtomicIntegerFieldUpdater：原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 AtomicReferenceFieldUpdater：原子更新引用类型字段的更新器 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:10:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"5.3. 讲讲 AtomicInteger 的使用 AtomicInteger 类常用方法 public final int get() //获取当前的值 public final int getAndSet(int newValue)//获取当前的值，并设置新的值 public final int getAndIncrement()//获取当前的值，并自增 public final int getAndDecrement() //获取当前的值，并自减 public final int getAndAdd(int delta) //获取当前的值，并加上预期的值 boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update） public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。 class AtomicIntegerTest { private AtomicInteger count = new AtomicInteger(); //使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。 public void increment() { count.incrementAndGet(); } public int getCount() { return count.get(); } } ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:11:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理 // setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用） private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。 关于 Atomic 原子类这部分更多内容可以查看我的这篇文章：并发编程面试必备 ","date":"2021-03-04","objectID":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:12:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronized和lock的使用分析摘抄","uri":"/java_synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"String能否被继承","date":"2021-03-04","objectID":"/java_string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/","tags":["wi21-week9","interview prep","Java"],"title":"String能否被继承","uri":"/java_string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/"},{"categories":["interview cheatsheet"],"content":"String能否被继承 根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。 　 final类不能被继承，没有子类，final类中的方法默认是final的。 final方法不能被子类的方法覆盖，但可以被继承。 final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 final不能用于修饰构造方法。 注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。 如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。 使用final方法的原因有二：　 第一、把方法锁定，防止任何继承类修改它的意义和实现。 第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。（这点有待商榷，《Java编程思想》中对于这点存疑） Java中，是否可以继承String类？为什么？ 答案： 不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。 ","date":"2021-03-04","objectID":"/java_string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"String能否被继承","uri":"/java_string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/"},{"categories":["interview cheatsheet"],"content":"Java的垃圾回收机制和回收算法","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"Java的垃圾回收机制和回收算法 ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"对象是否可回收 我们讨论的garbage collection主要是对Java中堆内存的回收，堆里面主要放的就是对象，那么一个对象是否能回收是如何被判断的呢？ 引用计数法 可达性分析 ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:0","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"引用计数法（Reference Counting） 引用计数法（Reference Counting）：给对象中添加一个引用计数器 每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；当计数器为0时对象就是不再被使用的。 这种方式实现简单，但是主流垃圾收集器没有用这种方式管理内存的，因为这种方式很难解决循环依赖问题。 ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:1","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"可达性分析（Reachability Analysis） 可达性分析（Reachability Analysis）：通过一系列的称为 “GC Roots” （GC根）的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到对象不可达）时，则证明此对象是不可用的。 主流的开发语言都是使用的这种方式判断对象是否存活的。如下图所示，object5，object6，object7虽然相互关联，但是GC Roots是不可达的，所以这些对象是可回收的。 Java中可被作为GC Root的对象主要有： 虚拟机栈（栈帧中的本地变量表）中引用对象 方法区中的类静态属性引用的对象 方法区中常量引用的对象 本地方法栈JNI的引用对象 激活状态的线程 正在被用于同步的各种锁对象 Class 由系统类加载器(system class loader)加载的对象，这些类不可以被回收，他们可以以静态字段的方式持有其它对象 more about reference ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:2","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"从对象的生存到死亡 ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:3","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"垃圾回收的算法 ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:0","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"标记一清除（Mark-Sweep）算法 算法讲述 标记阶段： 首先标记处所有需要回收的对象 清除阶段：在标记后统一回收所有被标记的对象 不足： 效率问题，标记和清除的效率都不高 空间问题，清除后会产生大量不连续的内存碎片，无法分配给太大的对象 ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:1","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"“复制”(Copying)算法 算法讲述 “复制”(Copying)算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面。 然后再把己使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 不足： 其缺点是只能用一半内存，浪费资源。 ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:2","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"“复制”(Copying)算法 算法讲述 “复制”(Copying)算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面。 然后再把己使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 大部分虚拟机都是采用复制算法回收新生代的，研究表明，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1：1的比例来划分内存空间。Java虚拟机将新生代内存分为一块较大的Eden空间和两块较小的Survivor（S0和S1）空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。Eden：S0：S1的比例默认是8：1：1，每次新生代中可用内存空间为整个新生代容量的90％（80％+10％)，只有10％的内存会被“浪费”。但是不能保证每次都能回收百分之九十多的对象，当Survivor区内存不够用时需要依赖老年代进行分配担保（Handle Promotion），说白了就是去老年代借内存空间，后面再做介绍。 不足： 其缺点是只能用一半内存，浪费资源。 ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:3","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"标记-整理算法 (Mark-Compact) 在回收老年代时可能回收后还有很多对象存活，复制算法肯定是不合适的，根据老年代的特点，“标记-整理” （Mark-Compact）算法出现了，标记过程仍然与\"标记一清除\"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，如下图所示： ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:4","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"分代收集算法 (Generational Collection) 分代收集（Generational Collection）算法是根据对象生存周期的不同，将内存划分为几块。 Java堆中是分为新生代和老年代，新生代对象朝生夕死选择复制算法。老年代对象存活率高、没有分配担保，必须采用标记-清除或者标记-整理算法进行回收。 ","date":"2021-03-04","objectID":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:5","tags":["wi21-week9","interview prep","Java"],"title":"Java的垃圾回收机制和回收算法摘抄","uri":"/java_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"红黑树与AVL树的区别与联系？","date":"2021-03-04","objectID":"/%E7%AE%97%E6%B3%95_%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/","tags":["wi21-week9","interview prep","算法"],"title":"红黑树和AVL树","uri":"/%E7%AE%97%E6%B3%95_%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"红黑树与AVL树的区别与联系？ ","date":"2021-03-04","objectID":"/%E7%AE%97%E6%B3%95_%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:0:0","tags":["wi21-week9","interview prep","算法"],"title":"红黑树和AVL树","uri":"/%E7%AE%97%E6%B3%95_%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"红黑树总结 节点都是红色或者黑色 根结点是黑色 所有叶子结点都是黑色 每个红色节点必须有两个黑色的叶子结点 从任意一个节点到每个叶子节点的简单路径都包含相同数目的黑色节点 ","date":"2021-03-04","objectID":"/%E7%AE%97%E6%B3%95_%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:1:0","tags":["wi21-week9","interview prep","算法"],"title":"红黑树和AVL树","uri":"/%E7%AE%97%E6%B3%95_%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"AVL树总结 AVL的条件是左右树的高度差不能大于1，并且他的每个子树也都是平衡二叉树 对于平衡二叉树的最小个数， n0=0 ; n1=1 ; nk=n(k-1)+n(k-2)+1 ;(求法可以类比斐波那契！) ","date":"2021-03-04","objectID":"/%E7%AE%97%E6%B3%95_%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:2:0","tags":["wi21-week9","interview prep","算法"],"title":"红黑树和AVL树","uri":"/%E7%AE%97%E6%B3%95_%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"红黑树和AVL树的相同点 就插入节点导致树失衡的情况，AVL和RB-Tree都是最多两次树旋转来实现复衡rebalance，旋转的量级是O(1) 删除节点导致失衡，AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN)，而RB-Tree最多只需要旋转3次实现复衡，只需O(1)，所以说RB-Tree删除节点的rebalance的效率更高，开销更小！ AVL的结构相较于RB-Tree更为平衡，插入和删除引起失衡，如2所述，RB-Tree复衡效率更高；当然，由于AVL高度平衡，因此AVL的Search效率更高啦。 红黑树的查询性能略微逊色于AVL树，因为其比AVL树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的AVL树最多多一次比较，但是，红黑树在插入和删除上优于AVL树，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多 总结：实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。 ","date":"2021-03-04","objectID":"/%E7%AE%97%E6%B3%95_%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:3:0","tags":["wi21-week9","interview prep","算法"],"title":"红黑树和AVL树","uri":"/%E7%AE%97%E6%B3%95_%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"volatile有何作用？volatile有何使用场景？volatile的实现原理是什么？","date":"2021-03-04","objectID":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatile的使用及其原理 ","date":"2021-03-04","objectID":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"摘抄 Volatile的使用及其原理 ","date":"2021-03-04","objectID":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:0","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatile的作用 我们已经提到过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。 ","date":"2021-03-04","objectID":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:1","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatile的使用 防止重排序 为什么要在变量singleton之间加上volatile关键字。 实例化一个对象其实可以分为三个步骤： 1）分配内存空间。 2) 初始化对象。 3) 将内存空间的地址赋值给对应的引用。 但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程： 1）分配内存空间。 2）将内存空间的地址赋值给对应的引用。 3）初始化对象 实现可见性 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 保证原子性 在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同。 Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作，如long、double）。 要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。volatile是无法保证复合操作的原子性。 volatile是无法保证这复合操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。 ","date":"2021-03-04","objectID":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:2","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatile的实现原理 有序性实现 通俗一点说就是如果a happen-before b，则a所做的任何操作对b是可见的。（这一点大家务必记住，因为happen-before这个词容易被误解为是时间的前后）。我们再来看看JSR 133中定义了哪些happen-before规则： 同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。 监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则） 对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则） 线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则） 线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。 如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。 这里我们主要看下第三条：volatile变量的保证有序性的规则。《Java并发编程：核心理论》一文中提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会对volatile变量限制这两种类型的重排序。下面是JMM针对volatile变量所规定的重排序规则表： 可见性的实现 在前文中已经提及过，线程本身并不直接与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。因此要实现volatile变量的可见性，直接从这方面入手即可。对volatile变量的写操作与普通变量的主要区别有两点： 1）修改volatile变量时会强制将修改后的值刷新的主内存中。 2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。通过这两个操作，就可以解决volatile变量的可见性问题。 ","date":"2021-03-04","objectID":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:3","tags":["wi21-week9","interview prep","Java"],"title":"Volatile的使用及其原理","uri":"/java_volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？","date":"2021-03-04","objectID":"/java_concurrenthashmap%E5%92%8Chashmap/","tags":["wi21-week9","interview prep","Java"],"title":"ConcurrentHashMap是如何保证线程安全的","uri":"/java_concurrenthashmap%E5%92%8Chashmap/"},{"categories":["interview cheatsheet"],"content":"ConcurrentHashMap是如何保证线程安全的 ","date":"2021-03-04","objectID":"/java_concurrenthashmap%E5%92%8Chashmap/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"ConcurrentHashMap是如何保证线程安全的","uri":"/java_concurrenthashmap%E5%92%8Chashmap/"},{"categories":["interview cheatsheet"],"content":"参考 ConcurrentHashMap是如何保证线程安全的 HashMap和HashTable的区别 HashTable 是非常高效率的数据结构，但HashMap和HashTable在线程的环境下使用并不合理 HashMap: HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成，具体原因自行百度google或查看源码分析），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。 HashTable:HashTable和HashMap的实现原理几乎一样，差别无非是1.HashTable不允许key和value为null；2.HashTable是线程安全的。但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。 使用ConcurrentHashMap解决全段锁的问题 和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。 原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。 1.7 如何实现呢？这就用到了ConcurrentHashMap中最关键的Segment。 ConcurrentHashMap中维护着一个Segment数组，每个Segment可以看做是一个HashMap。 而Segment本身继承了ReentrantLock，它本身就是一个锁。 在Segment中通过HashEntry数组来维护其内部的hash表。 每个HashEntry就代表了map中的一个K-V，用HashEntry可以组成一个链表结构，通过next字段引用到其下一个元素。 PUT的流程 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。 最后会解除在 1 中所获取当前 Segment 的锁。 GET的流程 只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。 由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。 ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。 1.8 其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。 PUT的流程 根据 key 计算出 hashcode。 判断是否需要进行初始化。 f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。 如果都不满足，则利用 synchronized 锁写入数据。 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。 GET的流程 根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。 如果是红黑树那就按照树的方式获取值，若不满足那就按照链表的方式遍历获取值。 常见关于 HashMap || ConcurrentHashMap 的问题整理 谈谈你理解的 HashMap，讲讲其中的 get put 过程。 1.8 做了什么优化？ 是线程安全的嘛？ 不安全会导致哪些问题？ 如何解决？有没有线程安全的并发容器？ ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？ ","date":"2021-03-04","objectID":"/java_concurrenthashmap%E5%92%8Chashmap/:0:1","tags":["wi21-week9","interview prep","Java"],"title":"ConcurrentHashMap是如何保证线程安全的","uri":"/java_concurrenthashmap%E5%92%8Chashmap/"},{"categories":["interview cheatsheet"],"content":"中国面试八股文背诵链接","date":"2021-03-03","objectID":"/eight_legged_essay/","tags":["wi21-week9","interview prep"],"title":"Eight_legged_essay","uri":"/eight_legged_essay/"},{"categories":["interview cheatsheet"],"content":"文章链接总结 https://blog.csdn.net/huangqili1314/article/details/79448187 https://github.com/Moosphan/Android-Daily-Interview https://osjobs.net/topk/ ","date":"2021-03-03","objectID":"/eight_legged_essay/:0:1","tags":["wi21-week9","interview prep"],"title":"Eight_legged_essay","uri":"/eight_legged_essay/"},{"categories":["Leetcode Problem"],"content":"New BFS to solve Leetcode 786 - K-th Smallest Prime Fraction ","date":"2021-02-22","objectID":"/leetcode_786/:0:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 786 You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k. For every i and j where 0 \u003c= i \u003c j \u003c arr.length, we consider the fraction arr[i] / arr[j]. Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j]. ","date":"2021-02-22","objectID":"/leetcode_786/:1:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Example Test Cases Leetcode 786 Example1: Input: arr = [1,2,3,5], k = 3 Output: [2,5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3. The third fraction is 2/5. ","date":"2021-02-22","objectID":"/leetcode_786/:2:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 786 // BFS vector\u003cint\u003e global_arr; class Node { public: int denominator; int numerator; double val; Node(int de, int nu){ this -\u003e denominator = de; this -\u003e numerator = nu; this -\u003e val = (double)global_arr[nu] / global_arr[de]; } }; class Compare { public: bool operator() (Node\u0026 n1, Node\u0026 n2) { return n1.val \u003e n2.val; } }; class Solution { public: vector\u003cint\u003e kthSmallestPrimeFraction(vector\u003cint\u003e\u0026 arr, int k) { global_arr.clear(); for(int i : arr){ global_arr.push_back(i); } std::priority_queue\u003cNode, std::vector\u003cNode\u003e, Compare\u003e pq; for(int i = 1; i \u003c arr.size(); i++){ Node cur(i, 0); pq.push(cur); } for(int i = 0; i \u003c k - 1; ++i){ // cout \u003c\u003c pq.top().numerator \u003c\u003c \" \" \u003c\u003c pq.top().denominator \u003c\u003c endl; Node cur = pq.top(); pq.pop(); if(cur.numerator == cur.denominator - 1){ continue; } else{ cur.numerator += 1; cur.val = (double)global_arr[cur.numerator] / global_arr[cur.denominator]; pq.push(cur); } } // cout \u003c\u003c global_arr[pq.top().numerator] \u003c\u003c \" \" \u003c\u003c global_arr[pq.top().denominator]; vector\u003cint\u003e ret{global_arr[pq.top().numerator], global_arr[pq.top().denominator]}; return ret; } }; ","date":"2021-02-22","objectID":"/leetcode_786/:3:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Leetcode 786 Using Heap O(k * log(n)) solution ","date":"2021-02-22","objectID":"/leetcode_786/:4:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"New BFS to solve Leetcode 1091 - Shortest Path in Binary Matrix. ","date":"2021-02-10","objectID":"/leetcode_1091/:0:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 1091 In an N by N square grid, each cell is either empty (0) or blocked (1). A clear path from top-left to bottom-right has length k if and only if it is composed of cells C_1, C_2, …, C_k such that: Adjacent cells C_i and C_{i+1} are connected 8-directionally (ie., they are different and share an edge or corner) C_1 is at location (0, 0) (ie. has value grid[0][0]) C_k is at location (N-1, N-1) (ie. has value grid[N-1][N-1]) If C_i is located at (r, c), then grid[r][c] is empty (ie. grid[r][c] == 0). Return the length of the shortest such clear path from top-left to bottom-right. If such a path does not exist, return -1. ","date":"2021-02-10","objectID":"/leetcode_1091/:1:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Example Test Cases Leetcode 1091 Example1: Input: [[0,1],[1,0]] Output: 2 ","date":"2021-02-10","objectID":"/leetcode_1091/:2:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 1091 // BFS class Solution { public: int shortestPathBinaryMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { if(grid[0][0] == 1){ return -1; } deque\u003cint\u003e q; set\u003cint\u003e seen; int m = grid.size(), n = grid[0].size(); int step = 1; seen.insert(0); q.push_back(0); while(q.size()){ int width = q.size(); for(int i = 0; i \u003c width; ++i){ int p = q.front(); q.pop_front(); int r = p / n, c = p % n; if(r == m - 1 \u0026\u0026 c == n -1){ return step; } for(int j = -1; j \u003c= 1; j++){ for(int k = -1; k \u003c= 1; k++){ if(j == 0 \u0026\u0026 k == 0){ continue; } else{ int nr = r + j, nc = c + k; int np = nr * n + nc; if(nr \u003e= 0 \u0026\u0026 nr \u003c m \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n \u0026\u0026 seen.find(np) == seen.end() \u0026\u0026 grid[nr][nc] == 0){ seen.insert(np); q.push_back(np); } } } } } step += 1; } return -1; } }; ","date":"2021-02-10","objectID":"/leetcode_1091/:3:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Leetcode 1091 Dimension Reduction + 8 direction loop O(m*n) solution ","date":"2021-02-10","objectID":"/leetcode_1091/:4:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 284 - Peeking Iterator","date":"2021-02-08","objectID":"/leetcode_284/","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"New Idea to solve Leetcode 284 - Peeking Iterator. ","date":"2021-02-08","objectID":"/leetcode_284/:0:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 284 Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next(). ","date":"2021-02-08","objectID":"/leetcode_284/:1:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Example Test Cases Leetcode 284 Example1: Assume that the iterator is initialized to the beginning of the list: [1,2,3]. Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2. You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false. ","date":"2021-02-08","objectID":"/leetcode_284/:2:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 284 # Below is the interface for Iterator, which is already defined for you. # # class Iterator: # def __init__(self, nums): # \"\"\" # Initializes an iterator object to the beginning of a list. # :type nums: List[int] # \"\"\" # # def hasNext(self): # \"\"\" # Returns true if the iteration has more elements. # :rtype: bool # \"\"\" # # def next(self): # \"\"\" # Returns the next element in the iteration. # :rtype: int # \"\"\" class PeekingIterator: def __init__(self, iterator): \"\"\" Initialize your data structure here. :type iterator: Iterator \"\"\" self.isCalled = False self.ret = 0 self.it = iterator def peek(self): \"\"\" Returns the next element in the iteration without advancing the iterator. :rtype: int \"\"\" if(self.isCalled): return self.ret else: self.ret = self.it.next() self.isCalled = True return self.ret def next(self): \"\"\" :rtype: int \"\"\" if(self.isCalled): self.isCalled = False return self.ret else: return self.it.next() def hasNext(self): \"\"\" :rtype: bool \"\"\" return self.it.hasNext() or self.isCalled # Your PeekingIterator object will be instantiated and called as such: # iter = PeekingIterator(Iterator(nums)) # while iter.hasNext(): # val = iter.peek() # Get the next element but not advance the iterator. # iter.next() # Should return the same value as [val]. ","date":"2021-02-08","objectID":"/leetcode_284/:3:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Leetcode 284 peek will differ at most one with the actual iterator, therefore use a boolean to remember diff or not O(1) solution ","date":"2021-02-08","objectID":"/leetcode_284/:4:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 638 - Shopping Offers","date":"2021-02-04","objectID":"/leetcode_638/","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Use Dynamic Programming to solve Leetcode 638 - Shopping Offers. ","date":"2021-02-04","objectID":"/leetcode_638/:0:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 638 In LeetCode Store, there are some kinds of items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. You are given the each item’s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer. You could use any of special offers as many times as you want. ","date":"2021-02-04","objectID":"/leetcode_638/:1:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 638 Example1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B. You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A. Example2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation: The price of A is $2, and $3 for B, $4 for C. You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. You cannot add more items, though only $9 for 2A ,2B and 1C. ","date":"2021-02-04","objectID":"/leetcode_638/:2:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 638 class Solution { public: unordered_map\u003cstring, int\u003e cache; vector\u003cint\u003e _p; vector\u003cvector\u003cint\u003e\u003e _s; string vector2str(vector\u003cint\u003e\u0026 num){ vector\u003cchar\u003e v; for(int i = 0; i \u003c num.size(); ++i){ v.push_back('a' + num[i]); } string s(v.begin(), v.end()); return s; } int helper(vector\u003cint\u003e\u0026 state){ string s = vector2str(state); if(cache.find(s) != cache.end()){ return cache[s]; } int ret = 0; for(int i = 0; i \u003c state.size(); ++i){ ret += (state[i] * _p[i]); } for(int i = 0; i \u003c _s.size(); ++i){ vector\u003cint\u003e ns = state; int j; for(j = 0; j \u003c _s[i].size() - 1; j++){ ns[j] -= _s[i][j]; if(ns[j] \u003c 0){ break; } } if(j == _s[i].size() - 1){ ret = min(ret, _s[i][j] + helper(ns)); } } return cache[vector2str(state)] = ret; } int shoppingOffers(vector\u003cint\u003e\u0026 price, vector\u003cvector\u003cint\u003e\u003e\u0026 special, vector\u003cint\u003e\u0026 needs) { _p = price; _s = special; vector\u003cint\u003e startState(needs.size(), 0); cache[vector2str(startState)] = 0; return helper(needs); } }; ","date":"2021-02-04","objectID":"/leetcode_638/:3:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Recursion + Memorization Top Down, and We can simply try to buy all the items by the original price as the starting ret to compare later. ","date":"2021-02-04","objectID":"/leetcode_638/:4:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["cpp cheatsheet"],"content":"cpp handy reference","date":"2021-02-03","objectID":"/cpp_handy_1/","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"cpp cheatsheet 1. ","date":"2021-02-03","objectID":"/cpp_handy_1/:0:0","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"Binary Search related library function lower_bound upper_bound binary_search (beginIterator, endInterator, val) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:0","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"lower_bound lower_bound(beginIterator, endInterator, target) Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val. greater than or equal to the target if no elements satisfies the condition, simply return the endInterator(out of bound) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:1","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"upper_bound upper_bound(beginIterator, endInterator, target)s Returns an iterator pointing to the first element in the range [first,last) which compares greater than val. strictly greater than the target if no element satisfies the condition, simply return the endInterator(out of bound) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:2","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"binary_search binary_search(beginIterator, endInterator, val) true if exist, false otherwise. int main() { vector\u003cint\u003e _v; for(int i = 0; i \u003c 5; i++){ _v.push_back(i); _v.push_back(i + 3); } // must be sorted in increasing order // note that rbegin, rend, reverse order is not allowed sort(_v.begin(), _v.end()); cout \u003c\u003c lower_bound(_v.begin(), _v.end(), 4) - _v.begin() \u003c\u003c '\\n'; return 0; } ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:3","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["codeforce"],"content":"codeforce 1","date":"2021-02-03","objectID":"/codeforce_1/","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"codeforce 1475D, share my solution for these this codeforce problem. ","date":"2021-02-03","objectID":"/codeforce_1/:0:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Description D. Cleaning the Phone ","date":"2021-02-03","objectID":"/codeforce_1/:1:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Introduction D. Cleaning the Phone Polycarp often uses his smartphone. He has already installed 𝑛 applications on it. Application with number 𝑖 takes up 𝑎𝑖 units of memory. Polycarp wants to free at least 𝑚 units of memory (by removing some applications). Of course, some applications are more important to Polycarp than others. He came up with the following scoring system — he assigned an integer 𝑏𝑖 to each application: 𝑏𝑖=1 — regular application; 𝑏𝑖=2 — important application. According to this rating system, his phone has 𝑏1+𝑏2+…+𝑏𝑛 convenience points. Polycarp believes that if he removes applications with numbers 𝑖1,𝑖2,…,𝑖𝑘, then he will free 𝑎𝑖1+𝑎𝑖2+…+𝑎𝑖𝑘 units of memory and lose 𝑏𝑖1+𝑏𝑖2+…+𝑏𝑖𝑘 convenience points. For example, if 𝑛=5, 𝑚=7, 𝑎=[5,3,2,1,4], 𝑏=[2,1,1,2,1], then Polycarp can uninstall the following application sets (not all options are listed below): applications with numbers 1,4 and 5. In this case, it will free 𝑎1+𝑎4+𝑎5=10 units of memory and lose 𝑏1+𝑏4+𝑏5=5 convenience points; applications with numbers 1 and 3. In this case, it will free 𝑎1+𝑎3=7 units of memory and lose 𝑏1+𝑏3=3 convenience points. applications with numbers 2 and 5. In this case, it will free 𝑎2+𝑎5=7 memory units and lose 𝑏2+𝑏5=2 convenience points. Help Polycarp, choose a set of applications, such that if removing them will free at least 𝑚 units of memory and lose the minimum number of convenience points, or indicate that such a set does not exist. ","date":"2021-02-03","objectID":"/codeforce_1/:1:1","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Input D. Cleaning the Phone Input The first line contains one integer 𝑡 (1≤𝑡≤104) — the number of test cases. Then 𝑡 test cases follow. The first line of each test case contains two integers 𝑛 and 𝑚 (1≤𝑛≤2⋅105, 1≤𝑚≤109) — the number of applications on Polycarp’s phone and the number of memory units to be freed. The second line of each test case contains 𝑛 integers 𝑎1,𝑎2,…,𝑎𝑛 (1≤𝑎𝑖≤109) — the number of memory units used by applications. The third line of each test case contains 𝑛 integers 𝑏1,𝑏2,…,𝑏𝑛 (1≤𝑏𝑖≤2) — the convenience points of each application. It is guaranteed that the sum of 𝑛 over all test cases does not exceed 2⋅105. ","date":"2021-02-03","objectID":"/codeforce_1/:1:2","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Output D. Cleaning the Phone Output For each test case, output on a separate line: -1, if there is no set of applications, removing which will free at least 𝑚 units of memory; the minimum number of convenience points that Polycarp will lose if such a set exists. ","date":"2021-02-03","objectID":"/codeforce_1/:1:3","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Example Input \u0026 Output D. Cleaning the Phone 5 5 7 5 3 2 1 4 2 1 1 2 1 1 3 2 1 5 10 2 3 2 3 2 1 2 1 2 1 4 10 5 1 3 4 1 2 1 2 4 5 3 2 1 2 2 1 2 1 2 -1 6 4 3 ","date":"2021-02-03","objectID":"/codeforce_1/:1:4","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Example Explanation D. Cleaning the Phone In the first test case, it is optimal to remove applications with numbers 2 and 5, freeing 7 units of memory. 𝑏2+𝑏5=2. In the second test case, by removing the only application, Polycarp will be able to clear only 2 of memory units out of the 3 needed. In the third test case, it is optimal to remove applications with numbers 1, 2, 3 and 4, freeing 10 units of memory. 𝑏1+𝑏2+𝑏3+𝑏4=6. In the fourth test case, it is optimal to remove applications with numbers 1, 3 and 4, freeing 12 units of memory. 𝑏1+𝑏3+𝑏4=4. In the fifth test case, it is optimal to remove applications with numbers 1 and 2, freeing 5 units of memory. 𝑏1+𝑏2=3. ","date":"2021-02-03","objectID":"/codeforce_1/:1:5","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Solution D. Cleaning the Phone #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long int main() { int n; cin \u003e\u003e n; vector\u003cll\u003e ret; for(int i = 0; i \u003c n; i+=1){ int m, needed; cin \u003e\u003e m \u003e\u003e needed; vector\u003cll\u003e a(m + 1, 0); vector\u003cint\u003e b(m + 1, 0); vector\u003cll\u003e _1; vector\u003cll\u003e _2; ll sum = 0; for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e a[i]; sum += a[i]; } for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e b[i]; if(b[i] == 1){ _1.push_back(a[i]); } else{ _2.push_back(a[i]); } } if(sum\u003cneeded) { ret.push_back(-1); continue; } sort(_1.rbegin(), _1.rend()); sort(_2.rbegin(), _2.rend()); vector\u003cll\u003e _pre2; _pre2.push_back(0); for(int i = 0; i \u003c _2.size(); i++){ _pre2.push_back(_pre2[i] + _2[i]); } int len=_pre2.size(); sum=0; ll ans=1e18; int cur=lower_bound(_pre2.begin(),_pre2.end(),needed)-_pre2.begin(); // if cur == len, it means that no element inside the _pre2 \u003e= needed if(cur!=len) { ans=cur*2; } for(int i = 0; i \u003c _1.size(); i++){ sum += _1[i]; if(needed \u003c 0){ ans = min(ans, 1ll + i + 1); break; } int point = needed - sum; int cur=lower_bound(_pre2.begin(),_pre2.end(),point)-_pre2.begin(); if(cur != len){ ans = min(ans, i + 1 + 2 * 1ll * cur); } } ret.push_back(ans); } for(int i : ret){ cout \u003c\u003c i \u003c\u003c '\\n'; } return 0; } ","date":"2021-02-03","objectID":"/codeforce_1/:2:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Remark D. Cleaning the Phone Implicit Binary Search Idea is computing the prefix sum and set the pointer at application with importance 1, and then do binary search to find the lower_bound for the application with importance of 2 ","date":"2021-02-03","objectID":"/codeforce_1/:3:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["OJ Problem"],"content":"OJ 5","date":"2021-02-02","objectID":"/coding_practice_5/","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"OJ Practice 5, share my solutions for these three OJ problems during the UCSD ICPC Selection Contest. ","date":"2021-02-02","objectID":"/coding_practice_5/:0:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Methodic Multiplication #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; int countS(string s){ int ret = 0; for(int i = 0; i \u003c s.length(); i++){ if(s[i] == 'S'){ ret += 1; } } return ret; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; if(s1 == \"0\"){ cout \u003c\u003c \"0\"; } else if(s2 == \"0\"){ cout \u003c\u003c \"0\"; } else{ int count1 = countS(s1), count2 = countS(s2); int ret = count1 * count2; int idx = 0; vector\u003cchar\u003e resultS; for(int i = 0; i \u003c ret; i++){ resultS.push_back('S'); resultS.push_back('('); } resultS.push_back('0'); for(int i = 0; i \u003c ret; i++){ resultS.push_back(')'); } string retS(resultS.begin(), resultS.end()); cout \u003c\u003c retS; } return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:1:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Dams in Distress #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; /* 4 75 0 100 50 1 49 10 1 50 0 3 50 48 */ int main() { ll n, t; cin \u003e\u003e n \u003e\u003e t; unordered_map\u003cint, vector\u003cint\u003e\u003e graph; vector\u003cll\u003e needed(n + 1, 0); vector\u003cll\u003e require(n + 1, 0); vector\u003cll\u003e current(n + 1, 0); // the first one need t amount of water needed[0] = t; require[0] = t; for(int i = 1; i \u003c= n; i++){ int d, c, u; cin \u003e\u003e d \u003e\u003e c \u003e\u003e u; // from parent to child if(graph.find(d) == graph.end()){ graph[d] = vector\u003cint\u003e {i}; } else{ graph[d].push_back(i); } require[i] = c; current[i] = u; } deque\u003cint\u003e q; q.push_back(0); while(q.size()){ int p = q.front(); q.pop_front(); if(graph.find(p) != graph.end()){ for(int np : graph[p]){ ll cur_n = max(needed[p], require[np]) - current[np]; needed[np] = cur_n; q.push_back(np); } } } ll min_amount = LLONG_MAX; for(int i = 0; i \u003c= n; i++){ min_amount = min(min_amount, needed[i]); } cout \u003c\u003c min_amount; /*TLE solution ll min_amount = LLONG_MAX; for(int i = 0; i \u003c= n; i++){ ll needed = require[i] - current[i]; ll carry = require[i]; int idx = i; while(idx != 0){ int next_level = parent[idx]; if(carry + current[next_level] \u003c require[next_level]){ break; } else{ carry = carry + current[next_level]; idx = parent[idx]; } } if(idx == 0){ min_amount = min(min_amount, needed); } } cout \u003c\u003c min_amount; */ return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:2:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Array of Discord #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; /* 3 2020 2020 2020 */ /* 4 1 42 4711 9876 */ ll magicSmall(ll num){ if(num \u003c 10){ return 0; } else{ string s = to_string(num); // if the first digit is not 1, we change it to 1, and return it. if(s[0] != '1'){ s[0] = '1'; return stoll(s); } // if the first digit is 1, we find the first non-zero, and change it to zero else{ for(int i = 1; i \u003c s.length(); i+=1){ if(s[i] != '0'){ s[i] = '0'; return stoll(s); } } } } return num; } ll magicBig(ll num){ if(num \u003c 10){ return 9; } else{ string s = to_string(num); if(s[0] != '9'){ s[0] = '9'; return stoll(s); } // find the first non-9, and change it to 9 else{ for(int i = 1; i \u003c s.length(); i+=1){ if(s[i] != '9'){ s[i] = '9'; return stoll(s); } } } } return num; } int main() { int n; cin \u003e\u003e n; vector\u003cll\u003e nums(n, 0); for(int i = 0; i \u003c n; i++){ ll num; cin \u003e\u003e num; nums[i] = num; } // either make left bigger, scan from the left to right, if the changed number is biggr than the one on the right, // we can return the array of numers for(int i = 0; i \u003c nums.size() - 1; i++){ if(magicBig(nums[i]) \u003e nums[i+1]){ nums[i] = magicBig(nums[i]); for(ll i : nums){ cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } } // or make right smaller, scan from right to left, if the changed number is smaller than the one on the left, // return the array of numbers for(int i = nums.size() - 1; i \u003e= 1; i--){ if(magicSmall(nums[i]) \u003c nums[i - 1]){ nums[i] = magicSmall(nums[i]); for(ll i : nums){ cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } } cout \u003c\u003c \"impossible\"; return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:3:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Remark to Array of Discord Just use stoll, do not mess up with the overflow ","date":"2021-02-02","objectID":"/coding_practice_5/:4:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"OJ 4","date":"2021-01-29","objectID":"/coding_practice_4/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"OJ Practice 4, share my solutions for these three OJ problems. ","date":"2021-01-29","objectID":"/coding_practice_4/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"[NCPC 2011 Problem A: Car Trouble] #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* 6 0 1 1 1 1 2 2 3 1 3 0 3 0 4 2 5 0 5 1 4 */ set\u003cint\u003e solve(unordered_map\u003cint, vector\u003cint\u003e\u003e\u0026 graph){ set\u003cint\u003e seen; if (graph.find(0) == graph.end()){ return seen; } deque\u003cint\u003e q; q.push_back(0); while(q.size()){ int cur = q.front(); q.pop_front(); seen.insert(cur); for(int j = 0; j \u003c graph[cur].size(); ++j){ if(seen.find(graph[cur][j]) == seen.end()){ seen.insert(graph[cur][j]); q.push_back(graph[cur][j]); } } } return seen; } int main() { int m, f, t, n; unordered_map\u003cint, vector\u003cint\u003e\u003e graph; unordered_map\u003cint, vector\u003cint\u003e\u003e reverse_graph; vector\u003cint\u003e all_road; cin \u003e\u003e m; for(int i = 0; i \u003c m; i++){ cin \u003e\u003e f; cin \u003e\u003e n; all_road.push_back(f); if(reverse_graph.find(t) == reverse_graph.end()){ reverse_graph[f] = vector\u003cint\u003e{}; } if(graph.find(f) == graph.end()){ graph[f] = vector\u003cint\u003e{}; } for(int j = 0; j \u003c n; j++){ cin \u003e\u003e t; graph[f].push_back(t); reverse_graph[t].push_back(f); } } // UNREACHABLE vector\u003cint\u003e unreachable; // TRAPPED vector\u003cint\u003e trapped; set\u003cint\u003e not_trapped = solve(reverse_graph); set\u003cint\u003e not_unreachable = solve(graph); for(int i : all_road){ if(not_unreachable.find(i) == not_unreachable.end()){ unreachable.push_back(i); } if(not_trapped.find(i) == not_trapped.end()){ trapped.push_back(i); } } if(trapped.size() == 0 \u0026\u0026 unreachable.size() == 0){ cout \u003c\u003c \"NO PROBLEMS\"; return 0; } else{ for(int i : trapped){ cout \u003c\u003c \"TRAPPED \" \u003c\u003c i \u003c\u003c endl; } for(int i : unreachable){ cout \u003c\u003c \"UNREACHABLE \" \u003c\u003c i \u003c\u003c endl; } } return 0; } ","date":"2021-01-29","objectID":"/coding_practice_4/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"NCPC 2015​ Goblin Garden Guards #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* 5 0 0 100 0 0 100 100 100 50 50 1 0 0 50 */ int main() { int n, m; cin \u003e\u003e n; int x, y, r; vector\u003ctuple\u003cint, int\u003e\u003e g; vector\u003ctuple\u003cint, int, int\u003e\u003e s; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e x \u003e\u003e y; g.push_back(make_tuple(x, y)); } cin \u003e\u003e m; for (int i = 0; i \u003c m; i++) { cin \u003e\u003e x \u003e\u003e y \u003e\u003e r; s.push_back(make_tuple(x, y, r)); } vector\u003cvector\u003cbool\u003e\u003e board(10000 + 5, vector\u003cbool\u003e(10000 + 5, true)); /*TLE SOLUTION int ret = 0; for(int i = 0; i \u003c n; i++){ bool flag = true; int g_x = get\u003c0\u003e(g[i]), g_y = get\u003c1\u003e(g[i]); for(int j = 0; j \u003c m; j++){ int s_x = get\u003c0\u003e(s[j]), s_y = get\u003c1\u003e(s[j]), s_r = get\u003c2\u003e(s[j]); if( pow((g_x - s_x), 2) + pow((g_y - s_y), 2) \u003c= pow(s_r, 2)){ flag = false; break; } } if(flag){ ret += 1; } } */ for (int j = 0; j \u003c m; j++) { int s_x = get\u003c0\u003e(s[j]), s_y = get\u003c1\u003e(s[j]), s_r = get\u003c2\u003e(s[j]); for (int dx = -s_r; dx \u003c= s_r; dx++) { for (int dy = -s_r; dy \u003c= s_r; dy++) { if (s_x + dx \u003e= 0 \u0026\u0026 s_x + dx \u003c 10000 + 5 \u0026\u0026 s_y + dy \u003e= 0 \u0026\u0026 s_y + dy \u003c 10000 + 5) { // double check the name of variables is correct if (dx * dx + dy * dy \u003c= s_r * s_r) { board[s_x + dx][s_y + dy] = false; } } } } } int ret = 0; for (int i = 0; i \u003c n; i++) { int g_x = get\u003c0\u003e(g[i]), g_y = get\u003c1\u003e(g[i]); if (board[g_x][g_y]) { ret += 1; } } cout \u003c\u003c ret; return 0; } ","date":"2021-01-29","objectID":"/coding_practice_4/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"OJ 2","date":"2021-01-28","objectID":"/coding_practice_3/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"OJ Practice 3, share my solution for these three OJ problems. ","date":"2021-01-28","objectID":"/coding_practice_3/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"NCPC 2011 Problem B: Mega Inversion using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { const int N = 2 * 1e5 + 10; const int origin = 1e5 + 10; public: vector\u003cll\u003e countLarger(vector\u003cint\u003e\u0026 nums){ vector\u003cll\u003e segtree(2 * N + 2, 0); reverse(nums.begin(), nums.end()); for(int i = 0; i \u003c nums.size(); ++i){ nums[i] = -nums[i]; } vector\u003cll\u003e result; for (int i = nums.size()-1; i \u003e= 0; i--) { result.push_back(rangeQuery(segtree, origin + nums[i])); update(segtree, origin + nums[i]); } return result; } vector\u003cll\u003e countSmaller(vector\u003cint\u003e\u0026 nums) { vector\u003cll\u003e segtree(2*N + 2, 0); vector\u003cll\u003e result; for (int i = nums.size()-1; i \u003e= 0; i--) { result.push_back(rangeQuery(segtree, origin + nums[i])); update(segtree, origin + nums[i]); } // need to reverse result reverse(result.begin(), result.end()); return result; } void update(vector\u003cll\u003e\u0026 segtree, int index) { for (index += N; index \u003e 0; index \u003e\u003e= 1) { segtree[index]++; } } ll rangeQuery(vector\u003cll\u003e\u0026 segtree, int entry) { int left = 0; int right = entry; ll result = 0; for (left += N, right += N; left \u003c right; left \u003e\u003e= 1, right \u003e\u003e= 1) { if(entry == 6 + origin){ } if (left%2 == 1) result += segtree[left++]; if (right%2 == 1) result += segtree[--right]; } return result; } }; int main() { Solution s; int n; cin \u003e\u003e n; vector\u003cint\u003e nums; int t; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e t; nums.push_back(t); } vector\u003cll\u003e smaller = s.countSmaller(nums); vector\u003cll\u003e larger = s.countLarger(nums); ll ret = 0; for(int i = 0; i \u003c larger.size(); i ++){ ret += (larger[i] * smaller[i]); } cout \u003c\u003c ret; return 0; } ","date":"2021-01-28","objectID":"/coding_practice_3/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"OJ 2","date":"2021-01-27","objectID":"/coding_practice_2/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"OJ Practice 2, share my solution for these three OJ problems. ","date":"2021-01-27","objectID":"/coding_practice_2/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"Robots on a grid using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { public: int test() { } }; int solve(vector\u003cvector\u003cint\u003e\u003e\u0026 board){ int m = board.size(), n = board[0].size(); int step = 0; vector\u003cint\u003e dirs = {0, 1, 0, -1, 0}; set\u003cint\u003e seen; deque\u003cint\u003e q; q.push_back(0); seen.insert(0); while(q.size()){ int size = q.size(); for(int i = 0; i \u003c size; i++){ int p = q.front(); q.pop_front(); int r = p / n, c = p % n; if(r == m - 1 \u0026\u0026 c == n - 1){ return step; } else{ for(int i = 0; i \u003c 4; i++){ int nr = r + (board[r][c] * dirs[i]), nc = c + (board[r][c] * dirs[i + 1]); if(nr \u003e= 0 \u0026\u0026 nr \u003c m \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n){ int np = nr * n + nc; if(seen.find(np) == seen.end()){ seen.insert(np); q.push_back(np); } } } } } step += 1; } return -1; } int main() { int m, n; cin \u003e\u003e m \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e board(m, vector\u003cint\u003e(n, 0)); char c; for(int i = 0; i \u003c m; i++){ for(int j = 0; j \u003c n; j++){ cin \u003e\u003e c; board[i][j] = c - '0'; } } // for(int i = 0; i \u003c m; i++){ // for(int j = 0; j \u003c n; j++){ // cout \u003c\u003c board[i][j]; // } // } cout \u003c\u003c solve(board); return 0; } ","date":"2021-01-27","objectID":"/coding_practice_2/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"SERGRID - Grid using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int solve(vector\u003cvector\u003cunsigned int\u003e\u003e\u0026 board){ int n = board.size() - 1; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= n; j++){ if(board[i][j] == -1){ board[i][j] = 0; } else{ board[i][j] = (board[i][j - 1] % 0x7FFFFFFF + board[i - 1][j] % 0x7FFFFFFF) % 0x7FFFFFFF; } } } return board[n][n]; } bool isValid(vector\u003cvector\u003cint\u003e\u003e\u0026 board){ int n = board.size(); // invalid board if(board[0][0] == -1){ return false; } vector\u003cint\u003e dirs = {0, 1, 0, -1, 0}; // r * n + c set\u003cint\u003e seen; deque\u003cint\u003e d; seen.insert(0); d.push_back(0); while(d.size()){ int p = d.front(); d.pop_front(); int r = p / n, c = p % n; if(r == n - 1 \u0026\u0026 c == n - 1){ return true; } else{ for(int i = 0; i \u003c dirs.size() - 1; i++){ int nr = r + dirs[i], nc = c + dirs[i + 1]; if(nr \u003e= 0 \u0026\u0026 nr \u003c n \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n \u0026\u0026 board[nr][nc] == 0){ int np = nr * n + nc; if(seen.find(np) == seen.end()){ seen.insert(np); d.push_back(np); } } } } } return false; } int main() { int n; char c; cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e validBoard(n, vector\u003cint\u003e(n, 0)); vector\u003cvector\u003cunsigned int\u003e\u003e board(n + 1, vector\u003cunsigned int\u003e(n + 1, 0)); for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c n; j++){ cin \u003e\u003e c; if(c == '.'){ board[i + 1][j + 1] = 0; validBoard[i][j] = 0; } else{ board[i + 1][j + 1] = -1; validBoard[i][j] = -1; } } } if(isValid(validBoard) == false){ cout \u003c\u003c \"INCONCEIVABLE\"; return 0; } board[0][1] = 1; int ret = solve(board); if (ret != 0){ cout \u003c\u003c ret; } else{ if(isValid(validBoard) == false){ cout \u003c\u003c \"INCONCEIVABLE\"; return 0; } else{ cout \u003c\u003c \"THE GAME IS A LIE\"; } } return 0; } ","date":"2021-01-27","objectID":"/coding_practice_2/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"OJ 1","date":"2021-01-26","objectID":"/coding_practice_1/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"OJ Practice 1, share my solution for these three OJ problems. ","date":"2021-01-26","objectID":"/coding_practice_1/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2013 Problem E: Timebomb #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int main() { string s; vector\u003cstring\u003e l; for(int i = 0; i \u003c 5; ++i){ std::getline (std::cin,s); l.push_back(s); } // for(string s : l){ // cout \u003c\u003c s \u003c\u003c endl; // } vector\u003cstring\u003e num_str = {\"75557\", \"11111\", \"71747\", \"71717\", \"55711\", \"74717\", \"74757\", \"71111\", \"75757\", \"75717\"}; unordered_map\u003cstring, int\u003e ref; for(int i = 0; i \u003c num_str.size(); ++i){ ref[num_str[i]] = i; } long long num = 0; vector\u003cint\u003e number; for(int i = 0; i \u003c l[0].size(); i += 4){ string s = \"\"; for(int k = 0; k \u003c 5; k++){ int counter = 0; for(int j = 0; j \u003c 3; j++){ if(l[k][i + j] == '*'){ counter += pow(2, 2- j); } } s += to_string(counter); } if(ref.find(s) == ref.end()){ cout \u003c\u003c \"BOOM!!\"; return 0; } else{ number.push_back(ref[s]); } } for(int i = 0; i \u003c number.size(); i += 1){ num = num * 10 + number[i]; } if(num % 6 == 0){ cout \u003c\u003c \"BEER!!\"; return 0; } else{ cout \u003c\u003c \"BOOM!!\"; return 0; } return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2015 Problem C: Cryptographer’s Conundrum #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int solve(string s){ int counter = 0; vector\u003cchar\u003e ref = {'P', 'E', 'R'}; for(int i = 0; i \u003c s.length(); ++i){ if(s[i] != ref[i % 3]){ counter += 1; } } return counter; } int main() { string s; cin \u003e\u003e s; cout \u003c\u003c solve(s) \u003c\u003c \"\\n\"; return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2011 Problem E: ls #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* *.* 4 main.c a.out readme yacc */ bool solve(string s, string p){ int s_len = s.length(), p_len = p.length(); vector\u003cvector\u003cbool\u003e\u003e dp(s_len + 1, vector\u003cbool\u003e(p_len + 1, false)); dp[0][0] = true; for(int j = 1; j \u003c= p_len; ++j){ if(p[j - 1] == '*'){ dp[0][j] = dp[0][j-1]; } else{ dp[0][j] = false; } } for(int i = 1; i \u003c= s_len; ++i){ for(int j = 1; j \u003c= p_len; ++j){ if(p[j-1] == '*'){ dp[i][j] = dp[i-1][j] || dp[i][j-1] || dp[i-1][j-1]; } else{ if(p[j-1] == s[i-1]){ dp[i][j] = dp[i-1][j-1]; } else{ dp[i][j] = false; } } } } return dp[s_len][p_len]; } int main() { int n = 0; string p, s; cin \u003e\u003e p; cin \u003e\u003e n; vector\u003cstring\u003e l; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e s; if(solve(s, p)){ l.push_back(s); } } for(string s : l){ cout \u003c\u003c s \u003c\u003c endl; } return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:3:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 315 - Count of Smaller Numbers After Self","date":"2021-01-23","objectID":"/leetcode_315/","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Use Segment Tree to solve Leetcode 315 - Count of Smaller Numbers After Self. ","date":"2021-01-23","objectID":"/leetcode_315/:0:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 315 You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. ","date":"2021-01-23","objectID":"/leetcode_315/:1:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 315 Example1: Input: nums = [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. ","date":"2021-01-23","objectID":"/leetcode_315/:2:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 315 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class SegmentTreeNode(object): # range[min, max] def __init__(self, min, max): self.min = min self.max = max self.mid = (self.max - self.min) // 2 + self.min self.count = 0 self.right = None self.left = None class SegmentTree(object): def __init__(self, root): self.root = root def update(self, value): self.updateHelper(value, self.root) def updateHelper(self, value, node): if node == None: return if value \u003c node.min or value \u003e node.max: return node.count += 1 if node.min == node.max: return working_mid = node.mid if node.left == None: node.left = SegmentTreeNode(node.min, working_mid) if node.right == None: node.right = SegmentTreeNode(working_mid + 1, node.max) if value \u003e working_mid: self.updateHelper(value, node.right) else: self.updateHelper(value, node.left) def queryRange(self, value): return self.queryRangeHelper(value, self.root) def queryRangeHelper(self, value, node): if node == None: return 0 if value \u003e= node.max: return node.count working_mid = node.mid if value \u003c= working_mid: return self.queryRangeHelper(value, node.left) else: return self.queryRangeHelper(value, node.right) + self.queryRangeHelper(value, node.left) class Solution: def countSmaller(self, nums: List[int]) -\u003e List[int]: if len(nums) == 0: return [] ret = [] root = SegmentTreeNode(min(nums), max(nums)) tree = SegmentTree(root) for i in range(len(nums) - 1, -1, -1): ret.append(tree.queryRange(nums[i] - 1)) tree.update(nums[i]) return ret[::-1] ","date":"2021-01-23","objectID":"/leetcode_315/:3:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Remark For each TreeNode, count refers to how many number between [max, min] O(nlogk) solution, where k is the max difference ","date":"2021-01-23","objectID":"/leetcode_315/:4:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 732 - My Calendar III","date":"2021-01-21","objectID":"/leetcode_732/","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Use Segment Tree to solve Leetcode 732 - My Calendar III. ","date":"2021-01-21","objectID":"/leetcode_732/:0:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 732 A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.) You are given some events [start, end), after each given event, return an integer k representing the maximum k-booking between all the previous events. Implement the MyCalendarThree class: MyCalendarThree() Initializes the object. int book(int start, int end) Returns an integer k representing the largest integer such that there exists a k-booking in the calendar. ","date":"2021-01-21","objectID":"/leetcode_732/:1:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 732 Example1: Input [\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"] [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]] Output [null, 1, 1, 2, 3, 3, 3] Explanation MyCalendarThree myCalendarThree = new MyCalendarThree(); myCalendarThree.book(10, 20); // return 1, The first event can be booked and is disjoint, so the maximum k-booking is a 1-booking. myCalendarThree.book(50, 60); // return 1, The second event can be booked and is disjoint, so the maximum k-booking is a 1-booking. myCalendarThree.book(10, 40); // return 2, The third event [10, 40) intersects the first event, and the maximum k-booking is a 2-booking. myCalendarThree.book(5, 15); // return 3, The remaining events cause the maximum K-booking to be only a 3-booking. myCalendarThree.book(5, 10); // return 3 myCalendarThree.book(25, 55); // return 3 ","date":"2021-01-21","objectID":"/leetcode_732/:2:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 732 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class TreeNode: # segment tree with lazy propogation for range max query # half-open interval [lo, hi) def __init__(self, low, high, val=0, lazy=0, leftChild = None, rightChild = None): self.low = low self.high = high # range max self.val = val # bookings to add to the children the next time children get visited self.lazy = lazy self.leftChild = leftChild self.rightChild = rightChild class MyCalendarThree: MIN_BOUND = 0 MAX_BOUND = 1e9 + 1 def __init__(self): self.root = TreeNode(MyCalendarThree.MIN_BOUND, MyCalendarThree.MAX_BOUND) def book(self, start: int, end: int) -\u003e int: # update the segment from top to down, using lazy propogation self.update(self.root, start, end) return self.root.val def update(self, node, start, end): # we found the match, increment the value and lazy to be propogated if node.low == start and node.high == end: node.val += 1 node.lazy += 1 return mid = (node.high - node.low) // 2 + node.low # top-down building the segment tree if node.leftChild == None and node.rightChild == None: node.leftChild = TreeNode(node.low, mid, node.lazy, node.lazy) node.rightChild = TreeNode(mid, node.high, node.lazy, node.lazy) else: node.leftChild.val += node.lazy node.leftChild.lazy += node.lazy node.rightChild.val += node.lazy node.rightChild.lazy += node.lazy node.lazy = 0 # after building the children, we are able to traverse downwards if mid \u003e= end: self.update(node.leftChild, start, end) elif mid \u003c= start: self.update(node.rightChild, start, end) else: self.update(node.leftChild, start, mid) self.update(node.rightChild, mid, end) node.val = max(node.leftChild.val, node.rightChild.val) return # credit to https://leetcode.com/problems/my-calendar-iii/discuss/1023625/Python-Segment-Tree-with-Lazy-Propagation ","date":"2021-01-21","objectID":"/leetcode_732/:3:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Remark We treat this problem as segment tree(interval tree) where each book would trigger the building of tree To build the tree top-down, we utilize Lazy Propagation ","date":"2021-01-21","objectID":"/leetcode_732/:4:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Data Structure"],"content":"This article reviews segment tree.","date":"2021-01-20","objectID":"/segment_tree/","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"This article reviews Segment Tree. Segment Tree ","date":"2021-01-20","objectID":"/segment_tree/:0:0","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Semantics This balanced tree data structure stores the aggregation of certain property within certain range. build(start, end, vals): construct the segment tree update(index, value): update the A[index] to value rangeQuery(start, end) query the aggregation of certain range [start, end] ","date":"2021-01-20","objectID":"/segment_tree/:0:1","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Implementation class SegmentTreeNode: def __init__(self, start, end, val, left=None, right=None): self.start = start self.end = end self.mid = start + (end - start) // 2 self.val = val self.left = left self.right = right class SegmentTree: def __init__(self, nums): self.nums = nums if self.nums: self.root = self.build(0, len(nums) - 1, nums) def build(self, start, end, nums): if start == end: return SegmentTreeNode(start, end, nums[start]) mid = (end - start) // 2 + start leftNode = self.build(start, mid, nums) rightNode = self.build(mid + 1, end, nums) return SegmentTreeNode(start, end, leftNode.val + rightNode.val, leftNode, rightNode) def update(self, index, value): self.updateHelper(self.root, index, value) def updateHelper(self, node, index, value): if node.start == index and node.end == index: node.val = value return if index \u003c= node.mid: self.updateHelper(node.left, index, value) else: self.updateHelper(node.right, index, value) node.val = node.left.val + node.right.val def queryRange(self, start, end): return self.queryRangeHelper(self.root, start, end) def queryRangeHelper(self, node, start, end): if node.start == start and node.end == end: return node.val elif end \u003c= node.mid: return self.queryRangeHelper(node.left, start, end) elif start \u003e node.mid: return self.queryRangeHelper(node.right, start, end) else: return self.queryRangeHelper(node.left, start, node.mid) + self.queryRangeHelper(node.right, node.mid + 1, end) ","date":"2021-01-20","objectID":"/segment_tree/:0:2","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Efficienty Analysis buil -\u003e O(n) update -\u003e O(log n) rangeQuery -\u003e ~ O(log n) ","date":"2021-01-20","objectID":"/segment_tree/:0:3","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Remarks query range with mutable arrays ","date":"2021-01-20","objectID":"/segment_tree/:0:4","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 947 - Most Stones Removed with Same Row or Column","date":"2021-01-17","objectID":"/leetcode_947/","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 947 - Most Stones Removed with Same Row or Column. ","date":"2021-01-17","objectID":"/leetcode_947/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 947 On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed. ","date":"2021-01-17","objectID":"/leetcode_947/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 947 Example1: Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5 Explanation: One way to remove 5 stones is as follows: 1. Remove stone [2,2] because it shares the same row as [2,1]. 2. Remove stone [2,1] because it shares the same column as [0,1]. 3. Remove stone [1,2] because it shares the same row as [1,0]. 4. Remove stone [1,0] because it shares the same column as [0,0]. 5. Remove stone [0,1] because it shares the same row as [0,0]. Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane. Example2: Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3 Explanation: One way to make 3 moves is as follows: 1. Remove stone [2,2] because it shares the same row as [2,0]. 2. Remove stone [2,0] because it shares the same column as [0,0]. 3. Remove stone [0,2] because it shares the same row as [0,0]. Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane. Example3: Input: stones = [[0,0]] Output: 0 Explanation: [0,0] is the only stone on the plane, so you cannot remove it. ","date":"2021-01-17","objectID":"/leetcode_947/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 947 from collections import deque, Counter class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): # already inserted if p in self.parents: return True else: self.num_sets += 1 self.parents[p] = p self.sizes[p] = 1 return False def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, [p, q]) if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sets -= 1 class Solution: def removeStones(self, stones: List[List[int]]) -\u003e int: row_stone = {} # row -\u003e stone location col_stone = {} # col -\u003e stone location for stone in stones: i, j = stone[0], stone[1] location = (i, j) if i in row_stone: row_stone[i].add(location) else: row_stone[i] = set() row_stone[i].add(location) if j in col_stone: col_stone[j].add(location) else: col_stone[j] = set() col_stone[j].add(location) disjoint_set = UnionFind() all_stone = set() for stone in stones: i, j = stone[0], stone[1] location = (i, j) if disjoint_set.contains(location): continue else: # do a little bfs here to find all the connected component my_queue = deque() my_queue.append(location) row_seen = set() col_seen = set() while(len(my_queue) != 0): cur_loc = my_queue.pop() disjoint_set.insert(cur_loc) disjoint_set.union(cur_loc, location) all_stone.add(cur_loc) i, j = cur_loc[0], cur_loc[1] if i not in row_seen: row_seen.add(i) for stone in row_stone[i]: my_queue.append(stone) if j not in col_seen: col_seen.add(j) for stone in col_stone[j]: my_queue.append(stone) leader_size = {} for stone in all_stone: real_leader = disjoint_set.find(stone) if real_leader not in leader_size: leader_size[real_leader] = disjoint_set.sizes[real_leader] else: leader_size[real_leader] = disjoint_set.sizes[real_leader] ret = 0 for leader in leader_size: ret += (leader_size[leader] - 1) return ret ","date":"2021-01-17","objectID":"/leetcode_947/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Remark We define connected-compoent as the componet of stones share same col/row with at least 1 other stone in the graph STEP1, remember all the locations of the stones STEP2, create disjoint set that stores all connected-component together STEP3, for each connected component, we greedily pick the size-1 of that component ","date":"2021-01-17","objectID":"/leetcode_947/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 827 - Making A Large Island","date":"2021-01-15","objectID":"/leetcode_827/","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 827 - Making A Large Island. ","date":"2021-01-15","objectID":"/leetcode_827/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). ","date":"2021-01-15","objectID":"/leetcode_827/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3. Example2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4. ","date":"2021-01-15","objectID":"/leetcode_827/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t : self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sets -= 1 return False class Solution: def largestIsland(self, grid: List[List[int]]) -\u003e int: dirs = [0, 1, 0, -1, 0] # Step1, union 1's and find 0's disjoint_set = UnionFind() all_zeros = set() ret = 0 m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == 1: base = i * n + j disjoint_set.insert(base) for t in range(len(dirs) - 1): if i + dirs[t] \u003e= 0 and i + dirs[t] \u003c m and j + dirs[t + 1] \u003e= 0 and j + dirs[t + 1] \u003c n and grid[i + dirs[t]][j + dirs[t + 1]] == 1: neighbour = (i + dirs[t]) * n + (j + dirs[t + 1]) disjoint_set.insert(neighbour) disjoint_set.union(neighbour, base) else: all_zeros.add((i, j)) # edge case, all 1's, just return the size of the grid if len(all_zeros) == 0: return m * n # for all possible zeros, try to flip it for zero in all_zeros: i, j = zero[0], zero[1] leader_size = {} for t in range(len(dirs) - 1): if i + dirs[t] \u003e= 0 and i + dirs[t] \u003c m and j + dirs[t + 1] \u003e= 0 and j + dirs[t + 1] \u003c n and grid[i + dirs[t]][j + dirs[t + 1]] == 1: leader = disjoint_set.find((i + dirs[t]) * n + (j + dirs[t + 1])) if leader in leader_size: continue else: leader_size[leader] = disjoint_set.sizes[leader] ret = max(ret, sum(list(leader_size.values())) + 1) return ret ","date":"2021-01-15","objectID":"/leetcode_827/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Naive Approach tries all the zeros, and recompute the connected component Union Find helps us to find the size of the connected component without computing the graph again, O(n*m) ","date":"2021-01-15","objectID":"/leetcode_827/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 1722 - Minimize Hamming Distance After Swap Operations.","date":"2021-01-14","objectID":"/leetcode_1722/","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 1722 - Minimize Hamming Distance After Swap Operations. ","date":"2021-01-14","objectID":"/leetcode_1722/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 1722 You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 \u003c= i \u003c= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source. ","date":"2021-01-14","objectID":"/leetcode_1722/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 1722 Example1: Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output: 1 Explanation: source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example1: Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output: 2 Explanation: There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. ","date":"2021-01-14","objectID":"/leetcode_1722/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 1722 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sizes = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.num_sizes += 1 self.parents[p] = p self.sizes[p] = 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # this means that we found a redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sizes -= 1 return False class Solution: def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(source) for i in range(n): disjoint_set.insert(i) # build the union graph # in each group, the numbers can be placed anywhere for edge in allowedSwaps: disjoint_set.union(edge[0], edge[1]) # hashmap, # group leader -\u003e set[indices in that group] leader_member = {} print(disjoint_set.parents) for member, leader in disjoint_set.parents.items(): # This is the real leader for this member leader = disjoint_set.find(member) if leader in leader_member: leader_member[leader].add(member) else: leader_member[leader] = set([member]) print(leader_member) ret = 0 # for all the members, try to figure out the distance for members in leader_member.values(): source_numbers = [source[i] for i in members] target_numbers = [target[i] for i in members] ret += sum((Counter(source_numbers) - Counter(target_numbers)).values()) return ret ","date":"2021-01-14","objectID":"/leetcode_1722/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To solve this problem, we need to observe that if (0, 1) is exchangeable and (0, 2) is exchangeable, then any pair in (0, 1, 2) can be exchangeble. The remaining problem is how to detect connected components in the graph -\u003e use Union Find. Counter, the subclass of dictionary, supports many great opeartions. ","date":"2021-01-14","objectID":"/leetcode_1722/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Entertainment"],"content":"牛振华三部曲","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/","tags":["moview review","chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Entertainment"],"content":"Stand Up, Don’t Bend Over 1993 Back to Back, Face to Face 1994 Signal Left, Turn Right 1995 闲来无事，写一篇影评，记录一下2021的开始。 偶然的机会看了一部反应中国政治生态的小短篇，之后有评论里提到一部《背靠背，脸对脸》的电影，简单的名字往往藏着不平凡的故事，youtube和b站搜了一下，有版权，随即看了一下。 这三部电影都由牛振华主演，黄建新执导，用幽默的手法反应当时90年代的都市百态、经济生活，政治生态。《背靠背，脸对脸》《站直喽，别趴下》《红灯停绿灯行》合称“都市百态三部曲”。 《背靠背，脸对脸》讲述的是一个文物馆的王双立副馆长，绞尽脑汁想上位一把手的故事。通过王副馆长在其转正过程中一波三折的经历，反应了现代化社会中复杂微妙的人际关系以及错综复杂的政治生态。牛振华饰演的王副馆长是一位有能力，懂得政治手段的领导，难能可贵的是，牛的表演展现了人的复杂性，矛盾性。和当今社会网络中许多线性的人设不同，现实中人的生活是对立统一的，在学会使用矛盾的观点看身边的问题之同时，辩证地理解人性的复杂。以及句兆杰饰演的会计在多次倒戈中体现出“没有永远的盟友，只有永远的利益”这点现实，值得回味。 《站直喽，别趴下》描述了“流氓”张永武（牛振华饰）通过养鱼发家致富，通过自己的努力和敢于拼搏的精神成为那栋楼里最有排面的人。原先看不起张永武的刘干部（达式常饰）和由高作家（冯巩饰）最终在利益的趋势下，像所谓的物质生活低头，改变了对张永武原先“地痞流氓”的标签。电影反应了当时社会“有钱没文化，有文化没钱”，张永武的渔业公司发展壮大后，要求高作家搬出这栋楼，在张永武一系列盘外招的干扰下，高作家连夜搬家，最后高作家蹲在地上收拾东西的镜头，抛出文化人是否向物质低头这个命题。 《红灯停绿灯行》讲述的是学车时发生的一系列故事，　记者苟宇佳（牛振华 饰）、下岗女工程芬（丁嘉丽 饰）、个体户绿豆（王劲松 饰）、大款老差（句号 饰）是驾校1025班的成员，在退伍军人侯教练手下练习。随着时间的推移，大家渐渐摸清彼此的习性。记者小苟八面玲珑，处事圆滑，一心想把学车费报销，结果天不遂人愿；待业女工阿芬被下海的丈夫发来离婚的传票，一人带着女儿，老实度日；早年丧父，母亲瘫痪在床的绿豆沾染上了毒品，白天学车，半夜偷井盖，却是个孝顺儿子；大款老差则是个打着盹儿都能赚上十万、八万的有钱人，不把驾校规定放在眼里；侯教练的教练身份为他带来了免费的香烟和赚回扣的机会，也因此引火烧身，弄得家里鸡犬不宁。 这段驾校生活，波折连连，却都一一化险为夷，5人间的暗战明战也都随着考试的顺利通关而结束。这段驾校的经历牵扯出了5个人的悲喜，除了学到了驾驶规则，似乎更学到了生存法则。credit to 豆瓣 总的来说，这三篇电影风格类似，大致都描述了错综复杂的人际关系和现代化社会的一些拜金主义苗头。人是复杂的而非线性的，生活是矛与盾的结合。网络很容易让人陷入一种单纯的思考状态，认为所有事物都是线性的，贴标签似的理解事情，这样显然很简单，也很容易，但写到这里，也想到百度CEO李彦宏曾对推荐算法有一番说辞，大致描述说推荐算法使得网民失去多样性，在计算了相似度以后，用户喜欢XX就一直推送XX，如果平台一直都是“投其所好”,把用户困在一个圈子里，丧失了获得多样性的机会，也使得很多用户失去了辩证思维。江泽民总书记曾说过 “对现实社会中的问题，我们要进行理性的思考。因为我们看到的现象，其中有的是真相，有的却是假象。只有把感性上升到理性，才能深化认识，才能把握事物的本质。”这几部电影在消遣时间的同时，也敲响了辩证思考的警钟，但从头论，本人也是被推荐算法带进这些电影的，不免有些讽刺。 希望以后思考问题能够深入本质，别太狭隘。 ","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/:0:0","tags":["moview review","chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 547 - Number of Provinces.","date":"2021-01-13","objectID":"/leetcode_547/","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 547 - Number of Provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]] Output: 2 Example2: Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]] Output: 3 ","date":"2021-01-13","objectID":"/leetcode_547/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 class Solution: def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(isConnected) for i in range(n): disjoint_set.insert(i) for i in range(n): for j in range(n): if isConnected[i][j]: disjoint_set.union(i, j) return disjoint_set.num_sets ","date":"2021-01-13","objectID":"/leetcode_547/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To find the connected component in undirected graph, Union Find(Disjoint Set) is the handy data structure to use. ","date":"2021-01-13","objectID":"/leetcode_547/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Data Structure"],"content":"This article reviews union find.","date":"2021-01-12","objectID":"/union_find/","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"This article reviews Union Find(Disjoint Set). Union Find | Disjoint Set ","date":"2021-01-12","objectID":"/union_find/:0:0","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Semantics This data structure stores the collection of disjoint(non-overlapping) sets(groups). find(p): find the leader of group that contains p union(p, q): merge two groups ","date":"2021-01-12","objectID":"/union_find/:0:1","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Implementation class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 ","date":"2021-01-12","objectID":"/union_find/:0:2","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Efficienty Analysis O(n) in memory, O(1) for union and look up in amortized analysis ","date":"2021-01-12","objectID":"/union_find/:0:3","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Remarks Check whether two elements belong to the same group. To find connected components in graph (usually undirected) Speed up implementation of kruskal’s algorithm ","date":"2021-01-12","objectID":"/union_find/:0:4","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":null,"content":" Welcome to  Haihao Sun’s field! Self Introduction Haihao SunTravelling \" Travelling Hi there! I am Haihao Sun, and my hobbies come and go. I enjoy travelling, playing Go, playing pokemon, and developing(AKA coding). I was born in Nanjing, and I currently live in San Diego . Skills JavaScript SQL C/C++  Java Python Extended Links Linkedin Blog Version I Github ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Page","uri":"/about/"}]