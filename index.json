[{"categories":["cpp cheatsheet"],"content":"cpp handy reference","date":"2021-02-03","objectID":"/cpp_handy_1/","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"cpp cheatsheet 1. ","date":"2021-02-03","objectID":"/cpp_handy_1/:0:0","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"Binary Search related library function lower_bound upper_bound binary_search (beginIterator, endInterator, val) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:0","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"lower_bound lower_bound(beginIterator, endInterator, target) Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val. greater than or equal to the target if no elements satisfies the condition, simply return the endInterator(out of bound) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:1","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"upper_bound upper_bound(beginIterator, endInterator, target)s Returns an iterator pointing to the first element in the range [first,last) which compares greater than val. strictly greater than the target if no element satisfies the condition, simply return the endInterator(out of bound) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:2","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"binary_search binary_search(beginIterator, endInterator, val) true if exist, false otherwise. int main() { vector\u003cint\u003e _v; for(int i = 0; i \u003c 5; i++){ _v.push_back(i); _v.push_back(i + 3); } // must be sorted in increasing order // note that rbegin, rend, reverse order is not allowed sort(_v.begin(), _v.end()); cout \u003c\u003c lower_bound(_v.begin(), _v.end(), 4) - _v.begin() \u003c\u003c '\\n'; return 0; } ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:3","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["codeforce"],"content":"codeforce 1","date":"2021-02-03","objectID":"/codeforce_1/","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"codeforce 1475D, share my solution for these this codeforce problem. ","date":"2021-02-03","objectID":"/codeforce_1/:0:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Description D. Cleaning the Phone ","date":"2021-02-03","objectID":"/codeforce_1/:1:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Introduction D. Cleaning the Phone Polycarp often uses his smartphone. He has already installed ùëõ applications on it. Application with number ùëñ takes up ùëéùëñ units of memory. Polycarp wants to free at least ùëö units of memory (by removing some applications). Of course, some applications are more important to Polycarp than others. He came up with the following scoring system ‚Äî he assigned an integer ùëèùëñ to each application: ùëèùëñ=1 ‚Äî regular application; ùëèùëñ=2 ‚Äî important application. According to this rating system, his phone has ùëè1+ùëè2+‚Ä¶+ùëèùëõ convenience points. Polycarp believes that if he removes applications with numbers ùëñ1,ùëñ2,‚Ä¶,ùëñùëò, then he will free ùëéùëñ1+ùëéùëñ2+‚Ä¶+ùëéùëñùëò units of memory and lose ùëèùëñ1+ùëèùëñ2+‚Ä¶+ùëèùëñùëò convenience points. For example, if ùëõ=5, ùëö=7, ùëé=[5,3,2,1,4], ùëè=[2,1,1,2,1], then Polycarp can uninstall the following application sets (not all options are listed below): applications with numbers 1,4 and 5. In this case, it will free ùëé1+ùëé4+ùëé5=10 units of memory and lose ùëè1+ùëè4+ùëè5=5 convenience points; applications with numbers 1 and 3. In this case, it will free ùëé1+ùëé3=7 units of memory and lose ùëè1+ùëè3=3 convenience points. applications with numbers 2 and 5. In this case, it will free ùëé2+ùëé5=7 memory units and lose ùëè2+ùëè5=2 convenience points. Help Polycarp, choose a set of applications, such that if removing them will free at least ùëö units of memory and lose the minimum number of convenience points, or indicate that such a set does not exist. ","date":"2021-02-03","objectID":"/codeforce_1/:1:1","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Input D. Cleaning the Phone Input The first line contains one integer ùë° (1‚â§ùë°‚â§104) ‚Äî the number of test cases. Then ùë° test cases follow. The first line of each test case contains two integers ùëõ and ùëö (1‚â§ùëõ‚â§2‚ãÖ105, 1‚â§ùëö‚â§109) ‚Äî the number of applications on Polycarp‚Äôs phone and the number of memory units to be freed. The second line of each test case contains ùëõ integers ùëé1,ùëé2,‚Ä¶,ùëéùëõ (1‚â§ùëéùëñ‚â§109) ‚Äî the number of memory units used by applications. The third line of each test case contains ùëõ integers ùëè1,ùëè2,‚Ä¶,ùëèùëõ (1‚â§ùëèùëñ‚â§2) ‚Äî the convenience points of each application. It is guaranteed that the sum of ùëõ over all test cases does not exceed 2‚ãÖ105. ","date":"2021-02-03","objectID":"/codeforce_1/:1:2","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Output D. Cleaning the Phone Output For each test case, output on a separate line: -1, if there is no set of applications, removing which will free at least ùëö units of memory; the minimum number of convenience points that Polycarp will lose if such a set exists. ","date":"2021-02-03","objectID":"/codeforce_1/:1:3","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Example Input \u0026 Output D. Cleaning the Phone 5 5 7 5 3 2 1 4 2 1 1 2 1 1 3 2 1 5 10 2 3 2 3 2 1 2 1 2 1 4 10 5 1 3 4 1 2 1 2 4 5 3 2 1 2 2 1 2 1 2 -1 6 4 3 ","date":"2021-02-03","objectID":"/codeforce_1/:1:4","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Example Explanation D. Cleaning the Phone In the first test case, it is optimal to remove applications with numbers 2 and 5, freeing 7 units of memory. ùëè2+ùëè5=2. In the second test case, by removing the only application, Polycarp will be able to clear only 2 of memory units out of the 3 needed. In the third test case, it is optimal to remove applications with numbers 1, 2, 3 and 4, freeing 10 units of memory. ùëè1+ùëè2+ùëè3+ùëè4=6. In the fourth test case, it is optimal to remove applications with numbers 1, 3 and 4, freeing 12 units of memory. ùëè1+ùëè3+ùëè4=4. In the fifth test case, it is optimal to remove applications with numbers 1 and 2, freeing 5 units of memory. ùëè1+ùëè2=3. ","date":"2021-02-03","objectID":"/codeforce_1/:1:5","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Solution D. Cleaning the Phone #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long int main() { int n; cin \u003e\u003e n; vector\u003cll\u003e ret; for(int i = 0; i \u003c n; i+=1){ int m, needed; cin \u003e\u003e m \u003e\u003e needed; vector\u003cll\u003e a(m + 1, 0); vector\u003cint\u003e b(m + 1, 0); vector\u003cll\u003e _1; vector\u003cll\u003e _2; ll sum = 0; for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e a[i]; sum += a[i]; } for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e b[i]; if(b[i] == 1){ _1.push_back(a[i]); } else{ _2.push_back(a[i]); } } if(sum\u003cneeded) { ret.push_back(-1); continue; } sort(_1.rbegin(), _1.rend()); sort(_2.rbegin(), _2.rend()); vector\u003cll\u003e _pre2; _pre2.push_back(0); for(int i = 0; i \u003c _2.size(); i++){ _pre2.push_back(_pre2[i] + _2[i]); } int len=_pre2.size(); sum=0; ll ans=1e18; int cur=lower_bound(_pre2.begin(),_pre2.end(),needed)-_pre2.begin(); // if cur == len, it means that no element inside the _pre2 \u003e= needed if(cur!=len) { ans=cur*2; } for(int i = 0; i \u003c _1.size(); i++){ sum += _1[i]; if(needed \u003c 0){ ans = min(ans, 1ll + i + 1); break; } int point = needed - sum; int cur=lower_bound(_pre2.begin(),_pre2.end(),point)-_pre2.begin(); if(cur != len){ ans = min(ans, i + 1 + 2 * 1ll * cur); } } ret.push_back(ans); } for(int i : ret){ cout \u003c\u003c i \u003c\u003c '\\n'; } return 0; } ","date":"2021-02-03","objectID":"/codeforce_1/:2:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Remark D. Cleaning the Phone Implicit Binary Search Idea is computing the prefix sum and set the pointer at application with importance 1, and then do binary search to find the lower_bound for the application with importance of 2 ","date":"2021-02-03","objectID":"/codeforce_1/:3:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["OJ Problem"],"content":"OJ 5","date":"2021-02-02","objectID":"/coding_practice_5/","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"OJ Practice 5, share my solutions for these three OJ problems during the UCSD ICPC Selection Contest. ","date":"2021-02-02","objectID":"/coding_practice_5/:0:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Methodic Multiplication #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; int countS(string s){ int ret = 0; for(int i = 0; i \u003c s.length(); i++){ if(s[i] == 'S'){ ret += 1; } } return ret; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; if(s1 == \"0\"){ cout \u003c\u003c \"0\"; } else if(s2 == \"0\"){ cout \u003c\u003c \"0\"; } else{ int count1 = countS(s1), count2 = countS(s2); int ret = count1 * count2; int idx = 0; vector\u003cchar\u003e resultS; for(int i = 0; i \u003c ret; i++){ resultS.push_back('S'); resultS.push_back('('); } resultS.push_back('0'); for(int i = 0; i \u003c ret; i++){ resultS.push_back(')'); } string retS(resultS.begin(), resultS.end()); cout \u003c\u003c retS; } return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:1:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Dams in Distress #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; /* 4 75 0 100 50 1 49 10 1 50 0 3 50 48 */ int main() { ll n, t; cin \u003e\u003e n \u003e\u003e t; unordered_map\u003cint, vector\u003cint\u003e\u003e graph; vector\u003cll\u003e needed(n + 1, 0); vector\u003cll\u003e require(n + 1, 0); vector\u003cll\u003e current(n + 1, 0); // the first one need t amount of water needed[0] = t; require[0] = t; for(int i = 1; i \u003c= n; i++){ int d, c, u; cin \u003e\u003e d \u003e\u003e c \u003e\u003e u; // from parent to child if(graph.find(d) == graph.end()){ graph[d] = vector\u003cint\u003e {i}; } else{ graph[d].push_back(i); } require[i] = c; current[i] = u; } deque\u003cint\u003e q; q.push_back(0); while(q.size()){ int p = q.front(); q.pop_front(); if(graph.find(p) != graph.end()){ for(int np : graph[p]){ ll cur_n = max(needed[p], require[np]) - current[np]; needed[np] = cur_n; q.push_back(np); } } } ll min_amount = LLONG_MAX; for(int i = 0; i \u003c= n; i++){ min_amount = min(min_amount, needed[i]); } cout \u003c\u003c min_amount; /*TLE solution ll min_amount = LLONG_MAX; for(int i = 0; i \u003c= n; i++){ ll needed = require[i] - current[i]; ll carry = require[i]; int idx = i; while(idx != 0){ int next_level = parent[idx]; if(carry + current[next_level] \u003c require[next_level]){ break; } else{ carry = carry + current[next_level]; idx = parent[idx]; } } if(idx == 0){ min_amount = min(min_amount, needed); } } cout \u003c\u003c min_amount; */ return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:2:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Array of Discord #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; /* 3 2020 2020 2020 */ /* 4 1 42 4711 9876 */ ll magicSmall(ll num){ if(num \u003c 10){ return 0; } else{ string s = to_string(num); // if the first digit is not 1, we change it to 1, and return it. if(s[0] != '1'){ s[0] = '1'; return stoll(s); } // if the first digit is 1, we find the first non-zero, and change it to zero else{ for(int i = 1; i \u003c s.length(); i+=1){ if(s[i] != '0'){ s[i] = '0'; return stoll(s); } } } } return num; } ll magicBig(ll num){ if(num \u003c 10){ return 9; } else{ string s = to_string(num); if(s[0] != '9'){ s[0] = '9'; return stoll(s); } // find the first non-9, and change it to 9 else{ for(int i = 1; i \u003c s.length(); i+=1){ if(s[i] != '9'){ s[i] = '9'; return stoll(s); } } } } return num; } int main() { int n; cin \u003e\u003e n; vector\u003cll\u003e nums(n, 0); for(int i = 0; i \u003c n; i++){ ll num; cin \u003e\u003e num; nums[i] = num; } // either make left bigger, scan from the left to right, if the changed number is biggr than the one on the right, // we can return the array of numers for(int i = 0; i \u003c nums.size() - 1; i++){ if(magicBig(nums[i]) \u003e nums[i+1]){ nums[i] = magicBig(nums[i]); for(ll i : nums){ cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } } // or make right smaller, scan from right to left, if the changed number is smaller than the one on the left, // return the array of numbers for(int i = nums.size() - 1; i \u003e= 1; i--){ if(magicSmall(nums[i]) \u003c nums[i - 1]){ nums[i] = magicSmall(nums[i]); for(ll i : nums){ cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } } cout \u003c\u003c \"impossible\"; return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:3:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Remark to Array of Discord Just use stoll, do not mess up with the overflow ","date":"2021-02-02","objectID":"/coding_practice_5/:4:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"OJ 4","date":"2021-01-29","objectID":"/coding_practice_4/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"OJ Practice 4, share my solutions for these three OJ problems. ","date":"2021-01-29","objectID":"/coding_practice_4/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"[NCPC 2011 Problem A: Car Trouble] #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* 6 0 1 1 1 1 2 2 3 1 3 0 3 0 4 2 5 0 5 1 4 */ set\u003cint\u003e solve(unordered_map\u003cint, vector\u003cint\u003e\u003e\u0026 graph){ set\u003cint\u003e seen; if (graph.find(0) == graph.end()){ return seen; } deque\u003cint\u003e q; q.push_back(0); while(q.size()){ int cur = q.front(); q.pop_front(); seen.insert(cur); for(int j = 0; j \u003c graph[cur].size(); ++j){ if(seen.find(graph[cur][j]) == seen.end()){ seen.insert(graph[cur][j]); q.push_back(graph[cur][j]); } } } return seen; } int main() { int m, f, t, n; unordered_map\u003cint, vector\u003cint\u003e\u003e graph; unordered_map\u003cint, vector\u003cint\u003e\u003e reverse_graph; vector\u003cint\u003e all_road; cin \u003e\u003e m; for(int i = 0; i \u003c m; i++){ cin \u003e\u003e f; cin \u003e\u003e n; all_road.push_back(f); if(reverse_graph.find(t) == reverse_graph.end()){ reverse_graph[f] = vector\u003cint\u003e{}; } if(graph.find(f) == graph.end()){ graph[f] = vector\u003cint\u003e{}; } for(int j = 0; j \u003c n; j++){ cin \u003e\u003e t; graph[f].push_back(t); reverse_graph[t].push_back(f); } } // UNREACHABLE vector\u003cint\u003e unreachable; // TRAPPED vector\u003cint\u003e trapped; set\u003cint\u003e not_trapped = solve(reverse_graph); set\u003cint\u003e not_unreachable = solve(graph); for(int i : all_road){ if(not_unreachable.find(i) == not_unreachable.end()){ unreachable.push_back(i); } if(not_trapped.find(i) == not_trapped.end()){ trapped.push_back(i); } } if(trapped.size() == 0 \u0026\u0026 unreachable.size() == 0){ cout \u003c\u003c \"NO PROBLEMS\"; return 0; } else{ for(int i : trapped){ cout \u003c\u003c \"TRAPPED \" \u003c\u003c i \u003c\u003c endl; } for(int i : unreachable){ cout \u003c\u003c \"UNREACHABLE \" \u003c\u003c i \u003c\u003c endl; } } return 0; } ","date":"2021-01-29","objectID":"/coding_practice_4/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"NCPC 2015‚Äã Goblin Garden Guards #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* 5 0 0 100 0 0 100 100 100 50 50 1 0 0 50 */ int main() { int n, m; cin \u003e\u003e n; int x, y, r; vector\u003ctuple\u003cint, int\u003e\u003e g; vector\u003ctuple\u003cint, int, int\u003e\u003e s; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e x \u003e\u003e y; g.push_back(make_tuple(x, y)); } cin \u003e\u003e m; for (int i = 0; i \u003c m; i++) { cin \u003e\u003e x \u003e\u003e y \u003e\u003e r; s.push_back(make_tuple(x, y, r)); } vector\u003cvector\u003cbool\u003e\u003e board(10000 + 5, vector\u003cbool\u003e(10000 + 5, true)); /*TLE SOLUTION int ret = 0; for(int i = 0; i \u003c n; i++){ bool flag = true; int g_x = get\u003c0\u003e(g[i]), g_y = get\u003c1\u003e(g[i]); for(int j = 0; j \u003c m; j++){ int s_x = get\u003c0\u003e(s[j]), s_y = get\u003c1\u003e(s[j]), s_r = get\u003c2\u003e(s[j]); if( pow((g_x - s_x), 2) + pow((g_y - s_y), 2) \u003c= pow(s_r, 2)){ flag = false; break; } } if(flag){ ret += 1; } } */ for (int j = 0; j \u003c m; j++) { int s_x = get\u003c0\u003e(s[j]), s_y = get\u003c1\u003e(s[j]), s_r = get\u003c2\u003e(s[j]); for (int dx = -s_r; dx \u003c= s_r; dx++) { for (int dy = -s_r; dy \u003c= s_r; dy++) { if (s_x + dx \u003e= 0 \u0026\u0026 s_x + dx \u003c 10000 + 5 \u0026\u0026 s_y + dy \u003e= 0 \u0026\u0026 s_y + dy \u003c 10000 + 5) { // double check the name of variables is correct if (dx * dx + dy * dy \u003c= s_r * s_r) { board[s_x + dx][s_y + dy] = false; } } } } } int ret = 0; for (int i = 0; i \u003c n; i++) { int g_x = get\u003c0\u003e(g[i]), g_y = get\u003c1\u003e(g[i]); if (board[g_x][g_y]) { ret += 1; } } cout \u003c\u003c ret; return 0; } ","date":"2021-01-29","objectID":"/coding_practice_4/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"OJ 2","date":"2021-01-28","objectID":"/coding_practice_3/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"OJ Practice 3, share my solution for these three OJ problems. ","date":"2021-01-28","objectID":"/coding_practice_3/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"NCPC 2011 Problem B: Mega Inversion using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { const int N = 2 * 1e5 + 10; const int origin = 1e5 + 10; public: vector\u003cll\u003e countLarger(vector\u003cint\u003e\u0026 nums){ vector\u003cll\u003e segtree(2 * N + 2, 0); reverse(nums.begin(), nums.end()); for(int i = 0; i \u003c nums.size(); ++i){ nums[i] = -nums[i]; } vector\u003cll\u003e result; for (int i = nums.size()-1; i \u003e= 0; i--) { result.push_back(rangeQuery(segtree, origin + nums[i])); update(segtree, origin + nums[i]); } return result; } vector\u003cll\u003e countSmaller(vector\u003cint\u003e\u0026 nums) { vector\u003cll\u003e segtree(2*N + 2, 0); vector\u003cll\u003e result; for (int i = nums.size()-1; i \u003e= 0; i--) { result.push_back(rangeQuery(segtree, origin + nums[i])); update(segtree, origin + nums[i]); } // need to reverse result reverse(result.begin(), result.end()); return result; } void update(vector\u003cll\u003e\u0026 segtree, int index) { for (index += N; index \u003e 0; index \u003e\u003e= 1) { segtree[index]++; } } ll rangeQuery(vector\u003cll\u003e\u0026 segtree, int entry) { int left = 0; int right = entry; ll result = 0; for (left += N, right += N; left \u003c right; left \u003e\u003e= 1, right \u003e\u003e= 1) { if(entry == 6 + origin){ } if (left%2 == 1) result += segtree[left++]; if (right%2 == 1) result += segtree[--right]; } return result; } }; int main() { Solution s; int n; cin \u003e\u003e n; vector\u003cint\u003e nums; int t; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e t; nums.push_back(t); } vector\u003cll\u003e smaller = s.countSmaller(nums); vector\u003cll\u003e larger = s.countLarger(nums); ll ret = 0; for(int i = 0; i \u003c larger.size(); i ++){ ret += (larger[i] * smaller[i]); } cout \u003c\u003c ret; return 0; } ","date":"2021-01-28","objectID":"/coding_practice_3/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"OJ 2","date":"2021-01-27","objectID":"/coding_practice_2/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"OJ Practice 2, share my solution for these three OJ problems. ","date":"2021-01-27","objectID":"/coding_practice_2/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"Robots on a grid using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { public: int test() { } }; int solve(vector\u003cvector\u003cint\u003e\u003e\u0026 board){ int m = board.size(), n = board[0].size(); int step = 0; vector\u003cint\u003e dirs = {0, 1, 0, -1, 0}; set\u003cint\u003e seen; deque\u003cint\u003e q; q.push_back(0); seen.insert(0); while(q.size()){ int size = q.size(); for(int i = 0; i \u003c size; i++){ int p = q.front(); q.pop_front(); int r = p / n, c = p % n; if(r == m - 1 \u0026\u0026 c == n - 1){ return step; } else{ for(int i = 0; i \u003c 4; i++){ int nr = r + (board[r][c] * dirs[i]), nc = c + (board[r][c] * dirs[i + 1]); if(nr \u003e= 0 \u0026\u0026 nr \u003c m \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n){ int np = nr * n + nc; if(seen.find(np) == seen.end()){ seen.insert(np); q.push_back(np); } } } } } step += 1; } return -1; } int main() { int m, n; cin \u003e\u003e m \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e board(m, vector\u003cint\u003e(n, 0)); char c; for(int i = 0; i \u003c m; i++){ for(int j = 0; j \u003c n; j++){ cin \u003e\u003e c; board[i][j] = c - '0'; } } // for(int i = 0; i \u003c m; i++){ // for(int j = 0; j \u003c n; j++){ // cout \u003c\u003c board[i][j]; // } // } cout \u003c\u003c solve(board); return 0; } ","date":"2021-01-27","objectID":"/coding_practice_2/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"SERGRID - Grid using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int solve(vector\u003cvector\u003cunsigned int\u003e\u003e\u0026 board){ int n = board.size() - 1; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= n; j++){ if(board[i][j] == -1){ board[i][j] = 0; } else{ board[i][j] = (board[i][j - 1] % 0x7FFFFFFF + board[i - 1][j] % 0x7FFFFFFF) % 0x7FFFFFFF; } } } return board[n][n]; } bool isValid(vector\u003cvector\u003cint\u003e\u003e\u0026 board){ int n = board.size(); // invalid board if(board[0][0] == -1){ return false; } vector\u003cint\u003e dirs = {0, 1, 0, -1, 0}; // r * n + c set\u003cint\u003e seen; deque\u003cint\u003e d; seen.insert(0); d.push_back(0); while(d.size()){ int p = d.front(); d.pop_front(); int r = p / n, c = p % n; if(r == n - 1 \u0026\u0026 c == n - 1){ return true; } else{ for(int i = 0; i \u003c dirs.size() - 1; i++){ int nr = r + dirs[i], nc = c + dirs[i + 1]; if(nr \u003e= 0 \u0026\u0026 nr \u003c n \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n \u0026\u0026 board[nr][nc] == 0){ int np = nr * n + nc; if(seen.find(np) == seen.end()){ seen.insert(np); d.push_back(np); } } } } } return false; } int main() { int n; char c; cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e validBoard(n, vector\u003cint\u003e(n, 0)); vector\u003cvector\u003cunsigned int\u003e\u003e board(n + 1, vector\u003cunsigned int\u003e(n + 1, 0)); for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c n; j++){ cin \u003e\u003e c; if(c == '.'){ board[i + 1][j + 1] = 0; validBoard[i][j] = 0; } else{ board[i + 1][j + 1] = -1; validBoard[i][j] = -1; } } } if(isValid(validBoard) == false){ cout \u003c\u003c \"INCONCEIVABLE\"; return 0; } board[0][1] = 1; int ret = solve(board); if (ret != 0){ cout \u003c\u003c ret; } else{ if(isValid(validBoard) == false){ cout \u003c\u003c \"INCONCEIVABLE\"; return 0; } else{ cout \u003c\u003c \"THE GAME IS A LIE\"; } } return 0; } ","date":"2021-01-27","objectID":"/coding_practice_2/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"OJ 1","date":"2021-01-26","objectID":"/coding_practice_1/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"OJ Practice 1, share my solution for these three OJ problems. ","date":"2021-01-26","objectID":"/coding_practice_1/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2013 Problem E: Timebomb #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int main() { string s; vector\u003cstring\u003e l; for(int i = 0; i \u003c 5; ++i){ std::getline (std::cin,s); l.push_back(s); } // for(string s : l){ // cout \u003c\u003c s \u003c\u003c endl; // } vector\u003cstring\u003e num_str = {\"75557\", \"11111\", \"71747\", \"71717\", \"55711\", \"74717\", \"74757\", \"71111\", \"75757\", \"75717\"}; unordered_map\u003cstring, int\u003e ref; for(int i = 0; i \u003c num_str.size(); ++i){ ref[num_str[i]] = i; } long long num = 0; vector\u003cint\u003e number; for(int i = 0; i \u003c l[0].size(); i += 4){ string s = \"\"; for(int k = 0; k \u003c 5; k++){ int counter = 0; for(int j = 0; j \u003c 3; j++){ if(l[k][i + j] == '*'){ counter += pow(2, 2- j); } } s += to_string(counter); } if(ref.find(s) == ref.end()){ cout \u003c\u003c \"BOOM!!\"; return 0; } else{ number.push_back(ref[s]); } } for(int i = 0; i \u003c number.size(); i += 1){ num = num * 10 + number[i]; } if(num % 6 == 0){ cout \u003c\u003c \"BEER!!\"; return 0; } else{ cout \u003c\u003c \"BOOM!!\"; return 0; } return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2015 Problem C: Cryptographer‚Äôs Conundrum #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int solve(string s){ int counter = 0; vector\u003cchar\u003e ref = {'P', 'E', 'R'}; for(int i = 0; i \u003c s.length(); ++i){ if(s[i] != ref[i % 3]){ counter += 1; } } return counter; } int main() { string s; cin \u003e\u003e s; cout \u003c\u003c solve(s) \u003c\u003c \"\\n\"; return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2011 Problem E: ls #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* *.* 4 main.c a.out readme yacc */ bool solve(string s, string p){ int s_len = s.length(), p_len = p.length(); vector\u003cvector\u003cbool\u003e\u003e dp(s_len + 1, vector\u003cbool\u003e(p_len + 1, false)); dp[0][0] = true; for(int j = 1; j \u003c= p_len; ++j){ if(p[j - 1] == '*'){ dp[0][j] = dp[0][j-1]; } else{ dp[0][j] = false; } } for(int i = 1; i \u003c= s_len; ++i){ for(int j = 1; j \u003c= p_len; ++j){ if(p[j-1] == '*'){ dp[i][j] = dp[i-1][j] || dp[i][j-1] || dp[i-1][j-1]; } else{ if(p[j-1] == s[i-1]){ dp[i][j] = dp[i-1][j-1]; } else{ dp[i][j] = false; } } } } return dp[s_len][p_len]; } int main() { int n = 0; string p, s; cin \u003e\u003e p; cin \u003e\u003e n; vector\u003cstring\u003e l; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e s; if(solve(s, p)){ l.push_back(s); } } for(string s : l){ cout \u003c\u003c s \u003c\u003c endl; } return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:3:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 315 - Count of Smaller Numbers After Self","date":"2021-01-23","objectID":"/leetcode_315/","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Use Segment Tree to solve Leetcode 315 - Count of Smaller Numbers After Self. ","date":"2021-01-23","objectID":"/leetcode_315/:0:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 315 You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. ","date":"2021-01-23","objectID":"/leetcode_315/:1:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 315 Example1: Input: nums = [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. ","date":"2021-01-23","objectID":"/leetcode_315/:2:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 315 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class SegmentTreeNode(object): # range[min, max] def __init__(self, min, max): self.min = min self.max = max self.mid = (self.max - self.min) // 2 + self.min self.count = 0 self.right = None self.left = None class SegmentTree(object): def __init__(self, root): self.root = root def update(self, value): self.updateHelper(value, self.root) def updateHelper(self, value, node): if node == None: return if value \u003c node.min or value \u003e node.max: return node.count += 1 if node.min == node.max: return working_mid = node.mid if node.left == None: node.left = SegmentTreeNode(node.min, working_mid) if node.right == None: node.right = SegmentTreeNode(working_mid + 1, node.max) if value \u003e working_mid: self.updateHelper(value, node.right) else: self.updateHelper(value, node.left) def queryRange(self, value): return self.queryRangeHelper(value, self.root) def queryRangeHelper(self, value, node): if node == None: return 0 if value \u003e= node.max: return node.count working_mid = node.mid if value \u003c= working_mid: return self.queryRangeHelper(value, node.left) else: return self.queryRangeHelper(value, node.right) + self.queryRangeHelper(value, node.left) class Solution: def countSmaller(self, nums: List[int]) -\u003e List[int]: if len(nums) == 0: return [] ret = [] root = SegmentTreeNode(min(nums), max(nums)) tree = SegmentTree(root) for i in range(len(nums) - 1, -1, -1): ret.append(tree.queryRange(nums[i] - 1)) tree.update(nums[i]) return ret[::-1] ","date":"2021-01-23","objectID":"/leetcode_315/:3:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Remark For each TreeNode, count refers to how many number between [max, min] O(nlogk) solution, where k is the max difference ","date":"2021-01-23","objectID":"/leetcode_315/:4:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 732 - My Calendar III","date":"2021-01-21","objectID":"/leetcode_732/","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Use Segment Tree to solve Leetcode 732 - My Calendar III. ","date":"2021-01-21","objectID":"/leetcode_732/:0:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 732 A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.) You are given some events [start, end), after each given event, return an integer k representing the maximum k-booking between all the previous events. Implement the MyCalendarThree class: MyCalendarThree() Initializes the object. int book(int start, int end) Returns an integer k representing the largest integer such that there exists a k-booking in the calendar. ","date":"2021-01-21","objectID":"/leetcode_732/:1:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 732 Example1: Input [\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"] [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]] Output [null, 1, 1, 2, 3, 3, 3] Explanation MyCalendarThree myCalendarThree = new MyCalendarThree(); myCalendarThree.book(10, 20); // return 1, The first event can be booked and is disjoint, so the maximum k-booking is a 1-booking. myCalendarThree.book(50, 60); // return 1, The second event can be booked and is disjoint, so the maximum k-booking is a 1-booking. myCalendarThree.book(10, 40); // return 2, The third event [10, 40) intersects the first event, and the maximum k-booking is a 2-booking. myCalendarThree.book(5, 15); // return 3, The remaining events cause the maximum K-booking to be only a 3-booking. myCalendarThree.book(5, 10); // return 3 myCalendarThree.book(25, 55); // return 3 ","date":"2021-01-21","objectID":"/leetcode_732/:2:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 732 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class TreeNode: # segment tree with lazy propogation for range max query # half-open interval [lo, hi) def __init__(self, low, high, val=0, lazy=0, leftChild = None, rightChild = None): self.low = low self.high = high # range max self.val = val # bookings to add to the children the next time children get visited self.lazy = lazy self.leftChild = leftChild self.rightChild = rightChild class MyCalendarThree: MIN_BOUND = 0 MAX_BOUND = 1e9 + 1 def __init__(self): self.root = TreeNode(MyCalendarThree.MIN_BOUND, MyCalendarThree.MAX_BOUND) def book(self, start: int, end: int) -\u003e int: # update the segment from top to down, using lazy propogation self.update(self.root, start, end) return self.root.val def update(self, node, start, end): # we found the match, increment the value and lazy to be propogated if node.low == start and node.high == end: node.val += 1 node.lazy += 1 return mid = (node.high - node.low) // 2 + node.low # top-down building the segment tree if node.leftChild == None and node.rightChild == None: node.leftChild = TreeNode(node.low, mid, node.lazy, node.lazy) node.rightChild = TreeNode(mid, node.high, node.lazy, node.lazy) else: node.leftChild.val += node.lazy node.leftChild.lazy += node.lazy node.rightChild.val += node.lazy node.rightChild.lazy += node.lazy node.lazy = 0 # after building the children, we are able to traverse downwards if mid \u003e= end: self.update(node.leftChild, start, end) elif mid \u003c= start: self.update(node.rightChild, start, end) else: self.update(node.leftChild, start, mid) self.update(node.rightChild, mid, end) node.val = max(node.leftChild.val, node.rightChild.val) return # credit to https://leetcode.com/problems/my-calendar-iii/discuss/1023625/Python-Segment-Tree-with-Lazy-Propagation ","date":"2021-01-21","objectID":"/leetcode_732/:3:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Remark We treat this problem as segment tree(interval tree) where each book would trigger the building of tree To build the tree top-down, we utilize Lazy Propagation ","date":"2021-01-21","objectID":"/leetcode_732/:4:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Data Structure"],"content":"This article reviews segment tree.","date":"2021-01-20","objectID":"/segment_tree/","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"This article reviews Segment Tree. Segment Tree ","date":"2021-01-20","objectID":"/segment_tree/:0:0","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Semantics This balanced tree data structure stores the aggregation of certain property within certain range. build(start, end, vals): construct the segment tree update(index, value): update the A[index] to value rangeQuery(start, end) query the aggregation of certain range [start, end] ","date":"2021-01-20","objectID":"/segment_tree/:0:1","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Implementation class SegmentTreeNode: def __init__(self, start, end, val, left=None, right=None): self.start = start self.end = end self.mid = start + (end - start) // 2 self.val = val self.left = left self.right = right class SegmentTree: def __init__(self, nums): self.nums = nums if self.nums: self.root = self.build(0, len(nums) - 1, nums) def build(self, start, end, nums): if start == end: return SegmentTreeNode(start, end, nums[start]) mid = (end - start) // 2 + start leftNode = self.build(start, mid, nums) rightNode = self.build(mid + 1, end, nums) return SegmentTreeNode(start, end, leftNode.val + rightNode.val, leftNode, rightNode) def update(self, index, value): self.updateHelper(self.root, index, value) def updateHelper(self, node, index, value): if node.start == index and node.end == index: node.val = value return if index \u003c= node.mid: self.updateHelper(node.left, index, value) else: self.updateHelper(node.right, index, value) node.val = node.left.val + node.right.val def queryRange(self, start, end): return self.queryRangeHelper(self.root, start, end) def queryRangeHelper(self, node, start, end): if node.start == start and node.end == end: return node.val elif end \u003c= node.mid: return self.queryRangeHelper(node.left, start, end) elif start \u003e node.mid: return self.queryRangeHelper(node.right, start, end) else: return self.queryRangeHelper(node.left, start, node.mid) + self.queryRangeHelper(node.right, node.mid + 1, end) ","date":"2021-01-20","objectID":"/segment_tree/:0:2","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Efficienty Analysis buil -\u003e O(n) update -\u003e O(log n) rangeQuery -\u003e ~ O(log n) ","date":"2021-01-20","objectID":"/segment_tree/:0:3","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Remarks query range with mutable arrays ","date":"2021-01-20","objectID":"/segment_tree/:0:4","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 947 - Most Stones Removed with Same Row or Column","date":"2021-01-17","objectID":"/leetcode_947/","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 947 - Most Stones Removed with Same Row or Column. ","date":"2021-01-17","objectID":"/leetcode_947/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 947 On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed. ","date":"2021-01-17","objectID":"/leetcode_947/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 947 Example1: Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5 Explanation: One way to remove 5 stones is as follows: 1. Remove stone [2,2] because it shares the same row as [2,1]. 2. Remove stone [2,1] because it shares the same column as [0,1]. 3. Remove stone [1,2] because it shares the same row as [1,0]. 4. Remove stone [1,0] because it shares the same column as [0,0]. 5. Remove stone [0,1] because it shares the same row as [0,0]. Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane. Example2: Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3 Explanation: One way to make 3 moves is as follows: 1. Remove stone [2,2] because it shares the same row as [2,0]. 2. Remove stone [2,0] because it shares the same column as [0,0]. 3. Remove stone [0,2] because it shares the same row as [0,0]. Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane. Example3: Input: stones = [[0,0]] Output: 0 Explanation: [0,0] is the only stone on the plane, so you cannot remove it. ","date":"2021-01-17","objectID":"/leetcode_947/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 947 from collections import deque, Counter class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): # already inserted if p in self.parents: return True else: self.num_sets += 1 self.parents[p] = p self.sizes[p] = 1 return False def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, [p, q]) if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sets -= 1 class Solution: def removeStones(self, stones: List[List[int]]) -\u003e int: row_stone = {} # row -\u003e stone location col_stone = {} # col -\u003e stone location for stone in stones: i, j = stone[0], stone[1] location = (i, j) if i in row_stone: row_stone[i].add(location) else: row_stone[i] = set() row_stone[i].add(location) if j in col_stone: col_stone[j].add(location) else: col_stone[j] = set() col_stone[j].add(location) disjoint_set = UnionFind() all_stone = set() for stone in stones: i, j = stone[0], stone[1] location = (i, j) if disjoint_set.contains(location): continue else: # do a little bfs here to find all the connected component my_queue = deque() my_queue.append(location) row_seen = set() col_seen = set() while(len(my_queue) != 0): cur_loc = my_queue.pop() disjoint_set.insert(cur_loc) disjoint_set.union(cur_loc, location) all_stone.add(cur_loc) i, j = cur_loc[0], cur_loc[1] if i not in row_seen: row_seen.add(i) for stone in row_stone[i]: my_queue.append(stone) if j not in col_seen: col_seen.add(j) for stone in col_stone[j]: my_queue.append(stone) leader_size = {} for stone in all_stone: real_leader = disjoint_set.find(stone) if real_leader not in leader_size: leader_size[real_leader] = disjoint_set.sizes[real_leader] else: leader_size[real_leader] = disjoint_set.sizes[real_leader] ret = 0 for leader in leader_size: ret += (leader_size[leader] - 1) return ret ","date":"2021-01-17","objectID":"/leetcode_947/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Remark We define connected-compoent as the componet of stones share same col/row with at least 1 other stone in the graph STEP1, remember all the locations of the stones STEP2, create disjoint set that stores all connected-component together STEP3, for each connected component, we greedily pick the size-1 of that component ","date":"2021-01-17","objectID":"/leetcode_947/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 827 - Making A Large Island","date":"2021-01-15","objectID":"/leetcode_827/","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 827 - Making A Large Island. ","date":"2021-01-15","objectID":"/leetcode_827/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). ","date":"2021-01-15","objectID":"/leetcode_827/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3. Example2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4. ","date":"2021-01-15","objectID":"/leetcode_827/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t : self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sets -= 1 return False class Solution: def largestIsland(self, grid: List[List[int]]) -\u003e int: dirs = [0, 1, 0, -1, 0] # Step1, union 1's and find 0's disjoint_set = UnionFind() all_zeros = set() ret = 0 m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == 1: base = i * n + j disjoint_set.insert(base) for t in range(len(dirs) - 1): if i + dirs[t] \u003e= 0 and i + dirs[t] \u003c m and j + dirs[t + 1] \u003e= 0 and j + dirs[t + 1] \u003c n and grid[i + dirs[t]][j + dirs[t + 1]] == 1: neighbour = (i + dirs[t]) * n + (j + dirs[t + 1]) disjoint_set.insert(neighbour) disjoint_set.union(neighbour, base) else: all_zeros.add((i, j)) # edge case, all 1's, just return the size of the grid if len(all_zeros) == 0: return m * n # for all possible zeros, try to flip it for zero in all_zeros: i, j = zero[0], zero[1] leader_size = {} for t in range(len(dirs) - 1): if i + dirs[t] \u003e= 0 and i + dirs[t] \u003c m and j + dirs[t + 1] \u003e= 0 and j + dirs[t + 1] \u003c n and grid[i + dirs[t]][j + dirs[t + 1]] == 1: leader = disjoint_set.find((i + dirs[t]) * n + (j + dirs[t + 1])) if leader in leader_size: continue else: leader_size[leader] = disjoint_set.sizes[leader] ret = max(ret, sum(list(leader_size.values())) + 1) return ret ","date":"2021-01-15","objectID":"/leetcode_827/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Naive Approach tries all the zeros, and recompute the connected component Union Find helps us to find the size of the connected component without computing the graph again, O(n*m) ","date":"2021-01-15","objectID":"/leetcode_827/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 1722 - Minimize Hamming Distance After Swap Operations.","date":"2021-01-14","objectID":"/leetcode_1722/","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 1722 - Minimize Hamming Distance After Swap Operations. ","date":"2021-01-14","objectID":"/leetcode_1722/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 1722 You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 \u003c= i \u003c= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source. ","date":"2021-01-14","objectID":"/leetcode_1722/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 1722 Example1: Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output: 1 Explanation: source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example1: Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output: 2 Explanation: There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. ","date":"2021-01-14","objectID":"/leetcode_1722/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 1722 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sizes = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.num_sizes += 1 self.parents[p] = p self.sizes[p] = 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # this means that we found a redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sizes -= 1 return False class Solution: def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(source) for i in range(n): disjoint_set.insert(i) # build the union graph # in each group, the numbers can be placed anywhere for edge in allowedSwaps: disjoint_set.union(edge[0], edge[1]) # hashmap, # group leader -\u003e set[indices in that group] leader_member = {} print(disjoint_set.parents) for member, leader in disjoint_set.parents.items(): # This is the real leader for this member leader = disjoint_set.find(member) if leader in leader_member: leader_member[leader].add(member) else: leader_member[leader] = set([member]) print(leader_member) ret = 0 # for all the members, try to figure out the distance for members in leader_member.values(): source_numbers = [source[i] for i in members] target_numbers = [target[i] for i in members] ret += sum((Counter(source_numbers) - Counter(target_numbers)).values()) return ret ","date":"2021-01-14","objectID":"/leetcode_1722/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To solve this problem, we need to observe that if (0, 1) is exchangeable and (0, 2) is exchangeable, then any pair in (0, 1, 2) can be exchangeble. The remaining problem is how to detect connected components in the graph -\u003e use Union Find. Counter, the subclass of dictionary, supports many great opeartions. ","date":"2021-01-14","objectID":"/leetcode_1722/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Entertainment"],"content":"ÁâõÊåØÂçé‰∏âÈÉ®Êõ≤","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/","tags":["Movie Review","Chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Entertainment"],"content":"Stand Up, Don‚Äôt Bend Over 1993 Back to Back, Face to Face 1994 Signal Left, Turn Right 1995 Èó≤Êù•Êó†‰∫ãÔºåÂÜô‰∏ÄÁØáÂΩ±ËØÑÔºåËÆ∞ÂΩï‰∏Ä‰∏ã2021ÁöÑÂºÄÂßã„ÄÇ ÂÅ∂ÁÑ∂ÁöÑÊú∫‰ºöÁúã‰∫Ü‰∏ÄÈÉ®ÂèçÂ∫î‰∏≠ÂõΩÊîøÊ≤ªÁîüÊÄÅÁöÑÂ∞èÁü≠ÁØáÔºå‰πãÂêéÊúâËØÑËÆ∫ÈáåÊèêÂà∞‰∏ÄÈÉ®„ÄäËÉåÈù†ËÉåÔºåËÑ∏ÂØπËÑ∏„ÄãÁöÑÁîµÂΩ±ÔºåÁÆÄÂçïÁöÑÂêçÂ≠óÂæÄÂæÄËóèÁùÄ‰∏çÂπ≥Âá°ÁöÑÊïÖ‰∫ãÔºåyoutubeÂíåbÁ´ôÊêú‰∫Ü‰∏Ä‰∏ãÔºåÊúâÁâàÊùÉÔºåÈöèÂç≥Áúã‰∫Ü‰∏Ä‰∏ã„ÄÇ Ëøô‰∏âÈÉ®ÁîµÂΩ±ÈÉΩÁî±ÁâõÊåØÂçé‰∏ªÊºîÔºåÈªÑÂª∫Êñ∞ÊâßÂØºÔºåÁî®ÂπΩÈªòÁöÑÊâãÊ≥ïÂèçÂ∫îÂΩìÊó∂90Âπ¥‰ª£ÁöÑÈÉΩÂ∏ÇÁôæÊÄÅ„ÄÅÁªèÊµéÁîüÊ¥ªÔºåÊîøÊ≤ªÁîüÊÄÅ„ÄÇ„ÄäËÉåÈù†ËÉåÔºåËÑ∏ÂØπËÑ∏„Äã„ÄäÁ´ôÁõ¥ÂñΩÔºåÂà´Ë∂¥‰∏ã„Äã„ÄäÁ∫¢ÁÅØÂÅúÁªøÁÅØË°å„ÄãÂêàÁß∞‚ÄúÈÉΩÂ∏ÇÁôæÊÄÅ‰∏âÈÉ®Êõ≤‚Äù„ÄÇ „ÄäËÉåÈù†ËÉåÔºåËÑ∏ÂØπËÑ∏„ÄãËÆ≤Ëø∞ÁöÑÊòØ‰∏Ä‰∏™ÊñáÁâ©È¶ÜÁöÑÁéãÂèåÁ´ãÂâØÈ¶ÜÈïøÔºåÁªûÂ∞ΩËÑëÊ±ÅÊÉ≥‰∏ä‰Ωç‰∏ÄÊääÊâãÁöÑÊïÖ‰∫ã„ÄÇÈÄöËøáÁéãÂâØÈ¶ÜÈïøÂú®ÂÖ∂ËΩ¨Ê≠£ËøáÁ®ã‰∏≠‰∏ÄÊ≥¢‰∏âÊäòÁöÑÁªèÂéÜÔºåÂèçÂ∫î‰∫ÜÁé∞‰ª£ÂåñÁ§æ‰ºö‰∏≠Â§çÊùÇÂæÆÂ¶ôÁöÑ‰∫∫ÈôÖÂÖ≥Á≥ª‰ª•ÂèäÈîôÁªºÂ§çÊùÇÁöÑÊîøÊ≤ªÁîüÊÄÅ„ÄÇÁâõÊåØÂçéÈ•∞ÊºîÁöÑÁéãÂâØÈ¶ÜÈïøÊòØ‰∏Ä‰ΩçÊúâËÉΩÂäõÔºåÊáÇÂæóÊîøÊ≤ªÊâãÊÆµÁöÑÈ¢ÜÂØºÔºåÈöæËÉΩÂèØË¥µÁöÑÊòØÔºåÁâõÁöÑË°®ÊºîÂ±ïÁé∞‰∫Ü‰∫∫ÁöÑÂ§çÊùÇÊÄßÔºåÁüõÁõæÊÄß„ÄÇÂíåÂΩì‰ªäÁ§æ‰ºöÁΩëÁªú‰∏≠ËÆ∏Â§öÁ∫øÊÄßÁöÑ‰∫∫ËÆæ‰∏çÂêåÔºåÁé∞ÂÆû‰∏≠‰∫∫ÁöÑÁîüÊ¥ªÊòØÂØπÁ´ãÁªü‰∏ÄÁöÑÔºåÂú®Â≠¶‰ºö‰ΩøÁî®ÁüõÁõæÁöÑËßÇÁÇπÁúãË∫´ËæπÁöÑÈóÆÈ¢ò‰πãÂêåÊó∂ÔºåËæ©ËØÅÂú∞ÁêÜËß£‰∫∫ÊÄßÁöÑÂ§çÊùÇ„ÄÇ‰ª•ÂèäÂè•ÂÖÜÊù∞È•∞ÊºîÁöÑ‰ºöËÆ°Âú®Â§öÊ¨°ÂÄíÊàà‰∏≠‰ΩìÁé∞Âá∫‚ÄúÊ≤°ÊúâÊ∞∏ËøúÁöÑÁõüÂèãÔºåÂè™ÊúâÊ∞∏ËøúÁöÑÂà©Áõä‚ÄùËøôÁÇπÁé∞ÂÆûÔºåÂÄºÂæóÂõûÂë≥„ÄÇ „ÄäÁ´ôÁõ¥ÂñΩÔºåÂà´Ë∂¥‰∏ã„ÄãÊèèËø∞‰∫Ü‚ÄúÊµÅÊ∞ì‚ÄùÂº†Ê∞∏Ê≠¶ÔºàÁâõÊåØÂçéÈ•∞ÔºâÈÄöËøáÂÖªÈ±ºÂèëÂÆ∂Ëá¥ÂØåÔºåÈÄöËøáËá™Â∑±ÁöÑÂä™ÂäõÂíåÊï¢‰∫éÊãºÊêèÁöÑÁ≤æÁ•ûÊàê‰∏∫ÈÇ£Ê†ãÊ•ºÈáåÊúÄÊúâÊéíÈù¢ÁöÑ‰∫∫„ÄÇÂéüÂÖàÁúã‰∏çËµ∑Âº†Ê∞∏Ê≠¶ÁöÑÂàòÂπ≤ÈÉ®ÔºàËææÂºèÂ∏∏È•∞ÔºâÂíåÁî±È´ò‰ΩúÂÆ∂ÔºàÂÜØÂ∑©È•∞ÔºâÊúÄÁªàÂú®Âà©ÁõäÁöÑË∂ãÂäø‰∏ãÔºåÂÉèÊâÄË∞ìÁöÑÁâ©Ë¥®ÁîüÊ¥ª‰ΩéÂ§¥ÔºåÊîπÂèò‰∫ÜÂØπÂº†Ê∞∏Ê≠¶ÂéüÂÖà‚ÄúÂú∞ÁóûÊµÅÊ∞ì‚ÄùÁöÑÊ†áÁ≠æ„ÄÇÁîµÂΩ±ÂèçÂ∫î‰∫ÜÂΩìÊó∂Á§æ‰ºö‚ÄúÊúâÈí±Ê≤°ÊñáÂåñÔºåÊúâÊñáÂåñÊ≤°Èí±‚ÄùÔºåÂº†Ê∞∏Ê≠¶ÁöÑÊ∏î‰∏öÂÖ¨Âè∏ÂèëÂ±ïÂ£ÆÂ§ßÂêéÔºåË¶ÅÊ±ÇÈ´ò‰ΩúÂÆ∂Êê¨Âá∫ËøôÊ†ãÊ•ºÔºåÂú®Âº†Ê∞∏Ê≠¶‰∏ÄÁ≥ªÂàóÁõòÂ§ñÊãõÁöÑÂπ≤Êâ∞‰∏ãÔºåÈ´ò‰ΩúÂÆ∂ËøûÂ§úÊê¨ÂÆ∂ÔºåÊúÄÂêéÈ´ò‰ΩúÂÆ∂Ëπ≤Âú®Âú∞‰∏äÊî∂Êãæ‰∏úË•øÁöÑÈïúÂ§¥ÔºåÊäõÂá∫ÊñáÂåñ‰∫∫ÊòØÂê¶ÂêëÁâ©Ë¥®‰ΩéÂ§¥Ëøô‰∏™ÂëΩÈ¢ò„ÄÇ „ÄäÁ∫¢ÁÅØÂÅúÁªøÁÅØË°å„ÄãËÆ≤Ëø∞ÁöÑÊòØÂ≠¶ËΩ¶Êó∂ÂèëÁîüÁöÑ‰∏ÄÁ≥ªÂàóÊïÖ‰∫ãÔºå„ÄÄËÆ∞ËÄÖËãüÂÆá‰Ω≥ÔºàÁâõÊåØÂçé È•∞Ôºâ„ÄÅ‰∏ãÂ≤óÂ•≥Â∑•Á®ãËä¨Ôºà‰∏ÅÂòâ‰∏Ω È•∞Ôºâ„ÄÅ‰∏™‰ΩìÊà∑ÁªøË±ÜÔºàÁéãÂä≤Êùæ È•∞Ôºâ„ÄÅÂ§ßÊ¨æËÄÅÂ∑ÆÔºàÂè•Âè∑ È•∞ÔºâÊòØÈ©æÊ†°1025Áè≠ÁöÑÊàêÂëòÔºåÂú®ÈÄÄ‰ºçÂÜõ‰∫∫‰æØÊïôÁªÉÊâã‰∏ãÁªÉ‰π†„ÄÇÈöèÁùÄÊó∂Èó¥ÁöÑÊé®ÁßªÔºåÂ§ßÂÆ∂Ê∏êÊ∏êÊë∏Ê∏ÖÂΩºÊ≠§ÁöÑ‰π†ÊÄß„ÄÇËÆ∞ËÄÖÂ∞èËãüÂÖ´Èù¢Áé≤ÁèëÔºåÂ§Ñ‰∫ãÂúÜÊªëÔºå‰∏ÄÂøÉÊÉ≥ÊääÂ≠¶ËΩ¶Ë¥πÊä•ÈîÄÔºåÁªìÊûúÂ§©‰∏çÈÅÇ‰∫∫ÊÑøÔºõÂæÖ‰∏öÂ•≥Â∑•ÈòøËä¨Ë¢´‰∏ãÊµ∑ÁöÑ‰∏àÂ§´ÂèëÊù•Á¶ªÂ©öÁöÑ‰º†Á•®Ôºå‰∏Ä‰∫∫Â∏¶ÁùÄÂ•≥ÂÑøÔºåËÄÅÂÆûÂ∫¶Êó•ÔºõÊó©Âπ¥‰∏ßÁà∂ÔºåÊØç‰∫≤Áò´Áó™Âú®Â∫äÁöÑÁªøË±ÜÊ≤æÊüì‰∏ä‰∫ÜÊØíÂìÅÔºåÁôΩÂ§©Â≠¶ËΩ¶ÔºåÂçäÂ§úÂÅ∑‰∫ïÁõñÔºåÂç¥ÊòØ‰∏™Â≠ùÈ°∫ÂÑøÂ≠êÔºõÂ§ßÊ¨æËÄÅÂ∑ÆÂàôÊòØ‰∏™ÊâìÁùÄÁõπÂÑøÈÉΩËÉΩËµö‰∏äÂçÅ‰∏á„ÄÅÂÖ´‰∏áÁöÑÊúâÈí±‰∫∫Ôºå‰∏çÊääÈ©æÊ†°ËßÑÂÆöÊîæÂú®ÁúºÈáåÔºõ‰æØÊïôÁªÉÁöÑÊïôÁªÉË∫´‰ªΩ‰∏∫‰ªñÂ∏¶Êù•‰∫ÜÂÖçË¥πÁöÑÈ¶ôÁÉüÂíåËµöÂõûÊâ£ÁöÑÊú∫‰ºöÔºå‰πüÂõ†Ê≠§ÂºïÁÅ´ÁÉßË∫´ÔºåÂºÑÂæóÂÆ∂ÈáåÈ∏°Áä¨‰∏çÂÆÅ„ÄÇ ËøôÊÆµÈ©æÊ†°ÁîüÊ¥ªÔºåÊ≥¢ÊäòËøûËøûÔºåÂç¥ÈÉΩ‰∏Ä‰∏ÄÂåñÈô©‰∏∫Â§∑Ôºå5‰∫∫Èó¥ÁöÑÊöóÊàòÊòéÊàò‰πüÈÉΩÈöèÁùÄËÄÉËØïÁöÑÈ°∫Âà©ÈÄöÂÖ≥ËÄåÁªìÊùü„ÄÇËøôÊÆµÈ©æÊ†°ÁöÑÁªèÂéÜÁâµÊâØÂá∫‰∫Ü5‰∏™‰∫∫ÁöÑÊÇ≤ÂñúÔºåÈô§‰∫ÜÂ≠¶Âà∞‰∫ÜÈ©æÈ©∂ËßÑÂàôÔºå‰ºº‰πéÊõ¥Â≠¶Âà∞‰∫ÜÁîüÂ≠òÊ≥ïÂàô„ÄÇcredit to Ë±ÜÁì£ ÊÄªÁöÑÊù•ËØ¥ÔºåËøô‰∏âÁØáÁîµÂΩ±È£éÊ†ºÁ±ª‰ººÔºåÂ§ßËá¥ÈÉΩÊèèËø∞‰∫ÜÈîôÁªºÂ§çÊùÇÁöÑ‰∫∫ÈôÖÂÖ≥Á≥ªÂíåÁé∞‰ª£ÂåñÁ§æ‰ºöÁöÑ‰∏Ä‰∫õÊãúÈáë‰∏ª‰πâËãóÂ§¥„ÄÇ‰∫∫ÊòØÂ§çÊùÇÁöÑËÄåÈùûÁ∫øÊÄßÁöÑÔºåÁîüÊ¥ªÊòØÁüõ‰∏éÁõæÁöÑÁªìÂêà„ÄÇÁΩëÁªúÂæàÂÆπÊòìËÆ©‰∫∫Èô∑ÂÖ•‰∏ÄÁßçÂçïÁ∫ØÁöÑÊÄùËÄÉÁä∂ÊÄÅÔºåËÆ§‰∏∫ÊâÄÊúâ‰∫ãÁâ©ÈÉΩÊòØÁ∫øÊÄßÁöÑÔºåË¥¥Ê†áÁ≠æ‰ººÁöÑÁêÜËß£‰∫ãÊÉÖÔºåËøôÊ†∑ÊòæÁÑ∂ÂæàÁÆÄÂçïÔºå‰πüÂæàÂÆπÊòìÔºå‰ΩÜÂÜôÂà∞ËøôÈáåÔºå‰πüÊÉ≥Âà∞ÁôæÂ∫¶CEOÊùéÂΩ¶ÂÆèÊõæÂØπÊé®ËçêÁÆóÊ≥ïÊúâ‰∏ÄÁï™ËØ¥ËæûÔºåÂ§ßËá¥ÊèèËø∞ËØ¥Êé®ËçêÁÆóÊ≥ï‰ΩøÂæóÁΩëÊ∞ëÂ§±ÂéªÂ§öÊ†∑ÊÄßÔºåÂú®ËÆ°ÁÆó‰∫ÜÁõ∏‰ººÂ∫¶‰ª•ÂêéÔºåÁî®Êà∑ÂñúÊ¨¢XXÂ∞±‰∏ÄÁõ¥Êé®ÈÄÅXXÔºåÂ¶ÇÊûúÂπ≥Âè∞‰∏ÄÁõ¥ÈÉΩÊòØ‚ÄúÊäïÂÖ∂ÊâÄÂ•Ω‚Äù,ÊääÁî®Êà∑Âõ∞Âú®‰∏Ä‰∏™ÂúàÂ≠êÈáåÔºå‰∏ßÂ§±‰∫ÜËé∑ÂæóÂ§öÊ†∑ÊÄßÁöÑÊú∫‰ºöÔºå‰πü‰ΩøÂæóÂæàÂ§öÁî®Êà∑Â§±Âéª‰∫ÜËæ©ËØÅÊÄùÁª¥„ÄÇÊ±üÊ≥ΩÊ∞ëÊÄª‰π¶ËÆ∞ÊõæËØ¥Ëøá ‚ÄúÂØπÁé∞ÂÆûÁ§æ‰ºö‰∏≠ÁöÑÈóÆÈ¢òÔºåÊàë‰ª¨Ë¶ÅËøõË°åÁêÜÊÄßÁöÑÊÄùËÄÉ„ÄÇÂõ†‰∏∫Êàë‰ª¨ÁúãÂà∞ÁöÑÁé∞Ë±°ÔºåÂÖ∂‰∏≠ÊúâÁöÑÊòØÁúüÁõ∏ÔºåÊúâÁöÑÂç¥ÊòØÂÅáË±°„ÄÇÂè™ÊúâÊääÊÑüÊÄß‰∏äÂçáÂà∞ÁêÜÊÄßÔºåÊâçËÉΩÊ∑±ÂåñËÆ§ËØÜÔºåÊâçËÉΩÊääÊè°‰∫ãÁâ©ÁöÑÊú¨Ë¥®„ÄÇ‚ÄùËøôÂá†ÈÉ®ÁîµÂΩ±Âú®Ê∂àÈÅ£Êó∂Èó¥ÁöÑÂêåÊó∂Ôºå‰πüÊï≤Âìç‰∫ÜËæ©ËØÅÊÄùËÄÉÁöÑË≠¶ÈíüÔºå‰ΩÜ‰ªéÂ§¥ËÆ∫ÔºåÊú¨‰∫∫‰πüÊòØË¢´Êé®ËçêÁÆóÊ≥ïÂ∏¶ËøõËøô‰∫õÁîµÂΩ±ÁöÑÔºå‰∏çÂÖçÊúâ‰∫õËÆΩÂà∫„ÄÇ Â∏åÊúõ‰ª•ÂêéÊÄùËÄÉÈóÆÈ¢òËÉΩÂ§üÊ∑±ÂÖ•Êú¨Ë¥®ÔºåÂà´Â§™Áã≠Èöò„ÄÇ ","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/:0:0","tags":["Movie Review","Chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 547 - Number of Provinces.","date":"2021-01-13","objectID":"/leetcode_547/","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 547 - Number of Provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]] Output: 2 Example2: Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]] Output: 3 ","date":"2021-01-13","objectID":"/leetcode_547/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 class Solution: def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(isConnected) for i in range(n): disjoint_set.insert(i) for i in range(n): for j in range(n): if isConnected[i][j]: disjoint_set.union(i, j) return disjoint_set.num_sets ","date":"2021-01-13","objectID":"/leetcode_547/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To find the connected component in undirected graph, Union Find(Disjoint Set) is the handy data structure to use. ","date":"2021-01-13","objectID":"/leetcode_547/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Data Structure"],"content":"This article reviews union find.","date":"2021-01-12","objectID":"/union_find/","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"This article reviews Union Find(Disjoint Set). Union Find | Disjoint Set ","date":"2021-01-12","objectID":"/union_find/:0:0","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Semantics This data structure stores the collection of disjoint(non-overlapping) sets(groups). find(p): find the leader of group that contains p union(p, q): merge two groups ","date":"2021-01-12","objectID":"/union_find/:0:1","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Implementation class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 ","date":"2021-01-12","objectID":"/union_find/:0:2","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Efficienty Analysis O(n) in memory, O(1) for union and look up in amortized analysis ","date":"2021-01-12","objectID":"/union_find/:0:3","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Remarks Check whether two elements belong to the same group. To find connected components in graph (usually undirected) Speed up implementation of kruskal‚Äôs algorithm ","date":"2021-01-12","objectID":"/union_find/:0:4","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":null,"content":" Welcome to ¬†Haihao Sun‚Äôs field! Self Introduction Haihao SunTravelling \" Travelling Hi there! I am Haihao Sun, and my hobbies come and go. I enjoy travelling, playing Go, playing pokemon, and developing(AKA coding). I was born in Nanjing, and I currently live in San Diego . Skills JavaScript SQL C/C++ ¬†Java Python Extended Links Linkedin Blog Version I Github ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Page","uri":"/about/"}]