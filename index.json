[{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 1722 - Minimize Hamming Distance After Swap Operations.","date":"2021-01-14","objectID":"/leetcode_1722/","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 1722 - Minimize Hamming Distance After Swap Operations. ","date":"2021-01-14","objectID":"/leetcode_1722/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 1722 You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 \u003c= i \u003c= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source. ","date":"2021-01-14","objectID":"/leetcode_1722/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 1722 Example1: Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output: 1 Explanation: source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example1: Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output: 2 Explanation: There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. ","date":"2021-01-14","objectID":"/leetcode_1722/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 1722 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sizes = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.num_sizes += 1 self.parents[p] = p self.sizes[p] = 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # this means that we found a redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sizes -= 1 return False class Solution: def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(source) for i in range(n): disjoint_set.insert(i) # build the union graph # in each group, the numbers can be placed anywhere for edge in allowedSwaps: disjoint_set.union(edge[0], edge[1]) # hashmap, # group leader -\u003e set[indices in that group] leader_member = {} print(disjoint_set.parents) for member, leader in disjoint_set.parents.items(): # This is the real leader for this member leader = disjoint_set.find(member) if leader in leader_member: leader_member[leader].add(member) else: leader_member[leader] = set([member]) print(leader_member) ret = 0 # for all the members, try to figure out the distance for members in leader_member.values(): source_numbers = [source[i] for i in members] target_numbers = [target[i] for i in members] ret += sum((Counter(source_numbers) - Counter(target_numbers)).values()) return ret ","date":"2021-01-14","objectID":"/leetcode_1722/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To solve this problem, we need to observe that if (0, 1) is exchangeable and (0, 2) is exchangeable, then any pair in (0, 1, 2) can be exchangeble. The remaining problem is how to detect connected components in the graph -\u003e use Union Find. Counter, the subclass of dictionary, supports many great opeartions. ","date":"2021-01-14","objectID":"/leetcode_1722/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Entertainment"],"content":"牛振华三部曲","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/","tags":["Movie Review","Chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Entertainment"],"content":"Stand Up, Don’t Bend Over 1993 Back to Back, Face to Face 1994 Signal Left, Turn Right 1995 闲来无事，写一篇影评，记录一下2021的开始。 偶然的机会看了一部反应中国政治生态的小短篇，之后有评论里提到一部《背靠背，脸对脸》的电影，简单的名字往往藏着不平凡的故事，youtube和b站搜了一下，有版权，随即看了一下。 这三部电影都由牛振华主演，黄建新执导，用幽默的手法反应当时90年代的都市百态、经济生活，政治生态。《背靠背，脸对脸》《站直喽，别趴下》《红灯停绿灯行》合称“都市百态三部曲”。 《背靠背，脸对脸》讲述的是一个文物馆的王双立副馆长，绞尽脑汁想上位一把手的故事。通过王副馆长在其转正过程中一波三折的经历，反应了现代化社会中复杂微妙的人际关系以及错综复杂的政治生态。牛振华饰演的王副馆长是一位有能力，懂得政治手段的领导，难能可贵的是，牛的表演展现了人的复杂性，矛盾性。和当今社会网络中许多线性的人设不同，现实中人的生活是对立统一的，在学会使用矛盾的观点看身边的问题之同时，辩证地理解人性的复杂。以及句兆杰饰演的会计在多次倒戈中体现出“没有永远的盟友，只有永远的利益”这点现实，值得回味。 《站直喽，别趴下》描述了“流氓”张永武（牛振华饰）通过养鱼发家致富，通过自己的努力和敢于拼搏的精神成为那栋楼里最有排面的人。原先看不起张永武的刘干部（达式常饰）和由高作家（冯巩饰）最终在利益的趋势下，像所谓的物质生活低头，改变了对张永武原先“地痞流氓”的标签。电影反应了当时社会“有钱没文化，有文化没钱”，张永武的渔业公司发展壮大后，要求高作家搬出这栋楼，在张永武一系列盘外招的干扰下，高作家连夜搬家，最后高作家蹲在地上收拾东西的镜头，抛出文化人是否向物质低头这个命题。 《红灯停绿灯行》讲述的是学车时发生的一系列故事，　记者苟宇佳（牛振华 饰）、下岗女工程芬（丁嘉丽 饰）、个体户绿豆（王劲松 饰）、大款老差（句号 饰）是驾校1025班的成员，在退伍军人侯教练手下练习。随着时间的推移，大家渐渐摸清彼此的习性。记者小苟八面玲珑，处事圆滑，一心想把学车费报销，结果天不遂人愿；待业女工阿芬被下海的丈夫发来离婚的传票，一人带着女儿，老实度日；早年丧父，母亲瘫痪在床的绿豆沾染上了毒品，白天学车，半夜偷井盖，却是个孝顺儿子；大款老差则是个打着盹儿都能赚上十万、八万的有钱人，不把驾校规定放在眼里；侯教练的教练身份为他带来了免费的香烟和赚回扣的机会，也因此引火烧身，弄得家里鸡犬不宁。 这段驾校生活，波折连连，却都一一化险为夷，5人间的暗战明战也都随着考试的顺利通关而结束。这段驾校的经历牵扯出了5个人的悲喜，除了学到了驾驶规则，似乎更学到了生存法则。credit to 豆瓣 总的来说，这三篇电影风格类似，大致都描述了错综复杂的人际关系和现代化社会的一些拜金主义苗头。人是复杂的而非线性的，生活是矛与盾的结合。网络很容易让人陷入一种单纯的思考状态，认为所有事物都是线性的，贴标签似的理解事情，这样显然很简单，也很容易，但写到这里，也想到百度CEO李彦宏曾对推荐算法有一番说辞，大致描述说推荐算法使得网民失去多样性，在计算了相似度以后，用户喜欢XX就一直推送XX，如果平台一直都是“投其所好”,把用户困在一个圈子里，丧失了获得多样性的机会，也使得很多用户失去了辩证思维。江泽民总书记曾说过 “对现实社会中的问题，我们要进行理性的思考。因为我们看到的现象，其中有的是真相，有的却是假象。只有把感性上升到理性，才能深化认识，才能把握事物的本质。”这几部电影在消遣时间的同时，也敲响了辩证思考的警钟，但从头论，本人也是被推荐算法带进这些电影的，不免有些讽刺。 希望以后思考问题能够深入本质，别太狭隘。 ","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/:0:0","tags":["Movie Review","Chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 547 - Number of Provinces.","date":"2021-01-13","objectID":"/leetcode_547/","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 547 - Number of Provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]] Output: 2 Example2: Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]] Output: 3 ","date":"2021-01-13","objectID":"/leetcode_547/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 class Solution: def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(isConnected) for i in range(n): disjoint_set.insert(i) for i in range(n): for j in range(n): if isConnected[i][j]: disjoint_set.union(i, j) return disjoint_set.num_sets ","date":"2021-01-13","objectID":"/leetcode_547/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To find the connected component in undirected graph, Union Find(Disjoint Set) is the handy data structure to use. ","date":"2021-01-13","objectID":"/leetcode_547/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Data Structure"],"content":"This article reviews union find.","date":"2021-01-12","objectID":"/union_find/","tags":["union find","wi21-week2"],"title":"Union_find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"This article reviews Union Find(Disjoint Set). Union Find | Disjoint Set ","date":"2021-01-12","objectID":"/union_find/:0:0","tags":["union find","wi21-week2"],"title":"Union_find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Semantics This data structure stores the collection of disjoint(non-overlapping) sets(groups). find(p): find the leader of group that contains p union(p, q): merge two groups ","date":"2021-01-12","objectID":"/union_find/:0:1","tags":["union find","wi21-week2"],"title":"Union_find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Implementation class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 ","date":"2021-01-12","objectID":"/union_find/:0:2","tags":["union find","wi21-week2"],"title":"Union_find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Efficienty Analysis O(n) in memory, O(1) for union and look up in amortized analysis ","date":"2021-01-12","objectID":"/union_find/:0:3","tags":["union find","wi21-week2"],"title":"Union_find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Remarks Check whether two elements belong to the same group. To find connected components in graph (usually undirected) Speed up implementation of kruskal’s algorithm ","date":"2021-01-12","objectID":"/union_find/:0:4","tags":["union find","wi21-week2"],"title":"Union_find Review","uri":"/union_find/"},{"categories":null,"content":" Welcome to  Haihao Sun’s field! Self Introduction Haihao SunTravelling \" Travelling Hi there! I am Haihao Sun, and my hobbies come and go. I enjoy travelling, playing Go, playing pokemon, and developing(AKA coding). I was born in Nanjing, and I currently live in San Diego . Skills JavaScript SQL C/C++  Java Python Extended Links Linkedin Blog Version I Github ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Page","uri":"/about/"}]