[{"categories":["interview cheatsheet"],"content":"Synchronizedå’Œlockçš„ä½¿ç”¨åˆ†æ","date":"2021-03-04","objectID":"/synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/","tags":["wi21-week9","interview prep","Java"],"title":"Synchronizedå’Œlockçš„ä½¿ç”¨åˆ†æ","uri":"/synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"Synchronizedå’Œlockçš„ä½¿ç”¨åˆ†æ ","date":"2021-03-04","objectID":"/synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Synchronizedå’Œlockçš„ä½¿ç”¨åˆ†æ","uri":"/synchronized%E5%92%8Clock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"},{"categories":["interview cheatsheet"],"content":"Stringèƒ½å¦è¢«ç»§æ‰¿","date":"2021-03-04","objectID":"/string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/","tags":["wi21-week9","interview prep","Java"],"title":"Stringèƒ½å¦è¢«ç»§æ‰¿","uri":"/string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/"},{"categories":["interview cheatsheet"],"content":"Stringèƒ½å¦è¢«ç»§æ‰¿ æ ¹æ®ç¨‹åºä¸Šä¸‹æ–‡ç¯å¢ƒï¼ŒJavaå…³é”®å­—finalæœ‰â€œè¿™æ˜¯æ— æ³•æ”¹å˜çš„â€æˆ–è€…â€œç»ˆæ€çš„â€å«ä¹‰ï¼Œå®ƒå¯ä»¥ä¿®é¥°éæŠ½è±¡ç±»ã€éæŠ½è±¡ç±»æˆå‘˜æ–¹æ³•å’Œå˜é‡ã€‚ä½ å¯èƒ½å‡ºäºä¸¤ç§ç†è§£è€Œéœ€è¦é˜»æ­¢æ”¹å˜ï¼šè®¾è®¡æˆ–æ•ˆç‡ã€‚ ã€€ finalç±»ä¸èƒ½è¢«ç»§æ‰¿ï¼Œæ²¡æœ‰å­ç±»ï¼Œfinalç±»ä¸­çš„æ–¹æ³•é»˜è®¤æ˜¯finalçš„ã€‚ finalæ–¹æ³•ä¸èƒ½è¢«å­ç±»çš„æ–¹æ³•è¦†ç›–ï¼Œä½†å¯ä»¥è¢«ç»§æ‰¿ã€‚ finalæˆå‘˜å˜é‡è¡¨ç¤ºå¸¸é‡ï¼Œåªèƒ½è¢«èµ‹å€¼ä¸€æ¬¡ï¼Œèµ‹å€¼åå€¼ä¸å†æ”¹å˜ã€‚ finalä¸èƒ½ç”¨äºä¿®é¥°æ„é€ æ–¹æ³•ã€‚ æ³¨æ„ï¼šçˆ¶ç±»çš„privateæˆå‘˜æ–¹æ³•æ˜¯ä¸èƒ½è¢«å­ç±»æ–¹æ³•è¦†ç›–çš„ï¼Œå› æ­¤privateç±»å‹çš„æ–¹æ³•é»˜è®¤æ˜¯finalç±»å‹çš„ã€‚ å¦‚æœä¸€ä¸ªç±»ä¸å…è®¸å…¶å­ç±»è¦†ç›–æŸä¸ªæ–¹æ³•ï¼Œåˆ™å¯ä»¥æŠŠè¿™ä¸ªæ–¹æ³•å£°æ˜ä¸ºfinalæ–¹æ³•ã€‚ ä½¿ç”¨finalæ–¹æ³•çš„åŸå› æœ‰äºŒï¼šã€€ ç¬¬ä¸€ã€æŠŠæ–¹æ³•é”å®šï¼Œé˜²æ­¢ä»»ä½•ç»§æ‰¿ç±»ä¿®æ”¹å®ƒçš„æ„ä¹‰å’Œå®ç°ã€‚ ç¬¬äºŒã€é«˜æ•ˆã€‚ç¼–è¯‘å™¨åœ¨é‡åˆ°è°ƒç”¨finalæ–¹æ³•æ—¶å€™ä¼šè½¬å…¥å†…åµŒæœºåˆ¶ï¼Œå¤§å¤§æé«˜æ‰§è¡Œæ•ˆç‡ã€‚ï¼ˆè¿™ç‚¹æœ‰å¾…å•†æ¦·ï¼Œã€ŠJavaç¼–ç¨‹æ€æƒ³ã€‹ä¸­å¯¹äºè¿™ç‚¹å­˜ç–‘ï¼‰ Javaä¸­ï¼Œæ˜¯å¦å¯ä»¥ç»§æ‰¿Stringç±»ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ ç­”æ¡ˆï¼š ä¸å¯ä»¥ï¼Œå› ä¸ºStringç±»æœ‰finalä¿®é¥°ç¬¦ï¼Œè€Œfinalä¿®é¥°çš„ç±»æ˜¯ä¸èƒ½è¢«ç»§æ‰¿çš„ï¼Œå®ç°ç»†èŠ‚ä¸å…è®¸æ”¹å˜ã€‚ ","date":"2021-03-04","objectID":"/string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Stringèƒ½å¦è¢«ç»§æ‰¿","uri":"/string%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/"},{"categories":["interview cheatsheet"],"content":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³• ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"å¯¹è±¡æ˜¯å¦å¯å›æ”¶ æˆ‘ä»¬è®¨è®ºçš„garbage collectionä¸»è¦æ˜¯å¯¹Javaä¸­å †å†…å­˜çš„å›æ”¶ï¼Œå †é‡Œé¢ä¸»è¦æ”¾çš„å°±æ˜¯å¯¹è±¡ï¼Œé‚£ä¹ˆä¸€ä¸ªå¯¹è±¡æ˜¯å¦èƒ½å›æ”¶æ˜¯å¦‚ä½•è¢«åˆ¤æ–­çš„å‘¢ï¼Ÿ å¼•ç”¨è®¡æ•°æ³• å¯è¾¾æ€§åˆ†æ ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:0","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"å¼•ç”¨è®¡æ•°æ³•ï¼ˆReference Countingï¼‰ å¼•ç”¨è®¡æ•°æ³•ï¼ˆReference Countingï¼‰ï¼šç»™å¯¹è±¡ä¸­æ·»åŠ ä¸€ä¸ªå¼•ç”¨è®¡æ•°å™¨ æ¯å½“æœ‰ä¸€ä¸ªåœ°æ–¹å¼•ç”¨å®ƒæ—¶ï¼Œè®¡æ•°å™¨å°±åŠ 1ï¼›å½“å¼•ç”¨å¤±æ•ˆæ—¶ï¼Œè®¡æ•°å™¨å°±å‡1ï¼›å½“è®¡æ•°å™¨ä¸º0æ—¶å¯¹è±¡å°±æ˜¯ä¸å†è¢«ä½¿ç”¨çš„ã€‚ è¿™ç§æ–¹å¼å®ç°ç®€å•ï¼Œä½†æ˜¯ä¸»æµåƒåœ¾æ”¶é›†å™¨æ²¡æœ‰ç”¨è¿™ç§æ–¹å¼ç®¡ç†å†…å­˜çš„ï¼Œå› ä¸ºè¿™ç§æ–¹å¼å¾ˆéš¾è§£å†³å¾ªç¯ä¾èµ–é—®é¢˜ã€‚ ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:1","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"å¯è¾¾æ€§åˆ†æï¼ˆReachability Analysisï¼‰ å¯è¾¾æ€§åˆ†æï¼ˆReachability Analysisï¼‰ï¼šé€šè¿‡ä¸€ç³»åˆ—çš„ç§°ä¸º â€œGC Rootsâ€ ï¼ˆGCæ ¹ï¼‰çš„å¯¹è±¡ä½œä¸ºèµ·ç‚¹ï¼Œä»è¿™äº›èŠ‚ç‚¹å¼€å§‹å‘ä¸‹æœç´¢ï¼Œæœç´¢æ‰€èµ°è¿‡çš„è·¯å¾„ç§°ä¸ºå¼•ç”¨é“¾ï¼ˆReference Chainï¼‰ï¼Œå½“ä¸€ä¸ªå¯¹è±¡åˆ°GC Rootsæ²¡æœ‰ä»»ä½•å¼•ç”¨é“¾ç›¸è¿ï¼ˆå°±æ˜¯ä»GC Rootsåˆ°å¯¹è±¡ä¸å¯è¾¾ï¼‰æ—¶ï¼Œåˆ™è¯æ˜æ­¤å¯¹è±¡æ˜¯ä¸å¯ç”¨çš„ã€‚ ä¸»æµçš„å¼€å‘è¯­è¨€éƒ½æ˜¯ä½¿ç”¨çš„è¿™ç§æ–¹å¼åˆ¤æ–­å¯¹è±¡æ˜¯å¦å­˜æ´»çš„ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œobject5ï¼Œobject6ï¼Œobject7è™½ç„¶ç›¸äº’å…³è”ï¼Œä½†æ˜¯GC Rootsæ˜¯ä¸å¯è¾¾çš„ï¼Œæ‰€ä»¥è¿™äº›å¯¹è±¡æ˜¯å¯å›æ”¶çš„ã€‚ Javaä¸­å¯è¢«ä½œä¸ºGC Rootçš„å¯¹è±¡ä¸»è¦æœ‰ï¼š è™šæ‹Ÿæœºæ ˆï¼ˆæ ˆå¸§ä¸­çš„æœ¬åœ°å˜é‡è¡¨ï¼‰ä¸­å¼•ç”¨å¯¹è±¡ æ–¹æ³•åŒºä¸­çš„ç±»é™æ€å±æ€§å¼•ç”¨çš„å¯¹è±¡ æ–¹æ³•åŒºä¸­å¸¸é‡å¼•ç”¨çš„å¯¹è±¡ æœ¬åœ°æ–¹æ³•æ ˆJNIçš„å¼•ç”¨å¯¹è±¡ æ¿€æ´»çŠ¶æ€çš„çº¿ç¨‹ æ­£åœ¨è¢«ç”¨äºåŒæ­¥çš„å„ç§é”å¯¹è±¡ Class ç”±ç³»ç»Ÿç±»åŠ è½½å™¨(system class loader)åŠ è½½çš„å¯¹è±¡ï¼Œè¿™äº›ç±»ä¸å¯ä»¥è¢«å›æ”¶ï¼Œä»–ä»¬å¯ä»¥ä»¥é™æ€å­—æ®µçš„æ–¹å¼æŒæœ‰å…¶å®ƒå¯¹è±¡ more about reference ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:2","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"ä»å¯¹è±¡çš„ç”Ÿå­˜åˆ°æ­»äº¡ ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:1:3","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"åƒåœ¾å›æ”¶çš„ç®—æ³• ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:0","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"æ ‡è®°ä¸€æ¸…é™¤ï¼ˆMark-Sweepï¼‰ç®—æ³• ç®—æ³•è®²è¿° æ ‡è®°é˜¶æ®µï¼š é¦–å…ˆæ ‡è®°å¤„æ‰€æœ‰éœ€è¦å›æ”¶çš„å¯¹è±¡ æ¸…é™¤é˜¶æ®µï¼šåœ¨æ ‡è®°åç»Ÿä¸€å›æ”¶æ‰€æœ‰è¢«æ ‡è®°çš„å¯¹è±¡ ä¸è¶³ï¼š æ•ˆç‡é—®é¢˜ï¼Œæ ‡è®°å’Œæ¸…é™¤çš„æ•ˆç‡éƒ½ä¸é«˜ ç©ºé—´é—®é¢˜ï¼Œæ¸…é™¤åä¼šäº§ç”Ÿå¤§é‡ä¸è¿ç»­çš„å†…å­˜ç¢ç‰‡ï¼Œæ— æ³•åˆ†é…ç»™å¤ªå¤§çš„å¯¹è±¡ ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:1","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"â€œå¤åˆ¶â€(Copying)ç®—æ³• ç®—æ³•è®²è¿° â€œå¤åˆ¶â€(Copying)ç®—æ³•ï¼šå®ƒå°†å¯ç”¨å†…å­˜æŒ‰å®¹é‡åˆ’åˆ†ä¸ºå¤§å°ç›¸ç­‰çš„ä¸¤å—ï¼Œæ¯æ¬¡åªä½¿ç”¨å…¶ä¸­çš„ä¸€å—ã€‚å½“è¿™ä¸€å—çš„å†…å­˜ç”¨å®Œäº†ï¼Œå°±å°†è¿˜å­˜æ´»ç€çš„å¯¹è±¡å¤åˆ¶åˆ°å¦å¤–ä¸€å—ä¸Šé¢ã€‚ ç„¶åå†æŠŠå·±ä½¿ç”¨è¿‡çš„å†…å­˜ç©ºé—´ä¸€æ¬¡æ¸…ç†æ‰ã€‚è¿™æ ·ä½¿å¾—æ¯æ¬¡éƒ½æ˜¯å¯¹æ•´ä¸ªåŠåŒºè¿›è¡Œå†…å­˜å›æ”¶ï¼Œå†…å­˜åˆ†é…æ—¶ä¹Ÿå°±ä¸ç”¨è€ƒè™‘å†…å­˜ç¢ç‰‡ç­‰å¤æ‚æƒ…å†µï¼Œåªè¦ç§»åŠ¨å †é¡¶æŒ‡é’ˆï¼ŒæŒ‰é¡ºåºåˆ†é…å†…å­˜å³å¯ï¼Œå®ç°ç®€å•ï¼Œè¿è¡Œé«˜æ•ˆã€‚ ä¸è¶³ï¼š å…¶ç¼ºç‚¹æ˜¯åªèƒ½ç”¨ä¸€åŠå†…å­˜ï¼Œæµªè´¹èµ„æºã€‚ ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:2","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"â€œå¤åˆ¶â€(Copying)ç®—æ³• ç®—æ³•è®²è¿° â€œå¤åˆ¶â€(Copying)ç®—æ³•ï¼šå®ƒå°†å¯ç”¨å†…å­˜æŒ‰å®¹é‡åˆ’åˆ†ä¸ºå¤§å°ç›¸ç­‰çš„ä¸¤å—ï¼Œæ¯æ¬¡åªä½¿ç”¨å…¶ä¸­çš„ä¸€å—ã€‚å½“è¿™ä¸€å—çš„å†…å­˜ç”¨å®Œäº†ï¼Œå°±å°†è¿˜å­˜æ´»ç€çš„å¯¹è±¡å¤åˆ¶åˆ°å¦å¤–ä¸€å—ä¸Šé¢ã€‚ ç„¶åå†æŠŠå·±ä½¿ç”¨è¿‡çš„å†…å­˜ç©ºé—´ä¸€æ¬¡æ¸…ç†æ‰ã€‚è¿™æ ·ä½¿å¾—æ¯æ¬¡éƒ½æ˜¯å¯¹æ•´ä¸ªåŠåŒºè¿›è¡Œå†…å­˜å›æ”¶ï¼Œå†…å­˜åˆ†é…æ—¶ä¹Ÿå°±ä¸ç”¨è€ƒè™‘å†…å­˜ç¢ç‰‡ç­‰å¤æ‚æƒ…å†µï¼Œåªè¦ç§»åŠ¨å †é¡¶æŒ‡é’ˆï¼ŒæŒ‰é¡ºåºåˆ†é…å†…å­˜å³å¯ï¼Œå®ç°ç®€å•ï¼Œè¿è¡Œé«˜æ•ˆã€‚ å¤§éƒ¨åˆ†è™šæ‹Ÿæœºéƒ½æ˜¯é‡‡ç”¨å¤åˆ¶ç®—æ³•å›æ”¶æ–°ç”Ÿä»£çš„ï¼Œç ”ç©¶è¡¨æ˜ï¼Œæ–°ç”Ÿä»£ä¸­çš„å¯¹è±¡98%éƒ½æ˜¯â€œæœç”Ÿå¤•æ­»â€çš„ï¼Œæ‰€ä»¥å¹¶ä¸éœ€è¦æŒ‰ç…§1ï¼š1çš„æ¯”ä¾‹æ¥åˆ’åˆ†å†…å­˜ç©ºé—´ã€‚Javaè™šæ‹Ÿæœºå°†æ–°ç”Ÿä»£å†…å­˜åˆ†ä¸ºä¸€å—è¾ƒå¤§çš„Edenç©ºé—´å’Œä¸¤å—è¾ƒå°çš„Survivorï¼ˆS0å’ŒS1ï¼‰ç©ºé—´ï¼Œæ¯æ¬¡ä½¿ç”¨Edenå’Œå…¶ä¸­ä¸€å—Survivorã€‚å½“å›æ”¶æ—¶ï¼Œå°†Edenå’ŒSurvivorä¸­è¿˜å­˜æ´»ç€çš„å¯¹è±¡ä¸€æ¬¡æ€§åœ°å¤åˆ¶åˆ°å¦å¤–ä¸€å—Survivorç©ºé—´ä¸Šï¼Œæœ€åæ¸…ç†æ‰Edenå’Œåˆšæ‰ç”¨è¿‡çš„Survivorç©ºé—´ã€‚Edenï¼šS0ï¼šS1çš„æ¯”ä¾‹é»˜è®¤æ˜¯8ï¼š1ï¼š1ï¼Œæ¯æ¬¡æ–°ç”Ÿä»£ä¸­å¯ç”¨å†…å­˜ç©ºé—´ä¸ºæ•´ä¸ªæ–°ç”Ÿä»£å®¹é‡çš„90ï¼…ï¼ˆ80ï¼…+10ï¼…)ï¼Œåªæœ‰10ï¼…çš„å†…å­˜ä¼šè¢«â€œæµªè´¹â€ã€‚ä½†æ˜¯ä¸èƒ½ä¿è¯æ¯æ¬¡éƒ½èƒ½å›æ”¶ç™¾åˆ†ä¹‹ä¹åå¤šçš„å¯¹è±¡ï¼Œå½“SurvivoråŒºå†…å­˜ä¸å¤Ÿç”¨æ—¶éœ€è¦ä¾èµ–è€å¹´ä»£è¿›è¡Œåˆ†é…æ‹…ä¿ï¼ˆHandle Promotionï¼‰ï¼Œè¯´ç™½äº†å°±æ˜¯å»è€å¹´ä»£å€Ÿå†…å­˜ç©ºé—´ï¼Œåé¢å†åšä»‹ç»ã€‚ ä¸è¶³ï¼š å…¶ç¼ºç‚¹æ˜¯åªèƒ½ç”¨ä¸€åŠå†…å­˜ï¼Œæµªè´¹èµ„æºã€‚ ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:3","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"æ ‡è®°-æ•´ç†ç®—æ³• (Mark-Compact) åœ¨å›æ”¶è€å¹´ä»£æ—¶å¯èƒ½å›æ”¶åè¿˜æœ‰å¾ˆå¤šå¯¹è±¡å­˜æ´»ï¼Œå¤åˆ¶ç®—æ³•è‚¯å®šæ˜¯ä¸åˆé€‚çš„ï¼Œæ ¹æ®è€å¹´ä»£çš„ç‰¹ç‚¹ï¼Œâ€œæ ‡è®°-æ•´ç†â€ ï¼ˆMark-Compactï¼‰ç®—æ³•å‡ºç°äº†ï¼Œæ ‡è®°è¿‡ç¨‹ä»ç„¶ä¸\"æ ‡è®°ä¸€æ¸…é™¤\"ç®—æ³•ä¸€æ ·ï¼Œä½†åç»­æ­¥éª¤ä¸æ˜¯ç›´æ¥å¯¹å¯å›æ”¶å¯¹è±¡è¿›è¡Œæ¸…ç†ï¼Œè€Œæ˜¯è®©æ‰€æœ‰å­˜æ´»çš„å¯¹è±¡éƒ½å‘ä¸€ç«¯ç§»åŠ¨ï¼Œç„¶åç›´æ¥æ¸…ç†æ‰ç«¯è¾¹ç•Œä»¥å¤–çš„å†…å­˜ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:4","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"åˆ†ä»£æ”¶é›†ç®—æ³• (Generational Collection) åˆ†ä»£æ”¶é›†ï¼ˆGenerational Collectionï¼‰ç®—æ³•æ˜¯æ ¹æ®å¯¹è±¡ç”Ÿå­˜å‘¨æœŸçš„ä¸åŒï¼Œå°†å†…å­˜åˆ’åˆ†ä¸ºå‡ å—ã€‚ Javaå †ä¸­æ˜¯åˆ†ä¸ºæ–°ç”Ÿä»£å’Œè€å¹´ä»£ï¼Œæ–°ç”Ÿä»£å¯¹è±¡æœç”Ÿå¤•æ­»é€‰æ‹©å¤åˆ¶ç®—æ³•ã€‚è€å¹´ä»£å¯¹è±¡å­˜æ´»ç‡é«˜ã€æ²¡æœ‰åˆ†é…æ‹…ä¿ï¼Œå¿…é¡»é‡‡ç”¨æ ‡è®°-æ¸…é™¤æˆ–è€…æ ‡è®°-æ•´ç†ç®—æ³•è¿›è¡Œå›æ”¶ã€‚ ","date":"2021-03-04","objectID":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/:2:5","tags":["wi21-week9","interview prep","Java"],"title":"Javaçš„åƒåœ¾å›æ”¶æœºåˆ¶å’Œå›æ”¶ç®—æ³•æ‘˜æŠ„","uri":"/java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},{"categories":["interview cheatsheet"],"content":"çº¢é»‘æ ‘ä¸AVLæ ‘çš„åŒºåˆ«ä¸è”ç³»ï¼Ÿ","date":"2021-03-04","objectID":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/","tags":["wi21-week9","interview prep","ç®—æ³•"],"title":"çº¢é»‘æ ‘å’ŒAVLæ ‘","uri":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"çº¢é»‘æ ‘ä¸AVLæ ‘çš„åŒºåˆ«ä¸è”ç³»ï¼Ÿ ","date":"2021-03-04","objectID":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:0:0","tags":["wi21-week9","interview prep","ç®—æ³•"],"title":"çº¢é»‘æ ‘å’ŒAVLæ ‘","uri":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"çº¢é»‘æ ‘æ€»ç»“ èŠ‚ç‚¹éƒ½æ˜¯çº¢è‰²æˆ–è€…é»‘è‰² æ ¹ç»“ç‚¹æ˜¯é»‘è‰² æ‰€æœ‰å¶å­ç»“ç‚¹éƒ½æ˜¯é»‘è‰² æ¯ä¸ªçº¢è‰²èŠ‚ç‚¹å¿…é¡»æœ‰ä¸¤ä¸ªé»‘è‰²çš„å¶å­ç»“ç‚¹ ä»ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹åˆ°æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„ç®€å•è·¯å¾„éƒ½åŒ…å«ç›¸åŒæ•°ç›®çš„é»‘è‰²èŠ‚ç‚¹ ","date":"2021-03-04","objectID":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:1:0","tags":["wi21-week9","interview prep","ç®—æ³•"],"title":"çº¢é»‘æ ‘å’ŒAVLæ ‘","uri":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"AVLæ ‘æ€»ç»“ AVLçš„æ¡ä»¶æ˜¯å·¦å³æ ‘çš„é«˜åº¦å·®ä¸èƒ½å¤§äº1ï¼Œå¹¶ä¸”ä»–çš„æ¯ä¸ªå­æ ‘ä¹Ÿéƒ½æ˜¯å¹³è¡¡äºŒå‰æ ‘ å¯¹äºå¹³è¡¡äºŒå‰æ ‘çš„æœ€å°ä¸ªæ•°ï¼Œ n0=0 ; n1=1 ; nk=n(k-1)+n(k-2)+1 ;(æ±‚æ³•å¯ä»¥ç±»æ¯”æ–æ³¢é‚£å¥‘ï¼) ","date":"2021-03-04","objectID":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:2:0","tags":["wi21-week9","interview prep","ç®—æ³•"],"title":"çº¢é»‘æ ‘å’ŒAVLæ ‘","uri":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"çº¢é»‘æ ‘å’ŒAVLæ ‘çš„ç›¸åŒç‚¹ å°±æ’å…¥èŠ‚ç‚¹å¯¼è‡´æ ‘å¤±è¡¡çš„æƒ…å†µï¼ŒAVLå’ŒRB-Treeéƒ½æ˜¯æœ€å¤šä¸¤æ¬¡æ ‘æ—‹è½¬æ¥å®ç°å¤è¡¡rebalanceï¼Œæ—‹è½¬çš„é‡çº§æ˜¯O(1) åˆ é™¤èŠ‚ç‚¹å¯¼è‡´å¤±è¡¡ï¼ŒAVLéœ€è¦ç»´æŠ¤ä»è¢«åˆ é™¤èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹rootè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å¹³è¡¡ï¼Œæ—‹è½¬çš„é‡çº§ä¸ºO(logN)ï¼Œè€ŒRB-Treeæœ€å¤šåªéœ€è¦æ—‹è½¬3æ¬¡å®ç°å¤è¡¡ï¼Œåªéœ€O(1)ï¼Œæ‰€ä»¥è¯´RB-Treeåˆ é™¤èŠ‚ç‚¹çš„rebalanceçš„æ•ˆç‡æ›´é«˜ï¼Œå¼€é”€æ›´å°ï¼ AVLçš„ç»“æ„ç›¸è¾ƒäºRB-Treeæ›´ä¸ºå¹³è¡¡ï¼Œæ’å…¥å’Œåˆ é™¤å¼•èµ·å¤±è¡¡ï¼Œå¦‚2æ‰€è¿°ï¼ŒRB-Treeå¤è¡¡æ•ˆç‡æ›´é«˜ï¼›å½“ç„¶ï¼Œç”±äºAVLé«˜åº¦å¹³è¡¡ï¼Œå› æ­¤AVLçš„Searchæ•ˆç‡æ›´é«˜å•¦ã€‚ çº¢é»‘æ ‘çš„æŸ¥è¯¢æ€§èƒ½ç•¥å¾®é€Šè‰²äºAVLæ ‘ï¼Œå› ä¸ºå…¶æ¯”AVLæ ‘ä¼šç¨å¾®ä¸å¹³è¡¡æœ€å¤šä¸€å±‚ï¼Œä¹Ÿå°±æ˜¯è¯´çº¢é»‘æ ‘çš„æŸ¥è¯¢æ€§èƒ½åªæ¯”ç›¸åŒå†…å®¹çš„AVLæ ‘æœ€å¤šå¤šä¸€æ¬¡æ¯”è¾ƒï¼Œä½†æ˜¯ï¼Œçº¢é»‘æ ‘åœ¨æ’å…¥å’Œåˆ é™¤ä¸Šä¼˜äºAVLæ ‘ï¼ŒAVLæ ‘æ¯æ¬¡æ’å…¥åˆ é™¤ä¼šè¿›è¡Œå¤§é‡çš„å¹³è¡¡åº¦è®¡ç®—ï¼Œè€Œçº¢é»‘æ ‘ä¸ºäº†ç»´æŒçº¢é»‘æ€§è´¨æ‰€åšçš„çº¢é»‘å˜æ¢å’Œæ—‹è½¬çš„å¼€é”€ï¼Œç›¸è¾ƒäºAVLæ ‘ä¸ºäº†ç»´æŒå¹³è¡¡çš„å¼€é”€è¦å°å¾—å¤š æ€»ç»“ï¼šå®é™…åº”ç”¨ä¸­ï¼Œè‹¥æœç´¢çš„æ¬¡æ•°è¿œè¿œå¤§äºæ’å…¥å’Œåˆ é™¤ï¼Œé‚£ä¹ˆé€‰æ‹©AVLï¼Œå¦‚æœæœç´¢ï¼Œæ’å…¥åˆ é™¤æ¬¡æ•°å‡ ä¹å·®ä¸å¤šï¼Œåº”è¯¥é€‰æ‹©RBã€‚ ","date":"2021-03-04","objectID":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/:3:0","tags":["wi21-week9","interview prep","ç®—æ³•"],"title":"çº¢é»‘æ ‘å’ŒAVLæ ‘","uri":"/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/"},{"categories":["interview cheatsheet"],"content":"volatileæœ‰ä½•ä½œç”¨ï¼Ÿvolatileæœ‰ä½•ä½¿ç”¨åœºæ™¯ï¼Ÿvolatileçš„å®ç°åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/","tags":["wi21-week9","interview prep","Java"],"title":"Volatileçš„ä½¿ç”¨åŠå…¶åŸç†","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatileçš„ä½¿ç”¨åŠå…¶åŸç† ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"Volatileçš„ä½¿ç”¨åŠå…¶åŸç†","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"æ‘˜æŠ„ Volatileçš„ä½¿ç”¨åŠå…¶åŸç† ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:0","tags":["wi21-week9","interview prep","Java"],"title":"Volatileçš„ä½¿ç”¨åŠå…¶åŸç†","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatileçš„ä½œç”¨ æˆ‘ä»¬å·²ç»æåˆ°è¿‡å¯è§æ€§ã€æœ‰åºæ€§åŠåŸå­æ€§é—®é¢˜ï¼Œé€šå¸¸æƒ…å†µä¸‹æˆ‘ä»¬å¯ä»¥é€šè¿‡Synchronizedå…³é”®å­—æ¥è§£å†³è¿™äº›ä¸ªé—®é¢˜ï¼Œä¸è¿‡å¦‚æœå¯¹SynchronizedåŸç†æœ‰äº†è§£çš„è¯ï¼Œåº”è¯¥çŸ¥é“Synchronizedæ˜¯ä¸€ä¸ªæ¯”è¾ƒé‡é‡çº§çš„æ“ä½œï¼Œå¯¹ç³»ç»Ÿçš„æ€§èƒ½æœ‰æ¯”è¾ƒå¤§çš„å½±å“ï¼Œæ‰€ä»¥ï¼Œå¦‚æœæœ‰å…¶ä»–è§£å†³æ–¹æ¡ˆï¼Œæˆ‘ä»¬é€šå¸¸éƒ½é¿å…ä½¿ç”¨Synchronizedæ¥è§£å†³é—®é¢˜ã€‚è€Œvolatileå…³é”®å­—å°±æ˜¯Javaä¸­æä¾›çš„å¦ä¸€ç§è§£å†³å¯è§æ€§å’Œæœ‰åºæ€§é—®é¢˜çš„æ–¹æ¡ˆã€‚å¯¹äºåŸå­æ€§ï¼Œéœ€è¦å¼ºè°ƒä¸€ç‚¹ï¼Œä¹Ÿæ˜¯å¤§å®¶å®¹æ˜“è¯¯è§£çš„ä¸€ç‚¹ï¼šå¯¹volatileå˜é‡çš„å•æ¬¡è¯»/å†™æ“ä½œå¯ä»¥ä¿è¯åŸå­æ€§çš„ï¼Œå¦‚longå’Œdoubleç±»å‹å˜é‡ï¼Œä½†æ˜¯å¹¶ä¸èƒ½ä¿è¯i++è¿™ç§æ“ä½œçš„åŸå­æ€§ï¼Œå› ä¸ºæœ¬è´¨ä¸Ši++æ˜¯è¯»ã€å†™ä¸¤æ¬¡æ“ä½œã€‚ ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:1","tags":["wi21-week9","interview prep","Java"],"title":"Volatileçš„ä½¿ç”¨åŠå…¶åŸç†","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatileçš„ä½¿ç”¨ é˜²æ­¢é‡æ’åº ä¸ºä»€ä¹ˆè¦åœ¨å˜é‡singletonä¹‹é—´åŠ ä¸Švolatileå…³é”®å­—ã€‚ å®ä¾‹åŒ–ä¸€ä¸ªå¯¹è±¡å…¶å®å¯ä»¥åˆ†ä¸ºä¸‰ä¸ªæ­¥éª¤ï¼š 1ï¼‰åˆ†é…å†…å­˜ç©ºé—´ã€‚ 2) åˆå§‹åŒ–å¯¹è±¡ã€‚ 3) å°†å†…å­˜ç©ºé—´çš„åœ°å€èµ‹å€¼ç»™å¯¹åº”çš„å¼•ç”¨ã€‚ ä½†æ˜¯ç”±äºæ“ä½œç³»ç»Ÿå¯ä»¥å¯¹æŒ‡ä»¤è¿›è¡Œé‡æ’åºï¼Œæ‰€ä»¥ä¸Šé¢çš„è¿‡ç¨‹ä¹Ÿå¯èƒ½ä¼šå˜æˆå¦‚ä¸‹è¿‡ç¨‹ï¼š 1ï¼‰åˆ†é…å†…å­˜ç©ºé—´ã€‚ 2ï¼‰å°†å†…å­˜ç©ºé—´çš„åœ°å€èµ‹å€¼ç»™å¯¹åº”çš„å¼•ç”¨ã€‚ 3ï¼‰åˆå§‹åŒ–å¯¹è±¡ å®ç°å¯è§æ€§ å¯è§æ€§æ˜¯æŒ‡å½“å¤šä¸ªçº¿ç¨‹è®¿é—®åŒä¸€ä¸ªå˜é‡æ—¶ï¼Œä¸€ä¸ªçº¿ç¨‹ä¿®æ”¹äº†è¿™ä¸ªå˜é‡çš„å€¼ï¼Œå…¶ä»–çº¿ç¨‹èƒ½å¤Ÿç«‹å³çœ‹å¾—åˆ°ä¿®æ”¹çš„å€¼ã€‚ å¯¹äºå¯è§æ€§ï¼ŒJavaæä¾›äº†volatileå…³é”®å­—æ¥ä¿è¯å¯è§æ€§ã€‚å½“ä¸€ä¸ªå…±äº«å˜é‡è¢«volatileä¿®é¥°æ—¶ï¼Œå®ƒä¼šä¿è¯ä¿®æ”¹çš„å€¼ä¼šç«‹å³è¢«æ›´æ–°åˆ°ä¸»å­˜ï¼Œå½“æœ‰å…¶ä»–çº¿ç¨‹éœ€è¦è¯»å–æ—¶ï¼Œå®ƒä¼šå»å†…å­˜ä¸­è¯»å–æ–°å€¼ã€‚è€Œæ™®é€šçš„å…±äº«å˜é‡ä¸èƒ½ä¿è¯å¯è§æ€§ï¼Œå› ä¸ºæ™®é€šå…±äº«å˜é‡è¢«ä¿®æ”¹ä¹‹åï¼Œä»€ä¹ˆæ—¶å€™è¢«å†™å…¥ä¸»å­˜æ˜¯ä¸ç¡®å®šçš„ï¼Œå½“å…¶ä»–çº¿ç¨‹å»è¯»å–æ—¶ï¼Œæ­¤æ—¶å†…å­˜ä¸­å¯èƒ½è¿˜æ˜¯åŸæ¥çš„æ—§å€¼ï¼Œå› æ­¤æ— æ³•ä¿è¯å¯è§æ€§ã€‚ ä¿è¯åŸå­æ€§ åœ¨å•çº¿ç¨‹ç¯å¢ƒä¸‹æˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ•´ä¸ªæ­¥éª¤éƒ½æ˜¯åŸå­æ€§æ“ä½œï¼Œä½†æ˜¯åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹åˆ™ä¸åŒã€‚ Javaåªä¿è¯äº†åŸºæœ¬æ•°æ®ç±»å‹çš„å˜é‡å’Œèµ‹å€¼æ“ä½œæ‰æ˜¯åŸå­æ€§çš„ï¼ˆæ³¨ï¼šåœ¨32ä½çš„JDKç¯å¢ƒä¸‹ï¼Œå¯¹64ä½æ•°æ®çš„è¯»å–ä¸æ˜¯åŸå­æ€§æ“ä½œï¼Œå¦‚longã€doubleï¼‰ã€‚ è¦æƒ³åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä¿è¯åŸå­æ€§ï¼Œåˆ™å¯ä»¥é€šè¿‡é”ã€synchronizedæ¥ç¡®ä¿ã€‚volatileæ˜¯æ— æ³•ä¿è¯å¤åˆæ“ä½œçš„åŸå­æ€§ã€‚ volatileæ˜¯æ— æ³•ä¿è¯è¿™å¤åˆæ“ä½œæ˜¯å…·æœ‰åŸå­æ€§çš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡AtomicIntegeræˆ–è€…Synchronizedæ¥ä¿è¯+1æ“ä½œçš„åŸå­æ€§ã€‚ ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:2","tags":["wi21-week9","interview prep","Java"],"title":"Volatileçš„ä½¿ç”¨åŠå…¶åŸç†","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"Volatileçš„å®ç°åŸç† æœ‰åºæ€§å®ç° é€šä¿—ä¸€ç‚¹è¯´å°±æ˜¯å¦‚æœa happen-before bï¼Œåˆ™aæ‰€åšçš„ä»»ä½•æ“ä½œå¯¹bæ˜¯å¯è§çš„ã€‚ï¼ˆè¿™ä¸€ç‚¹å¤§å®¶åŠ¡å¿…è®°ä½ï¼Œå› ä¸ºhappen-beforeè¿™ä¸ªè¯å®¹æ˜“è¢«è¯¯è§£ä¸ºæ˜¯æ—¶é—´çš„å‰åï¼‰ã€‚æˆ‘ä»¬å†æ¥çœ‹çœ‹JSR 133ä¸­å®šä¹‰äº†å“ªäº›happen-beforeè§„åˆ™ï¼š åŒä¸€ä¸ªçº¿ç¨‹ä¸­çš„ï¼Œå‰é¢çš„æ“ä½œ happen-before åç»­çš„æ“ä½œã€‚ï¼ˆå³å•çº¿ç¨‹å†…æŒ‰ä»£ç é¡ºåºæ‰§è¡Œã€‚ä½†æ˜¯ï¼Œåœ¨ä¸å½±å“åœ¨å•çº¿ç¨‹ç¯å¢ƒæ‰§è¡Œç»“æœçš„å‰æä¸‹ï¼Œç¼–è¯‘å™¨å’Œå¤„ç†å™¨å¯ä»¥è¿›è¡Œé‡æ’åºï¼Œè¿™æ˜¯åˆæ³•çš„ã€‚æ¢å¥è¯è¯´ï¼Œè¿™ä¸€æ˜¯è§„åˆ™æ— æ³•ä¿è¯ç¼–è¯‘é‡æ’å’ŒæŒ‡ä»¤é‡æ’ï¼‰ã€‚ ç›‘è§†å™¨ä¸Šçš„è§£é”æ“ä½œ happen-before å…¶åç»­çš„åŠ é”æ“ä½œã€‚ï¼ˆSynchronized è§„åˆ™ï¼‰ å¯¹volatileå˜é‡çš„å†™æ“ä½œ happen-before åç»­çš„è¯»æ“ä½œã€‚ï¼ˆvolatile è§„åˆ™ï¼‰ çº¿ç¨‹çš„start() æ–¹æ³• happen-before è¯¥çº¿ç¨‹æ‰€æœ‰çš„åç»­æ“ä½œã€‚ï¼ˆçº¿ç¨‹å¯åŠ¨è§„åˆ™ï¼‰ çº¿ç¨‹æ‰€æœ‰çš„æ“ä½œ happen-before å…¶ä»–çº¿ç¨‹åœ¨è¯¥çº¿ç¨‹ä¸Šè°ƒç”¨ join è¿”å›æˆåŠŸåçš„æ“ä½œã€‚ å¦‚æœ a happen-before bï¼Œb happen-before cï¼Œåˆ™a happen-before cï¼ˆä¼ é€’æ€§ï¼‰ã€‚ è¿™é‡Œæˆ‘ä»¬ä¸»è¦çœ‹ä¸‹ç¬¬ä¸‰æ¡ï¼švolatileå˜é‡çš„ä¿è¯æœ‰åºæ€§çš„è§„åˆ™ã€‚ã€ŠJavaå¹¶å‘ç¼–ç¨‹ï¼šæ ¸å¿ƒç†è®ºã€‹ä¸€æ–‡ä¸­æåˆ°è¿‡é‡æ’åºåˆ†ä¸ºç¼–è¯‘å™¨é‡æ’åºå’Œå¤„ç†å™¨é‡æ’åºã€‚ä¸ºäº†å®ç°volatileå†…å­˜è¯­ä¹‰ï¼ŒJMMä¼šå¯¹volatileå˜é‡é™åˆ¶è¿™ä¸¤ç§ç±»å‹çš„é‡æ’åºã€‚ä¸‹é¢æ˜¯JMMé’ˆå¯¹volatileå˜é‡æ‰€è§„å®šçš„é‡æ’åºè§„åˆ™è¡¨ï¼š å¯è§æ€§çš„å®ç° åœ¨å‰æ–‡ä¸­å·²ç»æåŠè¿‡ï¼Œçº¿ç¨‹æœ¬èº«å¹¶ä¸ç›´æ¥ä¸ä¸»å†…å­˜è¿›è¡Œæ•°æ®çš„äº¤äº’ï¼Œè€Œæ˜¯é€šè¿‡çº¿ç¨‹çš„å·¥ä½œå†…å­˜æ¥å®Œæˆç›¸åº”çš„æ“ä½œã€‚è¿™ä¹Ÿæ˜¯å¯¼è‡´çº¿ç¨‹é—´æ•°æ®ä¸å¯è§çš„æœ¬è´¨åŸå› ã€‚å› æ­¤è¦å®ç°volatileå˜é‡çš„å¯è§æ€§ï¼Œç›´æ¥ä»è¿™æ–¹é¢å…¥æ‰‹å³å¯ã€‚å¯¹volatileå˜é‡çš„å†™æ“ä½œä¸æ™®é€šå˜é‡çš„ä¸»è¦åŒºåˆ«æœ‰ä¸¤ç‚¹ï¼š 1ï¼‰ä¿®æ”¹volatileå˜é‡æ—¶ä¼šå¼ºåˆ¶å°†ä¿®æ”¹åçš„å€¼åˆ·æ–°çš„ä¸»å†…å­˜ä¸­ã€‚ 2ï¼‰ä¿®æ”¹volatileå˜é‡åä¼šå¯¼è‡´å…¶ä»–çº¿ç¨‹å·¥ä½œå†…å­˜ä¸­å¯¹åº”çš„å˜é‡å€¼å¤±æ•ˆã€‚å› æ­¤ï¼Œå†è¯»å–è¯¥å˜é‡å€¼çš„æ—¶å€™å°±éœ€è¦é‡æ–°ä»è¯»å–ä¸»å†…å­˜ä¸­çš„å€¼ã€‚é€šè¿‡è¿™ä¸¤ä¸ªæ“ä½œï¼Œå°±å¯ä»¥è§£å†³volatileå˜é‡çš„å¯è§æ€§é—®é¢˜ã€‚ ","date":"2021-03-04","objectID":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/:1:3","tags":["wi21-week9","interview prep","Java"],"title":"Volatileçš„ä½¿ç”¨åŠå…¶åŸç†","uri":"/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"categories":["interview cheatsheet"],"content":"HashMap ä¸ ConcurrentHashMap çš„å®ç°åŸç†æ˜¯æ€æ ·çš„ï¼ŸConcurrentHashMap æ˜¯å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨çš„ï¼Ÿ","date":"2021-03-04","objectID":"/concurrenthashmap%E5%92%8Chashmap/","tags":["wi21-week9","interview prep","Java"],"title":"ConcurrentHashMapæ˜¯å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨çš„","uri":"/concurrenthashmap%E5%92%8Chashmap/"},{"categories":["interview cheatsheet"],"content":"ConcurrentHashMapæ˜¯å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨çš„ ","date":"2021-03-04","objectID":"/concurrenthashmap%E5%92%8Chashmap/:0:0","tags":["wi21-week9","interview prep","Java"],"title":"ConcurrentHashMapæ˜¯å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨çš„","uri":"/concurrenthashmap%E5%92%8Chashmap/"},{"categories":["interview cheatsheet"],"content":"å‚è€ƒ ConcurrentHashMapæ˜¯å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨çš„ HashMapå’ŒHashTableçš„åŒºåˆ« HashTable æ˜¯éå¸¸é«˜æ•ˆç‡çš„æ•°æ®ç»“æ„ï¼Œä½†HashMapå’ŒHashTableåœ¨çº¿ç¨‹çš„ç¯å¢ƒä¸‹ä½¿ç”¨å¹¶ä¸åˆç† HashMap: HashMapæ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„ï¼Œåœ¨å¹¶å‘ç¯å¢ƒä¸‹ï¼Œå¯èƒ½ä¼šå½¢æˆç¯çŠ¶é“¾è¡¨ï¼ˆæ‰©å®¹æ—¶å¯èƒ½é€ æˆï¼Œå…·ä½“åŸå› è‡ªè¡Œç™¾åº¦googleæˆ–æŸ¥çœ‹æºç åˆ†æï¼‰ï¼Œå¯¼è‡´getæ“ä½œæ—¶ï¼Œcpuç©ºè½¬ï¼Œæ‰€ä»¥ï¼Œåœ¨å¹¶å‘ç¯å¢ƒä¸­ä½¿ç”¨HashMapæ˜¯éå¸¸å±é™©çš„ã€‚ HashTable:HashTableå’ŒHashMapçš„å®ç°åŸç†å‡ ä¹ä¸€æ ·ï¼Œå·®åˆ«æ— éæ˜¯1.HashTableä¸å…è®¸keyå’Œvalueä¸ºnullï¼›2.HashTableæ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ä½†æ˜¯HashTableçº¿ç¨‹å®‰å…¨çš„ç­–ç•¥å®ç°ä»£ä»·å´å¤ªå¤§äº†ï¼Œç®€å•ç²—æš´ï¼Œget/putæ‰€æœ‰ç›¸å…³æ“ä½œéƒ½æ˜¯synchronizedçš„ï¼Œè¿™ç›¸å½“äºç»™æ•´ä¸ªå“ˆå¸Œè¡¨åŠ äº†ä¸€æŠŠå¤§é”ï¼Œå¤šçº¿ç¨‹è®¿é—®æ—¶å€™ï¼Œåªè¦æœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®æˆ–æ“ä½œè¯¥å¯¹è±¡ï¼Œé‚£å…¶ä»–çº¿ç¨‹åªèƒ½é˜»å¡ï¼Œç›¸å½“äºå°†æ‰€æœ‰çš„æ“ä½œä¸²è¡ŒåŒ–ï¼Œåœ¨ç«äº‰æ¿€çƒˆçš„å¹¶å‘åœºæ™¯ä¸­æ€§èƒ½å°±ä¼šéå¸¸å·®ã€‚ ä½¿ç”¨ConcurrentHashMapè§£å†³å…¨æ®µé”çš„é—®é¢˜ å’Œ HashMap éå¸¸ç±»ä¼¼ï¼Œå”¯ä¸€çš„åŒºåˆ«å°±æ˜¯å…¶ä¸­çš„æ ¸å¿ƒæ•°æ®å¦‚ value ï¼Œä»¥åŠé“¾è¡¨éƒ½æ˜¯ volatile ä¿®é¥°çš„ï¼Œä¿è¯äº†è·å–æ—¶çš„å¯è§æ€§ã€‚ åŸç†ä¸Šæ¥è¯´ï¼šConcurrentHashMap é‡‡ç”¨äº†åˆ†æ®µé”æŠ€æœ¯ï¼Œå…¶ä¸­ Segment ç»§æ‰¿äº ReentrantLockã€‚ä¸ä¼šåƒ HashTable é‚£æ ·ä¸ç®¡æ˜¯ put è¿˜æ˜¯ get æ“ä½œéƒ½éœ€è¦åšåŒæ­¥å¤„ç†ï¼Œç†è®ºä¸Š ConcurrentHashMap æ”¯æŒ CurrencyLevel (Segment æ•°ç»„æ•°é‡)çš„çº¿ç¨‹å¹¶å‘ã€‚æ¯å½“ä¸€ä¸ªçº¿ç¨‹å ç”¨é”è®¿é—®ä¸€ä¸ª Segment æ—¶ï¼Œä¸ä¼šå½±å“åˆ°å…¶ä»–çš„ Segmentã€‚ 1.7 å¦‚ä½•å®ç°å‘¢ï¼Ÿè¿™å°±ç”¨åˆ°äº†ConcurrentHashMapä¸­æœ€å…³é”®çš„Segmentã€‚ ConcurrentHashMapä¸­ç»´æŠ¤ç€ä¸€ä¸ªSegmentæ•°ç»„ï¼Œæ¯ä¸ªSegmentå¯ä»¥çœ‹åšæ˜¯ä¸€ä¸ªHashMapã€‚ è€ŒSegmentæœ¬èº«ç»§æ‰¿äº†ReentrantLockï¼Œå®ƒæœ¬èº«å°±æ˜¯ä¸€ä¸ªé”ã€‚ åœ¨Segmentä¸­é€šè¿‡HashEntryæ•°ç»„æ¥ç»´æŠ¤å…¶å†…éƒ¨çš„hashè¡¨ã€‚ æ¯ä¸ªHashEntryå°±ä»£è¡¨äº†mapä¸­çš„ä¸€ä¸ªK-Vï¼Œç”¨HashEntryå¯ä»¥ç»„æˆä¸€ä¸ªé“¾è¡¨ç»“æ„ï¼Œé€šè¿‡nextå­—æ®µå¼•ç”¨åˆ°å…¶ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚ PUTçš„æµç¨‹ å°†å½“å‰ Segment ä¸­çš„ table é€šè¿‡ key çš„ hashcode å®šä½åˆ° HashEntryã€‚ éå†è¯¥ HashEntryï¼Œå¦‚æœä¸ä¸ºç©ºåˆ™åˆ¤æ–­ä¼ å…¥çš„ key å’Œå½“å‰éå†çš„ key æ˜¯å¦ç›¸ç­‰ï¼Œç›¸ç­‰åˆ™è¦†ç›–æ—§çš„ valueã€‚ ä¸ä¸ºç©ºåˆ™éœ€è¦æ–°å»ºä¸€ä¸ª HashEntry å¹¶åŠ å…¥åˆ° Segment ä¸­ï¼ŒåŒæ—¶ä¼šå…ˆåˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹ã€‚ æœ€åä¼šè§£é™¤åœ¨ 1 ä¸­æ‰€è·å–å½“å‰ Segment çš„é”ã€‚ GETçš„æµç¨‹ åªéœ€è¦å°† Key é€šè¿‡ Hash ä¹‹åå®šä½åˆ°å…·ä½“çš„ Segment ï¼Œå†é€šè¿‡ä¸€æ¬¡ Hash å®šä½åˆ°å…·ä½“çš„å…ƒç´ ä¸Šã€‚ ç”±äº HashEntry ä¸­çš„ value å±æ€§æ˜¯ç”¨ volatile å…³é”®è¯ä¿®é¥°çš„ï¼Œä¿è¯äº†å†…å­˜å¯è§æ€§ï¼Œæ‰€ä»¥æ¯æ¬¡è·å–æ—¶éƒ½æ˜¯æœ€æ–°å€¼ã€‚ ConcurrentHashMap çš„ get æ–¹æ³•æ˜¯éå¸¸é«˜æ•ˆçš„ï¼Œå› ä¸ºæ•´ä¸ªè¿‡ç¨‹éƒ½ä¸éœ€è¦åŠ é”ã€‚ 1.8 å…¶ä¸­æŠ›å¼ƒäº†åŸæœ‰çš„ Segment åˆ†æ®µé”ï¼Œè€Œé‡‡ç”¨äº† CAS + synchronized æ¥ä¿è¯å¹¶å‘å®‰å…¨æ€§ã€‚ PUTçš„æµç¨‹ æ ¹æ® key è®¡ç®—å‡º hashcodeã€‚ åˆ¤æ–­æ˜¯å¦éœ€è¦è¿›è¡Œåˆå§‹åŒ–ã€‚ f å³ä¸ºå½“å‰ key å®šä½å‡ºçš„ Nodeï¼Œå¦‚æœä¸ºç©ºè¡¨ç¤ºå½“å‰ä½ç½®å¯ä»¥å†™å…¥æ•°æ®ï¼Œåˆ©ç”¨ CAS å°è¯•å†™å…¥ï¼Œå¤±è´¥åˆ™è‡ªæ—‹ä¿è¯æˆåŠŸã€‚ å¦‚æœå½“å‰ä½ç½®çš„ hashcode == MOVED == -1,åˆ™éœ€è¦è¿›è¡Œæ‰©å®¹ã€‚ å¦‚æœéƒ½ä¸æ»¡è¶³ï¼Œåˆ™åˆ©ç”¨ synchronized é”å†™å…¥æ•°æ®ã€‚ å¦‚æœæ•°é‡å¤§äº TREEIFY_THRESHOLD åˆ™è¦è½¬æ¢ä¸ºçº¢é»‘æ ‘ã€‚ GETçš„æµç¨‹ æ ¹æ®è®¡ç®—å‡ºæ¥çš„ hashcode å¯»å€ï¼Œå¦‚æœå°±åœ¨æ¡¶ä¸Šé‚£ä¹ˆç›´æ¥è¿”å›å€¼ã€‚ å¦‚æœæ˜¯çº¢é»‘æ ‘é‚£å°±æŒ‰ç…§æ ‘çš„æ–¹å¼è·å–å€¼ï¼Œè‹¥ä¸æ»¡è¶³é‚£å°±æŒ‰ç…§é“¾è¡¨çš„æ–¹å¼éå†è·å–å€¼ã€‚ å¸¸è§å…³äº HashMap || ConcurrentHashMap çš„é—®é¢˜æ•´ç† è°ˆè°ˆä½ ç†è§£çš„ HashMapï¼Œè®²è®²å…¶ä¸­çš„ get put è¿‡ç¨‹ã€‚ 1.8 åšäº†ä»€ä¹ˆä¼˜åŒ–ï¼Ÿ æ˜¯çº¿ç¨‹å®‰å…¨çš„å˜›ï¼Ÿ ä¸å®‰å…¨ä¼šå¯¼è‡´å“ªäº›é—®é¢˜ï¼Ÿ å¦‚ä½•è§£å†³ï¼Ÿæœ‰æ²¡æœ‰çº¿ç¨‹å®‰å…¨çš„å¹¶å‘å®¹å™¨ï¼Ÿ ConcurrentHashMap æ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿ 1.7ã€1.8 å®ç°æœ‰ä½•ä¸åŒï¼Ÿä¸ºä»€ä¹ˆè¿™ä¹ˆåšï¼Ÿ ","date":"2021-03-04","objectID":"/concurrenthashmap%E5%92%8Chashmap/:0:1","tags":["wi21-week9","interview prep","Java"],"title":"ConcurrentHashMapæ˜¯å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨çš„","uri":"/concurrenthashmap%E5%92%8Chashmap/"},{"categories":["interview cheatsheet"],"content":"ä¸­å›½é¢è¯•å…«è‚¡æ–‡èƒŒè¯µé“¾æ¥","date":"2021-03-03","objectID":"/eight_legged_essay/","tags":["wi21-week9","interview prep"],"title":"Eight_legged_essay","uri":"/eight_legged_essay/"},{"categories":["interview cheatsheet"],"content":"æ–‡ç« é“¾æ¥æ€»ç»“ https://blog.csdn.net/huangqili1314/article/details/79448187 https://github.com/Moosphan/Android-Daily-Interview https://osjobs.net/topk/ ","date":"2021-03-03","objectID":"/eight_legged_essay/:0:1","tags":["wi21-week9","interview prep"],"title":"Eight_legged_essay","uri":"/eight_legged_essay/"},{"categories":["Leetcode Problem"],"content":"New BFS to solve Leetcode 786 - K-th Smallest Prime Fraction ","date":"2021-02-22","objectID":"/leetcode_786/:0:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 786 You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k. For every i and j where 0 \u003c= i \u003c j \u003c arr.length, we consider the fraction arr[i] / arr[j]. Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j]. ","date":"2021-02-22","objectID":"/leetcode_786/:1:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Example Test Cases Leetcode 786 Example1: Input: arr = [1,2,3,5], k = 3 Output: [2,5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3. The third fraction is 2/5. ","date":"2021-02-22","objectID":"/leetcode_786/:2:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 786 // BFS vector\u003cint\u003e global_arr; class Node { public: int denominator; int numerator; double val; Node(int de, int nu){ this -\u003e denominator = de; this -\u003e numerator = nu; this -\u003e val = (double)global_arr[nu] / global_arr[de]; } }; class Compare { public: bool operator() (Node\u0026 n1, Node\u0026 n2) { return n1.val \u003e n2.val; } }; class Solution { public: vector\u003cint\u003e kthSmallestPrimeFraction(vector\u003cint\u003e\u0026 arr, int k) { global_arr.clear(); for(int i : arr){ global_arr.push_back(i); } std::priority_queue\u003cNode, std::vector\u003cNode\u003e, Compare\u003e pq; for(int i = 1; i \u003c arr.size(); i++){ Node cur(i, 0); pq.push(cur); } for(int i = 0; i \u003c k - 1; ++i){ // cout \u003c\u003c pq.top().numerator \u003c\u003c \" \" \u003c\u003c pq.top().denominator \u003c\u003c endl; Node cur = pq.top(); pq.pop(); if(cur.numerator == cur.denominator - 1){ continue; } else{ cur.numerator += 1; cur.val = (double)global_arr[cur.numerator] / global_arr[cur.denominator]; pq.push(cur); } } // cout \u003c\u003c global_arr[pq.top().numerator] \u003c\u003c \" \" \u003c\u003c global_arr[pq.top().denominator]; vector\u003cint\u003e ret{global_arr[pq.top().numerator], global_arr[pq.top().denominator]}; return ret; } }; ","date":"2021-02-22","objectID":"/leetcode_786/:3:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Leetcode 786 Using Heap O(k * log(n)) solution ","date":"2021-02-22","objectID":"/leetcode_786/:4:0","tags":["wi21-week8","heap"],"title":"Leetcode 786 - K-th Smallest Prime Fraction","uri":"/leetcode_786/"},{"categories":["Leetcode Problem"],"content":"New BFS to solve Leetcode 1091 - Shortest Path in Binary Matrix. ","date":"2021-02-10","objectID":"/leetcode_1091/:0:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 1091 In an N by N square grid, each cell is either empty (0) or blocked (1). A clear path from top-left to bottom-right has length k if and only if it is composed of cells C_1, C_2, â€¦, C_k such that: Adjacent cells C_i and C_{i+1} are connected 8-directionally (ie., they are different and share an edge or corner) C_1 is at location (0, 0) (ie. has value grid[0][0]) C_k is at location (N-1, N-1) (ie. has value grid[N-1][N-1]) If C_i is located at (r, c), then grid[r][c] is empty (ie. grid[r][c] == 0). Return the length of the shortest such clear path from top-left to bottom-right. If such a path does not exist, return -1. ","date":"2021-02-10","objectID":"/leetcode_1091/:1:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Example Test Cases Leetcode 1091 Example1: Input: [[0,1],[1,0]] Output: 2 ","date":"2021-02-10","objectID":"/leetcode_1091/:2:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 1091 // BFS class Solution { public: int shortestPathBinaryMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { if(grid[0][0] == 1){ return -1; } deque\u003cint\u003e q; set\u003cint\u003e seen; int m = grid.size(), n = grid[0].size(); int step = 1; seen.insert(0); q.push_back(0); while(q.size()){ int width = q.size(); for(int i = 0; i \u003c width; ++i){ int p = q.front(); q.pop_front(); int r = p / n, c = p % n; if(r == m - 1 \u0026\u0026 c == n -1){ return step; } for(int j = -1; j \u003c= 1; j++){ for(int k = -1; k \u003c= 1; k++){ if(j == 0 \u0026\u0026 k == 0){ continue; } else{ int nr = r + j, nc = c + k; int np = nr * n + nc; if(nr \u003e= 0 \u0026\u0026 nr \u003c m \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n \u0026\u0026 seen.find(np) == seen.end() \u0026\u0026 grid[nr][nc] == 0){ seen.insert(np); q.push_back(np); } } } } } step += 1; } return -1; } }; ","date":"2021-02-10","objectID":"/leetcode_1091/:3:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Leetcode 1091 Dimension Reduction + 8 direction loop O(m*n) solution ","date":"2021-02-10","objectID":"/leetcode_1091/:4:0","tags":["wi21-week6","bfs"],"title":"Leetcode 1091 - Shortest Path in Binary Matrix","uri":"/leetcode_1091/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 284 - Peeking Iterator","date":"2021-02-08","objectID":"/leetcode_284/","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"New Idea to solve Leetcode 284 - Peeking Iterator. ","date":"2021-02-08","objectID":"/leetcode_284/:0:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 284 Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next(). ","date":"2021-02-08","objectID":"/leetcode_284/:1:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Example Test Cases Leetcode 284 Example1: Assume that the iterator is initialized to the beginning of the list: [1,2,3]. Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2. You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false. ","date":"2021-02-08","objectID":"/leetcode_284/:2:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 284 # Below is the interface for Iterator, which is already defined for you. # # class Iterator: # def __init__(self, nums): # \"\"\" # Initializes an iterator object to the beginning of a list. # :type nums: List[int] # \"\"\" # # def hasNext(self): # \"\"\" # Returns true if the iteration has more elements. # :rtype: bool # \"\"\" # # def next(self): # \"\"\" # Returns the next element in the iteration. # :rtype: int # \"\"\" class PeekingIterator: def __init__(self, iterator): \"\"\" Initialize your data structure here. :type iterator: Iterator \"\"\" self.isCalled = False self.ret = 0 self.it = iterator def peek(self): \"\"\" Returns the next element in the iteration without advancing the iterator. :rtype: int \"\"\" if(self.isCalled): return self.ret else: self.ret = self.it.next() self.isCalled = True return self.ret def next(self): \"\"\" :rtype: int \"\"\" if(self.isCalled): self.isCalled = False return self.ret else: return self.it.next() def hasNext(self): \"\"\" :rtype: bool \"\"\" return self.it.hasNext() or self.isCalled # Your PeekingIterator object will be instantiated and called as such: # iter = PeekingIterator(Iterator(nums)) # while iter.hasNext(): # val = iter.peek() # Get the next element but not advance the iterator. # iter.next() # Should return the same value as [val]. ","date":"2021-02-08","objectID":"/leetcode_284/:3:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Leetcode 284 peek will differ at most one with the actual iterator, therefore use a boolean to remember diff or not O(1) solution ","date":"2021-02-08","objectID":"/leetcode_284/:4:0","tags":["wi21-week6","idea","data structure"],"title":"Leetcode 284 - Peeking Iterator","uri":"/leetcode_284/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 638 - Shopping Offers","date":"2021-02-04","objectID":"/leetcode_638/","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Use Dynamic Programming to solve Leetcode 638 - Shopping Offers. ","date":"2021-02-04","objectID":"/leetcode_638/:0:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 638 In LeetCode Store, there are some kinds of items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. You are given the each itemâ€™s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer. You could use any of special offers as many times as you want. ","date":"2021-02-04","objectID":"/leetcode_638/:1:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 638 Example1: Input: [2,5], [[3,0,5],[1,2,10]], [3,2] Output: 14 Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B. You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A. Example2: Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] Output: 11 Explanation: The price of A is $2, and $3 for B, $4 for C. You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. You cannot add more items, though only $9 for 2A ,2B and 1C. ","date":"2021-02-04","objectID":"/leetcode_638/:2:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 638 class Solution { public: unordered_map\u003cstring, int\u003e cache; vector\u003cint\u003e _p; vector\u003cvector\u003cint\u003e\u003e _s; string vector2str(vector\u003cint\u003e\u0026 num){ vector\u003cchar\u003e v; for(int i = 0; i \u003c num.size(); ++i){ v.push_back('a' + num[i]); } string s(v.begin(), v.end()); return s; } int helper(vector\u003cint\u003e\u0026 state){ string s = vector2str(state); if(cache.find(s) != cache.end()){ return cache[s]; } int ret = 0; for(int i = 0; i \u003c state.size(); ++i){ ret += (state[i] * _p[i]); } for(int i = 0; i \u003c _s.size(); ++i){ vector\u003cint\u003e ns = state; int j; for(j = 0; j \u003c _s[i].size() - 1; j++){ ns[j] -= _s[i][j]; if(ns[j] \u003c 0){ break; } } if(j == _s[i].size() - 1){ ret = min(ret, _s[i][j] + helper(ns)); } } return cache[vector2str(state)] = ret; } int shoppingOffers(vector\u003cint\u003e\u0026 price, vector\u003cvector\u003cint\u003e\u003e\u0026 special, vector\u003cint\u003e\u0026 needs) { _p = price; _s = special; vector\u003cint\u003e startState(needs.size(), 0); cache[vector2str(startState)] = 0; return helper(needs); } }; ","date":"2021-02-04","objectID":"/leetcode_638/:3:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Recursion + Memorization Top Down, and We can simply try to buy all the items by the original price as the starting ret to compare later. ","date":"2021-02-04","objectID":"/leetcode_638/:4:0","tags":["recursion","wi21-week5"],"title":"Leetcode_638 Shopping Offers","uri":"/leetcode_638/"},{"categories":["cpp cheatsheet"],"content":"cpp handy reference","date":"2021-02-03","objectID":"/cpp_handy_1/","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"cpp cheatsheet 1. ","date":"2021-02-03","objectID":"/cpp_handy_1/:0:0","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"Binary Search related library function lower_bound upper_bound binary_search (beginIterator, endInterator, val) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:0","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"lower_bound lower_bound(beginIterator, endInterator, target) Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val. greater than or equal to the target if no elements satisfies the condition, simply return the endInterator(out of bound) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:1","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"upper_bound upper_bound(beginIterator, endInterator, target)s Returns an iterator pointing to the first element in the range [first,last) which compares greater than val. strictly greater than the target if no element satisfies the condition, simply return the endInterator(out of bound) ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:2","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["cpp cheatsheet"],"content":"binary_search binary_search(beginIterator, endInterator, val) true if exist, false otherwise. int main() { vector\u003cint\u003e _v; for(int i = 0; i \u003c 5; i++){ _v.push_back(i); _v.push_back(i + 3); } // must be sorted in increasing order // note that rbegin, rend, reverse order is not allowed sort(_v.begin(), _v.end()); cout \u003c\u003c lower_bound(_v.begin(), _v.end(), 4) - _v.begin() \u003c\u003c '\\n'; return 0; } ","date":"2021-02-03","objectID":"/cpp_handy_1/:1:3","tags":["wi21-week5","binary search"],"title":"cpp cheatsheet - upper_bound and lower_bound","uri":"/cpp_handy_1/"},{"categories":["codeforce"],"content":"codeforce 1","date":"2021-02-03","objectID":"/codeforce_1/","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"codeforce 1475D, share my solution for these this codeforce problem. ","date":"2021-02-03","objectID":"/codeforce_1/:0:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Description D. Cleaning the Phone ","date":"2021-02-03","objectID":"/codeforce_1/:1:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Introduction D. Cleaning the Phone Polycarp often uses his smartphone. He has already installed ğ‘› applications on it. Application with number ğ‘– takes up ğ‘ğ‘– units of memory. Polycarp wants to free at least ğ‘š units of memory (by removing some applications). Of course, some applications are more important to Polycarp than others. He came up with the following scoring system â€” he assigned an integer ğ‘ğ‘– to each application: ğ‘ğ‘–=1 â€” regular application; ğ‘ğ‘–=2 â€” important application. According to this rating system, his phone has ğ‘1+ğ‘2+â€¦+ğ‘ğ‘› convenience points. Polycarp believes that if he removes applications with numbers ğ‘–1,ğ‘–2,â€¦,ğ‘–ğ‘˜, then he will free ğ‘ğ‘–1+ğ‘ğ‘–2+â€¦+ğ‘ğ‘–ğ‘˜ units of memory and lose ğ‘ğ‘–1+ğ‘ğ‘–2+â€¦+ğ‘ğ‘–ğ‘˜ convenience points. For example, if ğ‘›=5, ğ‘š=7, ğ‘=[5,3,2,1,4], ğ‘=[2,1,1,2,1], then Polycarp can uninstall the following application sets (not all options are listed below): applications with numbers 1,4 and 5. In this case, it will free ğ‘1+ğ‘4+ğ‘5=10 units of memory and lose ğ‘1+ğ‘4+ğ‘5=5 convenience points; applications with numbers 1 and 3. In this case, it will free ğ‘1+ğ‘3=7 units of memory and lose ğ‘1+ğ‘3=3 convenience points. applications with numbers 2 and 5. In this case, it will free ğ‘2+ğ‘5=7 memory units and lose ğ‘2+ğ‘5=2 convenience points. Help Polycarp, choose a set of applications, such that if removing them will free at least ğ‘š units of memory and lose the minimum number of convenience points, or indicate that such a set does not exist. ","date":"2021-02-03","objectID":"/codeforce_1/:1:1","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Input D. Cleaning the Phone Input The first line contains one integer ğ‘¡ (1â‰¤ğ‘¡â‰¤104) â€” the number of test cases. Then ğ‘¡ test cases follow. The first line of each test case contains two integers ğ‘› and ğ‘š (1â‰¤ğ‘›â‰¤2â‹…105, 1â‰¤ğ‘šâ‰¤109) â€” the number of applications on Polycarpâ€™s phone and the number of memory units to be freed. The second line of each test case contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤109) â€” the number of memory units used by applications. The third line of each test case contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤2) â€” the convenience points of each application. It is guaranteed that the sum of ğ‘› over all test cases does not exceed 2â‹…105. ","date":"2021-02-03","objectID":"/codeforce_1/:1:2","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Output D. Cleaning the Phone Output For each test case, output on a separate line: -1, if there is no set of applications, removing which will free at least ğ‘š units of memory; the minimum number of convenience points that Polycarp will lose if such a set exists. ","date":"2021-02-03","objectID":"/codeforce_1/:1:3","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Example Input \u0026 Output D. Cleaning the Phone 5 5 7 5 3 2 1 4 2 1 1 2 1 1 3 2 1 5 10 2 3 2 3 2 1 2 1 2 1 4 10 5 1 3 4 1 2 1 2 4 5 3 2 1 2 2 1 2 1 2 -1 6 4 3 ","date":"2021-02-03","objectID":"/codeforce_1/:1:4","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Example Explanation D. Cleaning the Phone In the first test case, it is optimal to remove applications with numbers 2 and 5, freeing 7 units of memory. ğ‘2+ğ‘5=2. In the second test case, by removing the only application, Polycarp will be able to clear only 2 of memory units out of the 3 needed. In the third test case, it is optimal to remove applications with numbers 1, 2, 3 and 4, freeing 10 units of memory. ğ‘1+ğ‘2+ğ‘3+ğ‘4=6. In the fourth test case, it is optimal to remove applications with numbers 1, 3 and 4, freeing 12 units of memory. ğ‘1+ğ‘3+ğ‘4=4. In the fifth test case, it is optimal to remove applications with numbers 1 and 2, freeing 5 units of memory. ğ‘1+ğ‘2=3. ","date":"2021-02-03","objectID":"/codeforce_1/:1:5","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Solution D. Cleaning the Phone #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long int main() { int n; cin \u003e\u003e n; vector\u003cll\u003e ret; for(int i = 0; i \u003c n; i+=1){ int m, needed; cin \u003e\u003e m \u003e\u003e needed; vector\u003cll\u003e a(m + 1, 0); vector\u003cint\u003e b(m + 1, 0); vector\u003cll\u003e _1; vector\u003cll\u003e _2; ll sum = 0; for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e a[i]; sum += a[i]; } for(int i = 1; i \u003c= m; i++){ cin \u003e\u003e b[i]; if(b[i] == 1){ _1.push_back(a[i]); } else{ _2.push_back(a[i]); } } if(sum\u003cneeded) { ret.push_back(-1); continue; } sort(_1.rbegin(), _1.rend()); sort(_2.rbegin(), _2.rend()); vector\u003cll\u003e _pre2; _pre2.push_back(0); for(int i = 0; i \u003c _2.size(); i++){ _pre2.push_back(_pre2[i] + _2[i]); } int len=_pre2.size(); sum=0; ll ans=1e18; int cur=lower_bound(_pre2.begin(),_pre2.end(),needed)-_pre2.begin(); // if cur == len, it means that no element inside the _pre2 \u003e= needed if(cur!=len) { ans=cur*2; } for(int i = 0; i \u003c _1.size(); i++){ sum += _1[i]; if(needed \u003c 0){ ans = min(ans, 1ll + i + 1); break; } int point = needed - sum; int cur=lower_bound(_pre2.begin(),_pre2.end(),point)-_pre2.begin(); if(cur != len){ ans = min(ans, i + 1 + 2 * 1ll * cur); } } ret.push_back(ans); } for(int i : ret){ cout \u003c\u003c i \u003c\u003c '\\n'; } return 0; } ","date":"2021-02-03","objectID":"/codeforce_1/:2:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["codeforce"],"content":"Problem Remark D. Cleaning the Phone Implicit Binary Search Idea is computing the prefix sum and set the pointer at application with importance 1, and then do binary search to find the lower_bound for the application with importance of 2 ","date":"2021-02-03","objectID":"/codeforce_1/:3:0","tags":["wi21-week5","binary search","idea"],"title":"codeforce 1475D","uri":"/codeforce_1/"},{"categories":["OJ Problem"],"content":"OJ 5","date":"2021-02-02","objectID":"/coding_practice_5/","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"OJ Practice 5, share my solutions for these three OJ problems during the UCSD ICPC Selection Contest. ","date":"2021-02-02","objectID":"/coding_practice_5/:0:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Methodic Multiplication #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; int countS(string s){ int ret = 0; for(int i = 0; i \u003c s.length(); i++){ if(s[i] == 'S'){ ret += 1; } } return ret; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; if(s1 == \"0\"){ cout \u003c\u003c \"0\"; } else if(s2 == \"0\"){ cout \u003c\u003c \"0\"; } else{ int count1 = countS(s1), count2 = countS(s2); int ret = count1 * count2; int idx = 0; vector\u003cchar\u003e resultS; for(int i = 0; i \u003c ret; i++){ resultS.push_back('S'); resultS.push_back('('); } resultS.push_back('0'); for(int i = 0; i \u003c ret; i++){ resultS.push_back(')'); } string retS(resultS.begin(), resultS.end()); cout \u003c\u003c retS; } return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:1:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Dams in Distress #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; /* 4 75 0 100 50 1 49 10 1 50 0 3 50 48 */ int main() { ll n, t; cin \u003e\u003e n \u003e\u003e t; unordered_map\u003cint, vector\u003cint\u003e\u003e graph; vector\u003cll\u003e needed(n + 1, 0); vector\u003cll\u003e require(n + 1, 0); vector\u003cll\u003e current(n + 1, 0); // the first one need t amount of water needed[0] = t; require[0] = t; for(int i = 1; i \u003c= n; i++){ int d, c, u; cin \u003e\u003e d \u003e\u003e c \u003e\u003e u; // from parent to child if(graph.find(d) == graph.end()){ graph[d] = vector\u003cint\u003e {i}; } else{ graph[d].push_back(i); } require[i] = c; current[i] = u; } deque\u003cint\u003e q; q.push_back(0); while(q.size()){ int p = q.front(); q.pop_front(); if(graph.find(p) != graph.end()){ for(int np : graph[p]){ ll cur_n = max(needed[p], require[np]) - current[np]; needed[np] = cur_n; q.push_back(np); } } } ll min_amount = LLONG_MAX; for(int i = 0; i \u003c= n; i++){ min_amount = min(min_amount, needed[i]); } cout \u003c\u003c min_amount; /*TLE solution ll min_amount = LLONG_MAX; for(int i = 0; i \u003c= n; i++){ ll needed = require[i] - current[i]; ll carry = require[i]; int idx = i; while(idx != 0){ int next_level = parent[idx]; if(carry + current[next_level] \u003c require[next_level]){ break; } else{ carry = carry + current[next_level]; idx = parent[idx]; } } if(idx == 0){ min_amount = min(min_amount, needed); } } cout \u003c\u003c min_amount; */ return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:2:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Solution to Array of Discord #include \u003ccstdio\u003e#include \u003calgorithm\u003e#define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 using namespace std; /* 3 2020 2020 2020 */ /* 4 1 42 4711 9876 */ ll magicSmall(ll num){ if(num \u003c 10){ return 0; } else{ string s = to_string(num); // if the first digit is not 1, we change it to 1, and return it. if(s[0] != '1'){ s[0] = '1'; return stoll(s); } // if the first digit is 1, we find the first non-zero, and change it to zero else{ for(int i = 1; i \u003c s.length(); i+=1){ if(s[i] != '0'){ s[i] = '0'; return stoll(s); } } } } return num; } ll magicBig(ll num){ if(num \u003c 10){ return 9; } else{ string s = to_string(num); if(s[0] != '9'){ s[0] = '9'; return stoll(s); } // find the first non-9, and change it to 9 else{ for(int i = 1; i \u003c s.length(); i+=1){ if(s[i] != '9'){ s[i] = '9'; return stoll(s); } } } } return num; } int main() { int n; cin \u003e\u003e n; vector\u003cll\u003e nums(n, 0); for(int i = 0; i \u003c n; i++){ ll num; cin \u003e\u003e num; nums[i] = num; } // either make left bigger, scan from the left to right, if the changed number is biggr than the one on the right, // we can return the array of numers for(int i = 0; i \u003c nums.size() - 1; i++){ if(magicBig(nums[i]) \u003e nums[i+1]){ nums[i] = magicBig(nums[i]); for(ll i : nums){ cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } } // or make right smaller, scan from right to left, if the changed number is smaller than the one on the left, // return the array of numbers for(int i = nums.size() - 1; i \u003e= 1; i--){ if(magicSmall(nums[i]) \u003c nums[i - 1]){ nums[i] = magicSmall(nums[i]); for(ll i : nums){ cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } } cout \u003c\u003c \"impossible\"; return 0; } ","date":"2021-02-02","objectID":"/coding_practice_5/:3:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"Problem Remark to Array of Discord Just use stoll, do not mess up with the overflow ","date":"2021-02-02","objectID":"/coding_practice_5/:4:0","tags":["wi21-week5"],"title":"OJ Practice 5","uri":"/coding_practice_5/"},{"categories":["OJ Problem"],"content":"OJ 4","date":"2021-01-29","objectID":"/coding_practice_4/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"OJ Practice 4, share my solutions for these three OJ problems. ","date":"2021-01-29","objectID":"/coding_practice_4/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"[NCPC 2011 Problem A: Car Trouble] #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* 6 0 1 1 1 1 2 2 3 1 3 0 3 0 4 2 5 0 5 1 4 */ set\u003cint\u003e solve(unordered_map\u003cint, vector\u003cint\u003e\u003e\u0026 graph){ set\u003cint\u003e seen; if (graph.find(0) == graph.end()){ return seen; } deque\u003cint\u003e q; q.push_back(0); while(q.size()){ int cur = q.front(); q.pop_front(); seen.insert(cur); for(int j = 0; j \u003c graph[cur].size(); ++j){ if(seen.find(graph[cur][j]) == seen.end()){ seen.insert(graph[cur][j]); q.push_back(graph[cur][j]); } } } return seen; } int main() { int m, f, t, n; unordered_map\u003cint, vector\u003cint\u003e\u003e graph; unordered_map\u003cint, vector\u003cint\u003e\u003e reverse_graph; vector\u003cint\u003e all_road; cin \u003e\u003e m; for(int i = 0; i \u003c m; i++){ cin \u003e\u003e f; cin \u003e\u003e n; all_road.push_back(f); if(reverse_graph.find(t) == reverse_graph.end()){ reverse_graph[f] = vector\u003cint\u003e{}; } if(graph.find(f) == graph.end()){ graph[f] = vector\u003cint\u003e{}; } for(int j = 0; j \u003c n; j++){ cin \u003e\u003e t; graph[f].push_back(t); reverse_graph[t].push_back(f); } } // UNREACHABLE vector\u003cint\u003e unreachable; // TRAPPED vector\u003cint\u003e trapped; set\u003cint\u003e not_trapped = solve(reverse_graph); set\u003cint\u003e not_unreachable = solve(graph); for(int i : all_road){ if(not_unreachable.find(i) == not_unreachable.end()){ unreachable.push_back(i); } if(not_trapped.find(i) == not_trapped.end()){ trapped.push_back(i); } } if(trapped.size() == 0 \u0026\u0026 unreachable.size() == 0){ cout \u003c\u003c \"NO PROBLEMS\"; return 0; } else{ for(int i : trapped){ cout \u003c\u003c \"TRAPPED \" \u003c\u003c i \u003c\u003c endl; } for(int i : unreachable){ cout \u003c\u003c \"UNREACHABLE \" \u003c\u003c i \u003c\u003c endl; } } return 0; } ","date":"2021-01-29","objectID":"/coding_practice_4/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"NCPC 2015â€‹ Goblin Garden Guards #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* 5 0 0 100 0 0 100 100 100 50 50 1 0 0 50 */ int main() { int n, m; cin \u003e\u003e n; int x, y, r; vector\u003ctuple\u003cint, int\u003e\u003e g; vector\u003ctuple\u003cint, int, int\u003e\u003e s; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e x \u003e\u003e y; g.push_back(make_tuple(x, y)); } cin \u003e\u003e m; for (int i = 0; i \u003c m; i++) { cin \u003e\u003e x \u003e\u003e y \u003e\u003e r; s.push_back(make_tuple(x, y, r)); } vector\u003cvector\u003cbool\u003e\u003e board(10000 + 5, vector\u003cbool\u003e(10000 + 5, true)); /*TLE SOLUTION int ret = 0; for(int i = 0; i \u003c n; i++){ bool flag = true; int g_x = get\u003c0\u003e(g[i]), g_y = get\u003c1\u003e(g[i]); for(int j = 0; j \u003c m; j++){ int s_x = get\u003c0\u003e(s[j]), s_y = get\u003c1\u003e(s[j]), s_r = get\u003c2\u003e(s[j]); if( pow((g_x - s_x), 2) + pow((g_y - s_y), 2) \u003c= pow(s_r, 2)){ flag = false; break; } } if(flag){ ret += 1; } } */ for (int j = 0; j \u003c m; j++) { int s_x = get\u003c0\u003e(s[j]), s_y = get\u003c1\u003e(s[j]), s_r = get\u003c2\u003e(s[j]); for (int dx = -s_r; dx \u003c= s_r; dx++) { for (int dy = -s_r; dy \u003c= s_r; dy++) { if (s_x + dx \u003e= 0 \u0026\u0026 s_x + dx \u003c 10000 + 5 \u0026\u0026 s_y + dy \u003e= 0 \u0026\u0026 s_y + dy \u003c 10000 + 5) { // double check the name of variables is correct if (dx * dx + dy * dy \u003c= s_r * s_r) { board[s_x + dx][s_y + dy] = false; } } } } } int ret = 0; for (int i = 0; i \u003c n; i++) { int g_x = get\u003c0\u003e(g[i]), g_y = get\u003c1\u003e(g[i]); if (board[g_x][g_y]) { ret += 1; } } cout \u003c\u003c ret; return 0; } ","date":"2021-01-29","objectID":"/coding_practice_4/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 4","uri":"/coding_practice_4/"},{"categories":["OJ Problem"],"content":"OJ 2","date":"2021-01-28","objectID":"/coding_practice_3/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"OJ Practice 3, share my solution for these three OJ problems. ","date":"2021-01-28","objectID":"/coding_practice_3/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"NCPC 2011 Problem B: Mega Inversion using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { const int N = 2 * 1e5 + 10; const int origin = 1e5 + 10; public: vector\u003cll\u003e countLarger(vector\u003cint\u003e\u0026 nums){ vector\u003cll\u003e segtree(2 * N + 2, 0); reverse(nums.begin(), nums.end()); for(int i = 0; i \u003c nums.size(); ++i){ nums[i] = -nums[i]; } vector\u003cll\u003e result; for (int i = nums.size()-1; i \u003e= 0; i--) { result.push_back(rangeQuery(segtree, origin + nums[i])); update(segtree, origin + nums[i]); } return result; } vector\u003cll\u003e countSmaller(vector\u003cint\u003e\u0026 nums) { vector\u003cll\u003e segtree(2*N + 2, 0); vector\u003cll\u003e result; for (int i = nums.size()-1; i \u003e= 0; i--) { result.push_back(rangeQuery(segtree, origin + nums[i])); update(segtree, origin + nums[i]); } // need to reverse result reverse(result.begin(), result.end()); return result; } void update(vector\u003cll\u003e\u0026 segtree, int index) { for (index += N; index \u003e 0; index \u003e\u003e= 1) { segtree[index]++; } } ll rangeQuery(vector\u003cll\u003e\u0026 segtree, int entry) { int left = 0; int right = entry; ll result = 0; for (left += N, right += N; left \u003c right; left \u003e\u003e= 1, right \u003e\u003e= 1) { if(entry == 6 + origin){ } if (left%2 == 1) result += segtree[left++]; if (right%2 == 1) result += segtree[--right]; } return result; } }; int main() { Solution s; int n; cin \u003e\u003e n; vector\u003cint\u003e nums; int t; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e t; nums.push_back(t); } vector\u003cll\u003e smaller = s.countSmaller(nums); vector\u003cll\u003e larger = s.countLarger(nums); ll ret = 0; for(int i = 0; i \u003c larger.size(); i ++){ ret += (larger[i] * smaller[i]); } cout \u003c\u003c ret; return 0; } ","date":"2021-01-28","objectID":"/coding_practice_3/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 3","uri":"/coding_practice_3/"},{"categories":["OJ Problem"],"content":"OJ 2","date":"2021-01-27","objectID":"/coding_practice_2/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"OJ Practice 2, share my solution for these three OJ problems. ","date":"2021-01-27","objectID":"/coding_practice_2/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"Robots on a grid using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { public: int test() { } }; int solve(vector\u003cvector\u003cint\u003e\u003e\u0026 board){ int m = board.size(), n = board[0].size(); int step = 0; vector\u003cint\u003e dirs = {0, 1, 0, -1, 0}; set\u003cint\u003e seen; deque\u003cint\u003e q; q.push_back(0); seen.insert(0); while(q.size()){ int size = q.size(); for(int i = 0; i \u003c size; i++){ int p = q.front(); q.pop_front(); int r = p / n, c = p % n; if(r == m - 1 \u0026\u0026 c == n - 1){ return step; } else{ for(int i = 0; i \u003c 4; i++){ int nr = r + (board[r][c] * dirs[i]), nc = c + (board[r][c] * dirs[i + 1]); if(nr \u003e= 0 \u0026\u0026 nr \u003c m \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n){ int np = nr * n + nc; if(seen.find(np) == seen.end()){ seen.insert(np); q.push_back(np); } } } } } step += 1; } return -1; } int main() { int m, n; cin \u003e\u003e m \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e board(m, vector\u003cint\u003e(n, 0)); char c; for(int i = 0; i \u003c m; i++){ for(int j = 0; j \u003c n; j++){ cin \u003e\u003e c; board[i][j] = c - '0'; } } // for(int i = 0; i \u003c m; i++){ // for(int j = 0; j \u003c n; j++){ // cout \u003c\u003c board[i][j]; // } // } cout \u003c\u003c solve(board); return 0; } ","date":"2021-01-27","objectID":"/coding_practice_2/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"SERGRID - Grid using namespace std; #define ll long long #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int solve(vector\u003cvector\u003cunsigned int\u003e\u003e\u0026 board){ int n = board.size() - 1; for(int i = 1; i \u003c= n; i++){ for(int j = 1; j \u003c= n; j++){ if(board[i][j] == -1){ board[i][j] = 0; } else{ board[i][j] = (board[i][j - 1] % 0x7FFFFFFF + board[i - 1][j] % 0x7FFFFFFF) % 0x7FFFFFFF; } } } return board[n][n]; } bool isValid(vector\u003cvector\u003cint\u003e\u003e\u0026 board){ int n = board.size(); // invalid board if(board[0][0] == -1){ return false; } vector\u003cint\u003e dirs = {0, 1, 0, -1, 0}; // r * n + c set\u003cint\u003e seen; deque\u003cint\u003e d; seen.insert(0); d.push_back(0); while(d.size()){ int p = d.front(); d.pop_front(); int r = p / n, c = p % n; if(r == n - 1 \u0026\u0026 c == n - 1){ return true; } else{ for(int i = 0; i \u003c dirs.size() - 1; i++){ int nr = r + dirs[i], nc = c + dirs[i + 1]; if(nr \u003e= 0 \u0026\u0026 nr \u003c n \u0026\u0026 nc \u003e= 0 \u0026\u0026 nc \u003c n \u0026\u0026 board[nr][nc] == 0){ int np = nr * n + nc; if(seen.find(np) == seen.end()){ seen.insert(np); d.push_back(np); } } } } } return false; } int main() { int n; char c; cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e validBoard(n, vector\u003cint\u003e(n, 0)); vector\u003cvector\u003cunsigned int\u003e\u003e board(n + 1, vector\u003cunsigned int\u003e(n + 1, 0)); for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c n; j++){ cin \u003e\u003e c; if(c == '.'){ board[i + 1][j + 1] = 0; validBoard[i][j] = 0; } else{ board[i + 1][j + 1] = -1; validBoard[i][j] = -1; } } } if(isValid(validBoard) == false){ cout \u003c\u003c \"INCONCEIVABLE\"; return 0; } board[0][1] = 1; int ret = solve(board); if (ret != 0){ cout \u003c\u003c ret; } else{ if(isValid(validBoard) == false){ cout \u003c\u003c \"INCONCEIVABLE\"; return 0; } else{ cout \u003c\u003c \"THE GAME IS A LIE\"; } } return 0; } ","date":"2021-01-27","objectID":"/coding_practice_2/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 2","uri":"/coding_practice_2/"},{"categories":["OJ Problem"],"content":"OJ 1","date":"2021-01-26","objectID":"/coding_practice_1/","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"OJ Practice 1, share my solution for these three OJ problems. ","date":"2021-01-26","objectID":"/coding_practice_1/:0:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2013 Problem E: Timebomb #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int main() { string s; vector\u003cstring\u003e l; for(int i = 0; i \u003c 5; ++i){ std::getline (std::cin,s); l.push_back(s); } // for(string s : l){ // cout \u003c\u003c s \u003c\u003c endl; // } vector\u003cstring\u003e num_str = {\"75557\", \"11111\", \"71747\", \"71717\", \"55711\", \"74717\", \"74757\", \"71111\", \"75757\", \"75717\"}; unordered_map\u003cstring, int\u003e ref; for(int i = 0; i \u003c num_str.size(); ++i){ ref[num_str[i]] = i; } long long num = 0; vector\u003cint\u003e number; for(int i = 0; i \u003c l[0].size(); i += 4){ string s = \"\"; for(int k = 0; k \u003c 5; k++){ int counter = 0; for(int j = 0; j \u003c 3; j++){ if(l[k][i + j] == '*'){ counter += pow(2, 2- j); } } s += to_string(counter); } if(ref.find(s) == ref.end()){ cout \u003c\u003c \"BOOM!!\"; return 0; } else{ number.push_back(ref[s]); } } for(int i = 0; i \u003c number.size(); i += 1){ num = num * 10 + number[i]; } if(num % 6 == 0){ cout \u003c\u003c \"BEER!!\"; return 0; } else{ cout \u003c\u003c \"BOOM!!\"; return 0; } return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:1:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2015 Problem C: Cryptographerâ€™s Conundrum #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; int solve(string s){ int counter = 0; vector\u003cchar\u003e ref = {'P', 'E', 'R'}; for(int i = 0; i \u003c s.length(); ++i){ if(s[i] != ref[i % 3]){ counter += 1; } } return counter; } int main() { string s; cin \u003e\u003e s; cout \u003c\u003c solve(s) \u003c\u003c \"\\n\"; return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:2:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["OJ Problem"],"content":"NCPC 2011 Problem E: ls #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003csstream\u003e#include \u003cnumeric\u003e#include \u003cclimits\u003e#include \u003ccctype\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cqueue\u003e#include \u003clist\u003e#include \u003cmap\u003e#include \u003cset\u003e#include \u003cunordered_map\u003e#include \u003cunordered_set\u003e#include \u003ciostream\u003e#include \u003cfstream\u003eusing namespace std; #define ll long long #define pb push_back #define pf push_front #define mp make_pair #define F first #define S second #define mod 1000000007 #define vl vector\u003cll\u003e #define vi vector\u003cint\u003e #define pli pair\u003cll, int\u003e #define pil pair\u003cint, ll\u003e #define vpil vector\u003cpil\u003e #define vpli vector\u003cpli\u003e #define ml map\u003cll, ll\u003e #define mi map\u003cint, int\u003e #define m(a, b) map\u003ca, b\u003e #define YesNo(f) \\ if (f) \\ { \\ cout \u003c\u003c \"YES\" \u003c\u003c endl; \\ } \\ else \\ { \\ cout \u003c\u003c \"NO\" \u003c\u003c endl; \\ } #define setval(a, val) memset(a, val, sizeof(a)) #define fastIO \\ ios_base::sync_with_stdio(false); \\ cin.tie(0); \\ cout.tie(0) #define INF 1e12 //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; /* *.* 4 main.c a.out readme yacc */ bool solve(string s, string p){ int s_len = s.length(), p_len = p.length(); vector\u003cvector\u003cbool\u003e\u003e dp(s_len + 1, vector\u003cbool\u003e(p_len + 1, false)); dp[0][0] = true; for(int j = 1; j \u003c= p_len; ++j){ if(p[j - 1] == '*'){ dp[0][j] = dp[0][j-1]; } else{ dp[0][j] = false; } } for(int i = 1; i \u003c= s_len; ++i){ for(int j = 1; j \u003c= p_len; ++j){ if(p[j-1] == '*'){ dp[i][j] = dp[i-1][j] || dp[i][j-1] || dp[i-1][j-1]; } else{ if(p[j-1] == s[i-1]){ dp[i][j] = dp[i-1][j-1]; } else{ dp[i][j] = false; } } } } return dp[s_len][p_len]; } int main() { int n = 0; string p, s; cin \u003e\u003e p; cin \u003e\u003e n; vector\u003cstring\u003e l; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e s; if(solve(s, p)){ l.push_back(s); } } for(string s : l){ cout \u003c\u003c s \u003c\u003c endl; } return 0; } ","date":"2021-01-26","objectID":"/coding_practice_1/:3:0","tags":["wi21-week4","Implementation"],"title":"OJ Practice 1","uri":"/coding_practice_1/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 315 - Count of Smaller Numbers After Self","date":"2021-01-23","objectID":"/leetcode_315/","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Use Segment Tree to solve Leetcode 315 - Count of Smaller Numbers After Self. ","date":"2021-01-23","objectID":"/leetcode_315/:0:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 315 You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. ","date":"2021-01-23","objectID":"/leetcode_315/:1:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 315 Example1: Input: nums = [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. ","date":"2021-01-23","objectID":"/leetcode_315/:2:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 315 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class SegmentTreeNode(object): # range[min, max] def __init__(self, min, max): self.min = min self.max = max self.mid = (self.max - self.min) // 2 + self.min self.count = 0 self.right = None self.left = None class SegmentTree(object): def __init__(self, root): self.root = root def update(self, value): self.updateHelper(value, self.root) def updateHelper(self, value, node): if node == None: return if value \u003c node.min or value \u003e node.max: return node.count += 1 if node.min == node.max: return working_mid = node.mid if node.left == None: node.left = SegmentTreeNode(node.min, working_mid) if node.right == None: node.right = SegmentTreeNode(working_mid + 1, node.max) if value \u003e working_mid: self.updateHelper(value, node.right) else: self.updateHelper(value, node.left) def queryRange(self, value): return self.queryRangeHelper(value, self.root) def queryRangeHelper(self, value, node): if node == None: return 0 if value \u003e= node.max: return node.count working_mid = node.mid if value \u003c= working_mid: return self.queryRangeHelper(value, node.left) else: return self.queryRangeHelper(value, node.right) + self.queryRangeHelper(value, node.left) class Solution: def countSmaller(self, nums: List[int]) -\u003e List[int]: if len(nums) == 0: return [] ret = [] root = SegmentTreeNode(min(nums), max(nums)) tree = SegmentTree(root) for i in range(len(nums) - 1, -1, -1): ret.append(tree.queryRange(nums[i] - 1)) tree.update(nums[i]) return ret[::-1] ","date":"2021-01-23","objectID":"/leetcode_315/:3:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"Problem Remark For each TreeNode, count refers to how many number between [max, min] O(nlogk) solution, where k is the max difference ","date":"2021-01-23","objectID":"/leetcode_315/:4:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_315","uri":"/leetcode_315/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 732 - My Calendar III","date":"2021-01-21","objectID":"/leetcode_732/","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Use Segment Tree to solve Leetcode 732 - My Calendar III. ","date":"2021-01-21","objectID":"/leetcode_732/:0:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 732 A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.) You are given some events [start, end), after each given event, return an integer k representing the maximum k-booking between all the previous events. Implement the MyCalendarThree class: MyCalendarThree() Initializes the object. int book(int start, int end) Returns an integer k representing the largest integer such that there exists a k-booking in the calendar. ","date":"2021-01-21","objectID":"/leetcode_732/:1:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 732 Example1: Input [\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"] [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]] Output [null, 1, 1, 2, 3, 3, 3] Explanation MyCalendarThree myCalendarThree = new MyCalendarThree(); myCalendarThree.book(10, 20); // return 1, The first event can be booked and is disjoint, so the maximum k-booking is a 1-booking. myCalendarThree.book(50, 60); // return 1, The second event can be booked and is disjoint, so the maximum k-booking is a 1-booking. myCalendarThree.book(10, 40); // return 2, The third event [10, 40) intersects the first event, and the maximum k-booking is a 2-booking. myCalendarThree.book(5, 15); // return 3, The remaining events cause the maximum K-booking to be only a 3-booking. myCalendarThree.book(5, 10); // return 3 myCalendarThree.book(25, 55); // return 3 ","date":"2021-01-21","objectID":"/leetcode_732/:2:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 732 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class TreeNode: # segment tree with lazy propogation for range max query # half-open interval [lo, hi) def __init__(self, low, high, val=0, lazy=0, leftChild = None, rightChild = None): self.low = low self.high = high # range max self.val = val # bookings to add to the children the next time children get visited self.lazy = lazy self.leftChild = leftChild self.rightChild = rightChild class MyCalendarThree: MIN_BOUND = 0 MAX_BOUND = 1e9 + 1 def __init__(self): self.root = TreeNode(MyCalendarThree.MIN_BOUND, MyCalendarThree.MAX_BOUND) def book(self, start: int, end: int) -\u003e int: # update the segment from top to down, using lazy propogation self.update(self.root, start, end) return self.root.val def update(self, node, start, end): # we found the match, increment the value and lazy to be propogated if node.low == start and node.high == end: node.val += 1 node.lazy += 1 return mid = (node.high - node.low) // 2 + node.low # top-down building the segment tree if node.leftChild == None and node.rightChild == None: node.leftChild = TreeNode(node.low, mid, node.lazy, node.lazy) node.rightChild = TreeNode(mid, node.high, node.lazy, node.lazy) else: node.leftChild.val += node.lazy node.leftChild.lazy += node.lazy node.rightChild.val += node.lazy node.rightChild.lazy += node.lazy node.lazy = 0 # after building the children, we are able to traverse downwards if mid \u003e= end: self.update(node.leftChild, start, end) elif mid \u003c= start: self.update(node.rightChild, start, end) else: self.update(node.leftChild, start, mid) self.update(node.rightChild, mid, end) node.val = max(node.leftChild.val, node.rightChild.val) return # credit to https://leetcode.com/problems/my-calendar-iii/discuss/1023625/Python-Segment-Tree-with-Lazy-Propagation ","date":"2021-01-21","objectID":"/leetcode_732/:3:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Leetcode Problem"],"content":"Problem Remark We treat this problem as segment tree(interval tree) where each book would trigger the building of tree To build the tree top-down, we utilize Lazy Propagation ","date":"2021-01-21","objectID":"/leetcode_732/:4:0","tags":["segment tree","wi21-week3"],"title":"Leetcode_732 My Calendar III","uri":"/leetcode_732/"},{"categories":["Data Structure"],"content":"This article reviews segment tree.","date":"2021-01-20","objectID":"/segment_tree/","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"This article reviews Segment Tree. Segment Tree ","date":"2021-01-20","objectID":"/segment_tree/:0:0","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Semantics This balanced tree data structure stores the aggregation of certain property within certain range. build(start, end, vals): construct the segment tree update(index, value): update the A[index] to value rangeQuery(start, end) query the aggregation of certain range [start, end] ","date":"2021-01-20","objectID":"/segment_tree/:0:1","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Implementation class SegmentTreeNode: def __init__(self, start, end, val, left=None, right=None): self.start = start self.end = end self.mid = start + (end - start) // 2 self.val = val self.left = left self.right = right class SegmentTree: def __init__(self, nums): self.nums = nums if self.nums: self.root = self.build(0, len(nums) - 1, nums) def build(self, start, end, nums): if start == end: return SegmentTreeNode(start, end, nums[start]) mid = (end - start) // 2 + start leftNode = self.build(start, mid, nums) rightNode = self.build(mid + 1, end, nums) return SegmentTreeNode(start, end, leftNode.val + rightNode.val, leftNode, rightNode) def update(self, index, value): self.updateHelper(self.root, index, value) def updateHelper(self, node, index, value): if node.start == index and node.end == index: node.val = value return if index \u003c= node.mid: self.updateHelper(node.left, index, value) else: self.updateHelper(node.right, index, value) node.val = node.left.val + node.right.val def queryRange(self, start, end): return self.queryRangeHelper(self.root, start, end) def queryRangeHelper(self, node, start, end): if node.start == start and node.end == end: return node.val elif end \u003c= node.mid: return self.queryRangeHelper(node.left, start, end) elif start \u003e node.mid: return self.queryRangeHelper(node.right, start, end) else: return self.queryRangeHelper(node.left, start, node.mid) + self.queryRangeHelper(node.right, node.mid + 1, end) ","date":"2021-01-20","objectID":"/segment_tree/:0:2","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Efficienty Analysis buil -\u003e O(n) update -\u003e O(log n) rangeQuery -\u003e ~ O(log n) ","date":"2021-01-20","objectID":"/segment_tree/:0:3","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Data Structure"],"content":"Remarks query range with mutable arrays ","date":"2021-01-20","objectID":"/segment_tree/:0:4","tags":["segment tree","wi21-week3"],"title":"Segment Tree review","uri":"/segment_tree/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 947 - Most Stones Removed with Same Row or Column","date":"2021-01-17","objectID":"/leetcode_947/","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 947 - Most Stones Removed with Same Row or Column. ","date":"2021-01-17","objectID":"/leetcode_947/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 947 On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed. ","date":"2021-01-17","objectID":"/leetcode_947/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 947 Example1: Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5 Explanation: One way to remove 5 stones is as follows: 1. Remove stone [2,2] because it shares the same row as [2,1]. 2. Remove stone [2,1] because it shares the same column as [0,1]. 3. Remove stone [1,2] because it shares the same row as [1,0]. 4. Remove stone [1,0] because it shares the same column as [0,0]. 5. Remove stone [0,1] because it shares the same row as [0,0]. Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane. Example2: Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3 Explanation: One way to make 3 moves is as follows: 1. Remove stone [2,2] because it shares the same row as [2,0]. 2. Remove stone [2,0] because it shares the same column as [0,0]. 3. Remove stone [0,2] because it shares the same row as [0,0]. Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane. Example3: Input: stones = [[0,0]] Output: 0 Explanation: [0,0] is the only stone on the plane, so you cannot remove it. ","date":"2021-01-17","objectID":"/leetcode_947/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 947 from collections import deque, Counter class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): # already inserted if p in self.parents: return True else: self.num_sets += 1 self.parents[p] = p self.sizes[p] = 1 return False def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, [p, q]) if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sets -= 1 class Solution: def removeStones(self, stones: List[List[int]]) -\u003e int: row_stone = {} # row -\u003e stone location col_stone = {} # col -\u003e stone location for stone in stones: i, j = stone[0], stone[1] location = (i, j) if i in row_stone: row_stone[i].add(location) else: row_stone[i] = set() row_stone[i].add(location) if j in col_stone: col_stone[j].add(location) else: col_stone[j] = set() col_stone[j].add(location) disjoint_set = UnionFind() all_stone = set() for stone in stones: i, j = stone[0], stone[1] location = (i, j) if disjoint_set.contains(location): continue else: # do a little bfs here to find all the connected component my_queue = deque() my_queue.append(location) row_seen = set() col_seen = set() while(len(my_queue) != 0): cur_loc = my_queue.pop() disjoint_set.insert(cur_loc) disjoint_set.union(cur_loc, location) all_stone.add(cur_loc) i, j = cur_loc[0], cur_loc[1] if i not in row_seen: row_seen.add(i) for stone in row_stone[i]: my_queue.append(stone) if j not in col_seen: col_seen.add(j) for stone in col_stone[j]: my_queue.append(stone) leader_size = {} for stone in all_stone: real_leader = disjoint_set.find(stone) if real_leader not in leader_size: leader_size[real_leader] = disjoint_set.sizes[real_leader] else: leader_size[real_leader] = disjoint_set.sizes[real_leader] ret = 0 for leader in leader_size: ret += (leader_size[leader] - 1) return ret ","date":"2021-01-17","objectID":"/leetcode_947/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"Problem Remark We define connected-compoent as the componet of stones share same col/row with at least 1 other stone in the graph STEP1, remember all the locations of the stones STEP2, create disjoint set that stores all connected-component together STEP3, for each connected component, we greedily pick the size-1 of that component ","date":"2021-01-17","objectID":"/leetcode_947/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_947 Most Stones Removed with Same Row or Column","uri":"/leetcode_947/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 827 - Making A Large Island","date":"2021-01-15","objectID":"/leetcode_827/","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 827 - Making A Large Island. ","date":"2021-01-15","objectID":"/leetcode_827/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). ","date":"2021-01-15","objectID":"/leetcode_827/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: [[1, 0], [0, 1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3. Example2: Input: [[1, 1], [1, 0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example3: Input: [[1, 1], [1, 1]] Output: 4 Explanation: Can't change any 0 to 1, only one island with area = 4. ","date":"2021-01-15","objectID":"/leetcode_827/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t : self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sets -= 1 return False class Solution: def largestIsland(self, grid: List[List[int]]) -\u003e int: dirs = [0, 1, 0, -1, 0] # Step1, union 1's and find 0's disjoint_set = UnionFind() all_zeros = set() ret = 0 m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == 1: base = i * n + j disjoint_set.insert(base) for t in range(len(dirs) - 1): if i + dirs[t] \u003e= 0 and i + dirs[t] \u003c m and j + dirs[t + 1] \u003e= 0 and j + dirs[t + 1] \u003c n and grid[i + dirs[t]][j + dirs[t + 1]] == 1: neighbour = (i + dirs[t]) * n + (j + dirs[t + 1]) disjoint_set.insert(neighbour) disjoint_set.union(neighbour, base) else: all_zeros.add((i, j)) # edge case, all 1's, just return the size of the grid if len(all_zeros) == 0: return m * n # for all possible zeros, try to flip it for zero in all_zeros: i, j = zero[0], zero[1] leader_size = {} for t in range(len(dirs) - 1): if i + dirs[t] \u003e= 0 and i + dirs[t] \u003c m and j + dirs[t + 1] \u003e= 0 and j + dirs[t + 1] \u003c n and grid[i + dirs[t]][j + dirs[t + 1]] == 1: leader = disjoint_set.find((i + dirs[t]) * n + (j + dirs[t + 1])) if leader in leader_size: continue else: leader_size[leader] = disjoint_set.sizes[leader] ret = max(ret, sum(list(leader_size.values())) + 1) return ret ","date":"2021-01-15","objectID":"/leetcode_827/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"Problem Remark Naive Approach tries all the zeros, and recompute the connected component Union Find helps us to find the size of the connected component without computing the graph again, O(n*m) ","date":"2021-01-15","objectID":"/leetcode_827/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_827 Making A Large Island","uri":"/leetcode_827/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 1722 - Minimize Hamming Distance After Swap Operations.","date":"2021-01-14","objectID":"/leetcode_1722/","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 1722 - Minimize Hamming Distance After Swap Operations. ","date":"2021-01-14","objectID":"/leetcode_1722/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 1722 You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 \u003c= i \u003c= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source. ","date":"2021-01-14","objectID":"/leetcode_1722/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 1722 Example1: Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output: 1 Explanation: source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example1: Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output: 2 Explanation: There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. ","date":"2021-01-14","objectID":"/leetcode_1722/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 1722 import random from collections import deque, Counter import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sizes = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.num_sizes += 1 self.parents[p] = p self.sizes[p] = 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return p def union(self, p, q): root_p, root_q = map(self.find, (p, q)) # this means that we found a redundant edge if root_p == root_q: return True else: small, large = sorted([root_p, root_q], key = lambda t: self.sizes[t]) self.parents[small] = large self.sizes[large] += self.sizes[small] self.num_sizes -= 1 return False class Solution: def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(source) for i in range(n): disjoint_set.insert(i) # build the union graph # in each group, the numbers can be placed anywhere for edge in allowedSwaps: disjoint_set.union(edge[0], edge[1]) # hashmap, # group leader -\u003e set[indices in that group] leader_member = {} print(disjoint_set.parents) for member, leader in disjoint_set.parents.items(): # This is the real leader for this member leader = disjoint_set.find(member) if leader in leader_member: leader_member[leader].add(member) else: leader_member[leader] = set([member]) print(leader_member) ret = 0 # for all the members, try to figure out the distance for members in leader_member.values(): source_numbers = [source[i] for i in members] target_numbers = [target[i] for i in members] ret += sum((Counter(source_numbers) - Counter(target_numbers)).values()) return ret ","date":"2021-01-14","objectID":"/leetcode_1722/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To solve this problem, we need to observe that if (0, 1) is exchangeable and (0, 2) is exchangeable, then any pair in (0, 1, 2) can be exchangeble. The remaining problem is how to detect connected components in the graph -\u003e use Union Find. Counter, the subclass of dictionary, supports many great opeartions. ","date":"2021-01-14","objectID":"/leetcode_1722/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_1722 Minimize Hamming Distance After Swap Operations","uri":"/leetcode_1722/"},{"categories":["Entertainment"],"content":"ç‰›æŒ¯åä¸‰éƒ¨æ›²","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/","tags":["moview review","chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Entertainment"],"content":"Stand Up, Donâ€™t Bend Over 1993 Back to Back, Face to Face 1994 Signal Left, Turn Right 1995 é—²æ¥æ— äº‹ï¼Œå†™ä¸€ç¯‡å½±è¯„ï¼Œè®°å½•ä¸€ä¸‹2021çš„å¼€å§‹ã€‚ å¶ç„¶çš„æœºä¼šçœ‹äº†ä¸€éƒ¨ååº”ä¸­å›½æ”¿æ²»ç”Ÿæ€çš„å°çŸ­ç¯‡ï¼Œä¹‹åæœ‰è¯„è®ºé‡Œæåˆ°ä¸€éƒ¨ã€ŠèƒŒé èƒŒï¼Œè„¸å¯¹è„¸ã€‹çš„ç”µå½±ï¼Œç®€å•çš„åå­—å¾€å¾€è—ç€ä¸å¹³å‡¡çš„æ•…äº‹ï¼Œyoutubeå’Œbç«™æœäº†ä¸€ä¸‹ï¼Œæœ‰ç‰ˆæƒï¼Œéšå³çœ‹äº†ä¸€ä¸‹ã€‚ è¿™ä¸‰éƒ¨ç”µå½±éƒ½ç”±ç‰›æŒ¯åä¸»æ¼”ï¼Œé»„å»ºæ–°æ‰§å¯¼ï¼Œç”¨å¹½é»˜çš„æ‰‹æ³•ååº”å½“æ—¶90å¹´ä»£çš„éƒ½å¸‚ç™¾æ€ã€ç»æµç”Ÿæ´»ï¼Œæ”¿æ²»ç”Ÿæ€ã€‚ã€ŠèƒŒé èƒŒï¼Œè„¸å¯¹è„¸ã€‹ã€Šç«™ç›´å–½ï¼Œåˆ«è¶´ä¸‹ã€‹ã€Šçº¢ç¯åœç»¿ç¯è¡Œã€‹åˆç§°â€œéƒ½å¸‚ç™¾æ€ä¸‰éƒ¨æ›²â€ã€‚ ã€ŠèƒŒé èƒŒï¼Œè„¸å¯¹è„¸ã€‹è®²è¿°çš„æ˜¯ä¸€ä¸ªæ–‡ç‰©é¦†çš„ç‹åŒç«‹å‰¯é¦†é•¿ï¼Œç»å°½è„‘æ±æƒ³ä¸Šä½ä¸€æŠŠæ‰‹çš„æ•…äº‹ã€‚é€šè¿‡ç‹å‰¯é¦†é•¿åœ¨å…¶è½¬æ­£è¿‡ç¨‹ä¸­ä¸€æ³¢ä¸‰æŠ˜çš„ç»å†ï¼Œååº”äº†ç°ä»£åŒ–ç¤¾ä¼šä¸­å¤æ‚å¾®å¦™çš„äººé™…å…³ç³»ä»¥åŠé”™ç»¼å¤æ‚çš„æ”¿æ²»ç”Ÿæ€ã€‚ç‰›æŒ¯åé¥°æ¼”çš„ç‹å‰¯é¦†é•¿æ˜¯ä¸€ä½æœ‰èƒ½åŠ›ï¼Œæ‡‚å¾—æ”¿æ²»æ‰‹æ®µçš„é¢†å¯¼ï¼Œéš¾èƒ½å¯è´µçš„æ˜¯ï¼Œç‰›çš„è¡¨æ¼”å±•ç°äº†äººçš„å¤æ‚æ€§ï¼ŒçŸ›ç›¾æ€§ã€‚å’Œå½“ä»Šç¤¾ä¼šç½‘ç»œä¸­è®¸å¤šçº¿æ€§çš„äººè®¾ä¸åŒï¼Œç°å®ä¸­äººçš„ç”Ÿæ´»æ˜¯å¯¹ç«‹ç»Ÿä¸€çš„ï¼Œåœ¨å­¦ä¼šä½¿ç”¨çŸ›ç›¾çš„è§‚ç‚¹çœ‹èº«è¾¹çš„é—®é¢˜ä¹‹åŒæ—¶ï¼Œè¾©è¯åœ°ç†è§£äººæ€§çš„å¤æ‚ã€‚ä»¥åŠå¥å…†æ°é¥°æ¼”çš„ä¼šè®¡åœ¨å¤šæ¬¡å€’æˆˆä¸­ä½“ç°å‡ºâ€œæ²¡æœ‰æ°¸è¿œçš„ç›Ÿå‹ï¼Œåªæœ‰æ°¸è¿œçš„åˆ©ç›Šâ€è¿™ç‚¹ç°å®ï¼Œå€¼å¾—å›å‘³ã€‚ ã€Šç«™ç›´å–½ï¼Œåˆ«è¶´ä¸‹ã€‹æè¿°äº†â€œæµæ°“â€å¼ æ°¸æ­¦ï¼ˆç‰›æŒ¯åé¥°ï¼‰é€šè¿‡å…»é±¼å‘å®¶è‡´å¯Œï¼Œé€šè¿‡è‡ªå·±çš„åŠªåŠ›å’Œæ•¢äºæ‹¼æçš„ç²¾ç¥æˆä¸ºé‚£æ ‹æ¥¼é‡Œæœ€æœ‰æ’é¢çš„äººã€‚åŸå…ˆçœ‹ä¸èµ·å¼ æ°¸æ­¦çš„åˆ˜å¹²éƒ¨ï¼ˆè¾¾å¼å¸¸é¥°ï¼‰å’Œç”±é«˜ä½œå®¶ï¼ˆå†¯å·©é¥°ï¼‰æœ€ç»ˆåœ¨åˆ©ç›Šçš„è¶‹åŠ¿ä¸‹ï¼Œåƒæ‰€è°“çš„ç‰©è´¨ç”Ÿæ´»ä½å¤´ï¼Œæ”¹å˜äº†å¯¹å¼ æ°¸æ­¦åŸå…ˆâ€œåœ°ç—æµæ°“â€çš„æ ‡ç­¾ã€‚ç”µå½±ååº”äº†å½“æ—¶ç¤¾ä¼šâ€œæœ‰é’±æ²¡æ–‡åŒ–ï¼Œæœ‰æ–‡åŒ–æ²¡é’±â€ï¼Œå¼ æ°¸æ­¦çš„æ¸”ä¸šå…¬å¸å‘å±•å£®å¤§åï¼Œè¦æ±‚é«˜ä½œå®¶æ¬å‡ºè¿™æ ‹æ¥¼ï¼Œåœ¨å¼ æ°¸æ­¦ä¸€ç³»åˆ—ç›˜å¤–æ‹›çš„å¹²æ‰°ä¸‹ï¼Œé«˜ä½œå®¶è¿å¤œæ¬å®¶ï¼Œæœ€åé«˜ä½œå®¶è¹²åœ¨åœ°ä¸Šæ”¶æ‹¾ä¸œè¥¿çš„é•œå¤´ï¼ŒæŠ›å‡ºæ–‡åŒ–äººæ˜¯å¦å‘ç‰©è´¨ä½å¤´è¿™ä¸ªå‘½é¢˜ã€‚ ã€Šçº¢ç¯åœç»¿ç¯è¡Œã€‹è®²è¿°çš„æ˜¯å­¦è½¦æ—¶å‘ç”Ÿçš„ä¸€ç³»åˆ—æ•…äº‹ï¼Œã€€è®°è€…è‹Ÿå®‡ä½³ï¼ˆç‰›æŒ¯å é¥°ï¼‰ã€ä¸‹å²—å¥³å·¥ç¨‹èŠ¬ï¼ˆä¸å˜‰ä¸½ é¥°ï¼‰ã€ä¸ªä½“æˆ·ç»¿è±†ï¼ˆç‹åŠ²æ¾ é¥°ï¼‰ã€å¤§æ¬¾è€å·®ï¼ˆå¥å· é¥°ï¼‰æ˜¯é©¾æ ¡1025ç­çš„æˆå‘˜ï¼Œåœ¨é€€ä¼å†›äººä¾¯æ•™ç»ƒæ‰‹ä¸‹ç»ƒä¹ ã€‚éšç€æ—¶é—´çš„æ¨ç§»ï¼Œå¤§å®¶æ¸æ¸æ‘¸æ¸…å½¼æ­¤çš„ä¹ æ€§ã€‚è®°è€…å°è‹Ÿå…«é¢ç²ç‘ï¼Œå¤„äº‹åœ†æ»‘ï¼Œä¸€å¿ƒæƒ³æŠŠå­¦è½¦è´¹æŠ¥é”€ï¼Œç»“æœå¤©ä¸é‚äººæ„¿ï¼›å¾…ä¸šå¥³å·¥é˜¿èŠ¬è¢«ä¸‹æµ·çš„ä¸ˆå¤«å‘æ¥ç¦»å©šçš„ä¼ ç¥¨ï¼Œä¸€äººå¸¦ç€å¥³å„¿ï¼Œè€å®åº¦æ—¥ï¼›æ—©å¹´ä¸§çˆ¶ï¼Œæ¯äº²ç˜«ç—ªåœ¨åºŠçš„ç»¿è±†æ²¾æŸ“ä¸Šäº†æ¯’å“ï¼Œç™½å¤©å­¦è½¦ï¼ŒåŠå¤œå·äº•ç›–ï¼Œå´æ˜¯ä¸ªå­é¡ºå„¿å­ï¼›å¤§æ¬¾è€å·®åˆ™æ˜¯ä¸ªæ‰“ç€ç›¹å„¿éƒ½èƒ½èµšä¸Šåä¸‡ã€å…«ä¸‡çš„æœ‰é’±äººï¼Œä¸æŠŠé©¾æ ¡è§„å®šæ”¾åœ¨çœ¼é‡Œï¼›ä¾¯æ•™ç»ƒçš„æ•™ç»ƒèº«ä»½ä¸ºä»–å¸¦æ¥äº†å…è´¹çš„é¦™çƒŸå’Œèµšå›æ‰£çš„æœºä¼šï¼Œä¹Ÿå› æ­¤å¼•ç«çƒ§èº«ï¼Œå¼„å¾—å®¶é‡Œé¸¡çŠ¬ä¸å®ã€‚ è¿™æ®µé©¾æ ¡ç”Ÿæ´»ï¼Œæ³¢æŠ˜è¿è¿ï¼Œå´éƒ½ä¸€ä¸€åŒ–é™©ä¸ºå¤·ï¼Œ5äººé—´çš„æš—æˆ˜æ˜æˆ˜ä¹Ÿéƒ½éšç€è€ƒè¯•çš„é¡ºåˆ©é€šå…³è€Œç»“æŸã€‚è¿™æ®µé©¾æ ¡çš„ç»å†ç‰µæ‰¯å‡ºäº†5ä¸ªäººçš„æ‚²å–œï¼Œé™¤äº†å­¦åˆ°äº†é©¾é©¶è§„åˆ™ï¼Œä¼¼ä¹æ›´å­¦åˆ°äº†ç”Ÿå­˜æ³•åˆ™ã€‚credit to è±†ç“£ æ€»çš„æ¥è¯´ï¼Œè¿™ä¸‰ç¯‡ç”µå½±é£æ ¼ç±»ä¼¼ï¼Œå¤§è‡´éƒ½æè¿°äº†é”™ç»¼å¤æ‚çš„äººé™…å…³ç³»å’Œç°ä»£åŒ–ç¤¾ä¼šçš„ä¸€äº›æ‹œé‡‘ä¸»ä¹‰è‹—å¤´ã€‚äººæ˜¯å¤æ‚çš„è€Œéçº¿æ€§çš„ï¼Œç”Ÿæ´»æ˜¯çŸ›ä¸ç›¾çš„ç»“åˆã€‚ç½‘ç»œå¾ˆå®¹æ˜“è®©äººé™·å…¥ä¸€ç§å•çº¯çš„æ€è€ƒçŠ¶æ€ï¼Œè®¤ä¸ºæ‰€æœ‰äº‹ç‰©éƒ½æ˜¯çº¿æ€§çš„ï¼Œè´´æ ‡ç­¾ä¼¼çš„ç†è§£äº‹æƒ…ï¼Œè¿™æ ·æ˜¾ç„¶å¾ˆç®€å•ï¼Œä¹Ÿå¾ˆå®¹æ˜“ï¼Œä½†å†™åˆ°è¿™é‡Œï¼Œä¹Ÿæƒ³åˆ°ç™¾åº¦CEOæå½¦å®æ›¾å¯¹æ¨èç®—æ³•æœ‰ä¸€ç•ªè¯´è¾ï¼Œå¤§è‡´æè¿°è¯´æ¨èç®—æ³•ä½¿å¾—ç½‘æ°‘å¤±å»å¤šæ ·æ€§ï¼Œåœ¨è®¡ç®—äº†ç›¸ä¼¼åº¦ä»¥åï¼Œç”¨æˆ·å–œæ¬¢XXå°±ä¸€ç›´æ¨é€XXï¼Œå¦‚æœå¹³å°ä¸€ç›´éƒ½æ˜¯â€œæŠ•å…¶æ‰€å¥½â€,æŠŠç”¨æˆ·å›°åœ¨ä¸€ä¸ªåœˆå­é‡Œï¼Œä¸§å¤±äº†è·å¾—å¤šæ ·æ€§çš„æœºä¼šï¼Œä¹Ÿä½¿å¾—å¾ˆå¤šç”¨æˆ·å¤±å»äº†è¾©è¯æ€ç»´ã€‚æ±Ÿæ³½æ°‘æ€»ä¹¦è®°æ›¾è¯´è¿‡ â€œå¯¹ç°å®ç¤¾ä¼šä¸­çš„é—®é¢˜ï¼Œæˆ‘ä»¬è¦è¿›è¡Œç†æ€§çš„æ€è€ƒã€‚å› ä¸ºæˆ‘ä»¬çœ‹åˆ°çš„ç°è±¡ï¼Œå…¶ä¸­æœ‰çš„æ˜¯çœŸç›¸ï¼Œæœ‰çš„å´æ˜¯å‡è±¡ã€‚åªæœ‰æŠŠæ„Ÿæ€§ä¸Šå‡åˆ°ç†æ€§ï¼Œæ‰èƒ½æ·±åŒ–è®¤è¯†ï¼Œæ‰èƒ½æŠŠæ¡äº‹ç‰©çš„æœ¬è´¨ã€‚â€è¿™å‡ éƒ¨ç”µå½±åœ¨æ¶ˆé£æ—¶é—´çš„åŒæ—¶ï¼Œä¹Ÿæ•²å“äº†è¾©è¯æ€è€ƒçš„è­¦é’Ÿï¼Œä½†ä»å¤´è®ºï¼Œæœ¬äººä¹Ÿæ˜¯è¢«æ¨èç®—æ³•å¸¦è¿›è¿™äº›ç”µå½±çš„ï¼Œä¸å…æœ‰äº›è®½åˆºã€‚ å¸Œæœ›ä»¥åæ€è€ƒé—®é¢˜èƒ½å¤Ÿæ·±å…¥æœ¬è´¨ï¼Œåˆ«å¤ªç‹­éš˜ã€‚ ","date":"2021-01-13","objectID":"/%E5%BD%B1%E8%AF%841/:0:0","tags":["moview review","chinese"],"title":"Movie Review, Zhenhua Niu","uri":"/%E5%BD%B1%E8%AF%841/"},{"categories":["Leetcode Problem"],"content":"This article solves Leetcode 547 - Number of Provinces.","date":"2021-01-13","objectID":"/leetcode_547/","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Use Union Find to solve Leetcode 547 - Number of Provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:0:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Description Leetcode 547 There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces. ","date":"2021-01-13","objectID":"/leetcode_547/:1:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Examples Test Cases Leetcode 547 Example1: Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]] Output: 2 Example2: Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]] Output: 3 ","date":"2021-01-13","objectID":"/leetcode_547/:2:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Solution Leetcode 547 import random from collections import deque import math import functools import bisect from typing import List import heapq class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 class Solution: def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: disjoint_set = UnionFind() n = len(isConnected) for i in range(n): disjoint_set.insert(i) for i in range(n): for j in range(n): if isConnected[i][j]: disjoint_set.union(i, j) return disjoint_set.num_sets ","date":"2021-01-13","objectID":"/leetcode_547/:3:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Leetcode Problem"],"content":"Problem Remark To find the connected component in undirected graph, Union Find(Disjoint Set) is the handy data structure to use. ","date":"2021-01-13","objectID":"/leetcode_547/:4:0","tags":["union find","wi21-week2"],"title":"Leetcode_547 Number of Provinces","uri":"/leetcode_547/"},{"categories":["Data Structure"],"content":"This article reviews union find.","date":"2021-01-12","objectID":"/union_find/","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"This article reviews Union Find(Disjoint Set). Union Find | Disjoint Set ","date":"2021-01-12","objectID":"/union_find/:0:0","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Semantics This data structure stores the collection of disjoint(non-overlapping) sets(groups). find(p): find the leader of group that contains p union(p, q): merge two groups ","date":"2021-01-12","objectID":"/union_find/:0:1","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Implementation class UnionFind(object): def __init__(self): self.num_sets = 0 self.parents = {} self.sizes = {} def contains(self, p): return p in self.parents def insert(self, p): if self.contains(p): return else: self.parents[p] = p self.sizes[p] = 1 self.num_sets += 1 def find(self, p): if p != self.parents[p]: self.parents[p] = self.find(self.parents[p]) p = self.parents[p] return self.parents[p] def union(self, p, q): root_p, root_q = self.find(p), self.find(q) if root_p == root_q: return else: if self.sizes[root_p] \u003e self.sizes[root_q]: small_root = root_q large_root = root_p else: small_root = root_p large_root = root_q self.parents[small_root] = large_root self.sizes[large_root] += self.sizes[small_root] self.num_sets -= 1 ","date":"2021-01-12","objectID":"/union_find/:0:2","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Efficienty Analysis O(n) in memory, O(1) for union and look up in amortized analysis ","date":"2021-01-12","objectID":"/union_find/:0:3","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":["Data Structure"],"content":"Remarks Check whether two elements belong to the same group. To find connected components in graph (usually undirected) Speed up implementation of kruskalâ€™s algorithm ","date":"2021-01-12","objectID":"/union_find/:0:4","tags":["union find","wi21-week2"],"title":"Union Find Review","uri":"/union_find/"},{"categories":null,"content":" Welcome to Â Haihao Sunâ€™s field! Self Introduction Haihao SunTravelling \" Travelling Hi there! I am Haihao Sun, and my hobbies come and go. I enjoy travelling, playing Go, playing pokemon, and developing(AKA coding). I was born in Nanjing, and I currently live in San Diego . Skills JavaScript SQL C/C++ Â Java Python Extended Links Linkedin Blog Version I Github ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Page","uri":"/about/"}]